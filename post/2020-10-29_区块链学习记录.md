
<!-- vim-markdown-toc GitLab -->

* [区块链的一些概念](#区块链的一些概念)
* [区块链技术基础](#区块链技术基础)
    * [密码学原理](#密码学原理)
        * [哈希算法性质](#哈希算法性质)
        * [数字签名](#数字签名)
    * [*区块链数据结构](#区块链数据结构)
        * [Hash Pointer](#hash-pointer)
        * [Merkle Tree](#merkle-tree)
    * [共识协议](#共识协议)

<!-- vim-markdown-toc -->

# 区块链的一些概念

> 引用自<区块链实战：从技术创新到商业模式>

因为区块链是一个从工程出发的新的技术，一些概念尚未确定下来。下面是本人根据书籍总结得来。



**区块链**

- 是一种无中心节点的分布式数据库，各个全节点保存着完整的数据，并且存储操作的效率很低且容量不应大。

- 主要特性包括：分布式数据库，共识算法，点对点通信，数据公开，数字签名的自主账户，智能合约。

- 通过共识算法提供节点间的一致性，通过哈希算法和非对称加密算法保证数据的可验证能力。<br>这两个技术是难以篡改数据的基础。

  

**账本**

- 是交易数据组成的数据集合。



**共识机制**

- 是一类分布式一致性算法(注意FLP不可能结果和CAP理论)，但基于部分节点不是诚实的这个条件。
- 目的是维护各个节点的一致性。
- 效率必然低于集中式数据库，高性能不是区块链中共识规则的根本目的。



**公链 / 私链 / 联盟链**

- 即所有人都可以参与的区块链 / 获得许可的用户参与的区块链(各种操作具有权限控制)
- 公链对共识机制要求很高，需要可靠性杜绝恶意节点。<br>非公链对共识机制要求低，结合其他权限规则等可以保证数据安全和一致性。



**点对点通信的发展**

- BitTorrent协议：将文件分割成大小相等的区域，并将每个块的索引和哈希值记录于种子文件。下载者根据自己持有的块信息，和对等方交换数据。
- Kademlia协议：基于分布式哈希表。根据节点的ID异或值划分自树构建路由表建立网络，更加高效。
- 比特币协议：基于P2P协议技术。
- 以太坊：基于Kademlia技术。



**自主账户**

- 账户的创建是指生成一对公钥和私钥。<br>公钥用于证明自己是一个不同于其他账户的信息。<br>私钥用于证明数据是否真实。
- 公钥与现实中的人是无法对应的。但是大数据技术和执法机构等，可以根据使用公钥产生的交易特征来识别出现实中的人。
- (注意：私钥专门用于解密向自己发来的消息。如果用公钥解密向自己发来的消息，那么中间人可随意查看。)



**区块链的分类**

- 专用区块链：区块链，数字货币和比特币应用三者结合。如比特币和各种分叉币。
- 可扩展区块链：通过智能合约提供可编程和可扩展能力。如以太坊，R3 Codra。
- 模块化区块链：区块链被组件化，可以被替代和启用。如 Hyperledger Fabric。



**区块链发展**

- 区块链1.0：区块链网络，单一协议和应用三者结合。
- 区块链2.0：增加了可以运行智能合约的程序，提供可编程和可扩展能力。
- 区块链3.0：区块链作为基础设施，支持各行各业。



# 区块链技术基础

> 主要引用自<区块链技术与应用>公开课 北京大学肖臻

> <https://blog.csdn.net/Mu_Xiaoye/article/details/104299664>



## 密码学原理



### 哈希算法性质

**Collision Resistance**

- 如果有Hash(x)!=Hash(y)，必然可以得到x!=y。

- 或者说如果x=y，则Hash(x) == Hash(y)。

  

**Hiding**

- 能够由x推出H(x)， 但是难以从H(x) 推到 x。
- hiding成立的前提是输入的x空间，足够大，人们才无法使用暴力法来求解出x。



**Digital Commitment(数据保证)**

- 由collision resistance和hiding结合实现。

- 某个人对某个股票进行涨停预测，我们如何保证能够知晓其预测是否准确？<br>当提前发布预测后，可能会由于预测者本身对股市实际结果造成影响。<br>所以，应该将提前将其写于纸上并密封，交给第三方机构保管，等到实际结果出现后开启密封与实际对比，而第三方机构需要能够使人信服。<br>在实际生活中，有很多场景并不存在一个这样的第三方机构，而区块链技术正为此提供了一个很好的解决方法。



**Puzzle Friendly**

- 该性质要求哈希值计算事先不可预测，仅仅根据输入很难预测出输出。
- 例如：我们需要一个哈希值，存在于某一个范围内，只能通过不停运算查找出来。该性质保证了工作量证明(POW)机制可以运行。



### 数字签名

- 公钥和私钥的应用保证了“签名”的应用。
- 当在比特币网络中进行转账时，通过“签名”可以明确是由哪个账户转出的，从而防止不良分子对其他账户比特币的盗取。
- 在发布交易时，通过自己私钥签名，其他人可以根据公钥进行验证，从而保证该交易由自己发起。<br>私钥在这里的作用是，声明比特币是从自己转出的(只能用对应公钥成功验证)。<br>



## *区块链数据结构

> https://www.jianshu.com/p/330736abc7e7

> 具体比特币结构 未总结



### Hash Pointer

**哈希指针**

- 包括指向前一个区块的普通指针和数据哈希值的指针。
- 它保证了验证前一个数据真实性的能力。



**区块链数据结构**

- 由区块作为节点，由哈希指针作为链接的链表。
- 区块头部包括：版本号，前一个区块的哈希指针，Ｍarkle树的根哈希指针，挖矿难度target，随机数nonce；<br>区块体包括：交易列表<br>全节点保存整个区块的所有内容，而轻节点仅仅保存区块的块头信息。
- 区块必须保证以下规则，才能是一个有意义的区块:

  1. `Hash(Block Header) <= target`；

  2. `target`是协议中有效的；

  3. 在最长合法链上，即不是一个分支。


- 整个区块链保证了数据难以篡改的能力，前依法而动全身。




### Merkle Tree

**Merkle Tree**

- 将二叉树的非叶节点替换为哈希指针，叶节点替换为交易数据的树。
- 作用是提供Merkle Proof，即证明某个交易存在(可计算hash并能够索引到，即Hash Pointer)。<br>即根据其他节点提供的Merkle Tree的路径节点和自己节点的根哈希指针计算和比较。
- 排序Merkle Tree可以提供证明交易不存在的快速算法Ｏ(logn)：<br>即对每个交易节点的hash进行排序，二分查找该索引两边的节点，再进行Merkle Proof证明两个节点相邻。<br>(无中间交易即不存在目标交易)



**其他数据结构**

- 只要满足DAG即可，回环会有循环依赖。



## 共识协议

**分布式协议前置知识**

- FLP不可能结论：在一个异步系统中，网络时延无上限，即使只有一个成员是有问题的，也不可能达成共识。
- CAP理论：（Consistency一致性、Availability可靠性、Partition tolerance分区容错性），任何一个分布式系统中，最多只能满足其中两个性质。



**比特币的核心问题**

- 谁来发行币? <br>仅有创建区块的奖励，和处理交易的奖励。

- 如何验证货币合法性? 即处理**双花攻击**<br>

  依赖于系统中维护的一个数据结构，记录货币的来源和去向（是否被花过？被谁花过？给了谁？）。该数据结构由系统中全体用户共同维护，保证了交易的有效性。该数据结构，便是区块链。<br>（相见案例说明）

- 注意：交易双方都要提供自己的公钥。<br><s>付款人需要公钥（收款人提供）来进行转账；<br>收款人需要公钥（付款人提供）来验证区块签名的有效性，同时这个公钥需要与上一个区块哈希匹配（防止付款人偷窃）。</s>



**比特币共识协议**

- **女巫攻击**：如果基于用户数量投票机制，则某个节点可以生成大量公私钥对，当产生数量超过系统中一半数目，就可以获得支配地位。

- 如何获得记账权，并达成共识？：**根据算力投票，竞争记账权**

  在比特币系统中，每个节点都可以自行尝试各种nonce值组装一个候选区块（即挖矿），使`Hash(BH) <= target`。

- **分叉处理方法**：在发生分叉的情况下，暂时保存分叉情况，但区块链只承认最长合法链，随着时间推移，必然存在某一条链变成最长合法链。

- **分叉攻击**：因为大多数用户认可最长合法链，会沿着该链继续挖下去。而攻击者要想回退记录，就必须使得分叉链变得比原先的链还长。理论上来说，攻击者需要达到整个系统中51%的计算力。



**比特币激励机制**

- 区块创建奖励
  - 为什么系统中节点要竞争记账权？需要提供算力和电力成本，节点为什么要去做？
  - 比特币通过设置**出块奖励**来解决该问题，一个获得合法区块的节点，可以在区块中加入一个特殊交易（铸币交易）。
- 交易处理奖励
  - 为什么系统中节点要进行处理交易？
  - 引入**交易费**，在一个区块中，其输入>=输出，差值便是给区块所属节点的手续费。
