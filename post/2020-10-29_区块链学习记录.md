
<!-- vim-markdown-toc GitLab -->

* [区块链的一些概念](#区块链的一些概念)
* [区块链技术基础 - 从比特币入手](#区块链技术基础-从比特币入手)
    * [密码学原理](#密码学原理)
        * [哈希算法性质](#哈希算法性质)
        * [数字签名](#数字签名)
    * [区块链数据结构](#区块链数据结构)
        * [Hash Pointer](#hash-pointer)
        * [Merkle Tree](#merkle-tree)
    * [共识协议](#共识协议)
    * [比特币的账本](#比特币的账本)
        * [基于交易的账本](#基于交易的账本)
        * [基于账户的账本](#基于账户的账本)
        * [BTC系统中具体的区块信息](#btc系统中具体的区块信息)
        * [实际区块举例](#实际区块举例)
        * [统计学原理](#统计学原理)
        * [不诚实的节点](#不诚实的节点)
    * [比特币的网络基础](#比特币的网络基础)
    * [挖矿难度调整](#挖矿难度调整)
        * [BTC系统如何调整挖矿难度](#btc系统如何调整挖矿难度)
    * [矿池](#矿池)
        * [全节点和轻节点](#全节点和轻节点)
        * [挖矿设备演化 - 单节点的发展](#挖矿设备演化-单节点的发展)
        * [矿池的出现 - 多节点的发展](#矿池的出现-多节点的发展)
        * [51%算力矿池的攻击手段](#51算力矿池的攻击手段)
    * [比特币的脚本](#比特币的脚本)
        * [交易的数据结构](#交易的数据结构)
        * [输入输出脚本的计算方法](#输入输出脚本的计算方法)
    * [分叉](#分叉)
        * [硬分叉](#硬分叉)
        * [软分叉](#软分叉)
        * [总结](#总结)
    * [匿名性](#匿名性)
        * [什么情况会破坏其匿名性？](#什么情况会破坏其匿名性)
        * [如何提高匿名性？](#如何提高匿名性)
    * [零知识证明](#零知识证明)
        * [同态隐藏](#同态隐藏)
        * [盲签](#盲签)
        * [零钞和零币](#零钞和零币)
    * [一些比特币上的问题](#一些比特币上的问题)

<!-- vim-markdown-toc -->

# 区块链的一些概念

> 引用自<区块链实战：从技术创新到商业模式>

 因为区块链是一个从工程出发的新的技术，一些概念尚未确定下来。下面是本人根据书籍总结得来。



**区块链**

- 是一种无中心节点的分布式数据库，各个全节点保存着完整的数据，并且存储操作的效率很低且容量不应大。

- 主要特性包括：分布式数据库，共识算法，点对点通信，数据公开，数字签名的自主账户，智能合约。

- 通过共识算法提供节点间的一致性，通过哈希算法和非对称加密算法保证数据的可验证能力。<br>这两个技术是难以篡改数据的基础。

  

**账本**

- 是交易数据组成的数据集合。



**共识机制**

- 是一类分布式一致性算法(注意FLP不可能结果和CAP理论)，但基于部分节点不是诚实的这个条件。
- 目的是维护各个节点的一致性。
- 效率必然低于集中式数据库，高性能不是区块链中共识规则的根本目的。



**公链 / 私链 / 联盟链**

- 即所有人都可以参与的区块链 / 获得许可的用户参与的区块链(各种操作具有权限控制)
- 公链对共识机制要求很高，需要可靠性杜绝恶意节点。<br>非公链对共识机制要求低，结合其他权限规则等可以保证数据安全和一致性。



**点对点通信的发展**

- BitTorrent协议：将文件分割成大小相等的区域，并将每个块的索引和哈希值记录于种子文件。下载者根据自己持有的块信息，和对等方交换数据。
- Kademlia协议：基于分布式哈希表。根据节点的ID异或值划分自树构建路由表建立网络，更加高效。
- 比特币协议：基于P2P协议技术。
- 以太坊：基于Kademlia技术。



**自主账户**

- 账户的创建是指生成一对公钥和私钥。<br>公钥用于证明自己是一个不同于其他账户的信息。<br>私钥用于证明数据是否真实。
- 公钥与现实中的人是无法对应的。但是大数据技术和执法机构等，可以根据使用公钥产生的交易特征来识别出现实中的人。
- (注意：私钥专门用于解密向自己发来的消息。如果用公钥解密向自己发来的消息，那么中间人可随意查看。公钥也可以从私钥中推导出。)



**区块链的分类**

- 专用区块链：区块链，数字货币和比特币应用三者结合。如比特币和各种分叉币。
- 可扩展区块链：通过智能合约提供可编程和可扩展能力。如以太坊，R3 Codra。
- 模块化区块链：区块链被组件化，可以被替代和启用。如 Hyperledger Fabric。



**区块链发展**

- 区块链1.0：区块链网络，单一协议和应用三者结合。
- 区块链2.0：增加了可以运行智能合约的程序，提供可编程和可扩展能力。
- 区块链3.0：区块链作为基础设施，支持各行各业。



# 区块链技术基础 - 从比特币入手

> 主要引用自<区块链技术与应用>公开课 北京大学肖臻

> <https://blog.csdn.net/Mu_Xiaoye/article/details/104299664>



## 密码学原理



### 哈希算法性质

**Collision Resistance**

- 如果有Hash(x)!=Hash(y)，必然可以得到x!=y。

- 或者说如果x=y，则Hash(x) == Hash(y)。

  

**Hiding**

- 能够由x推出H(x)， 但是难以从H(x) 推到 x。
- hiding成立的前提是输入的x空间，足够大，人们才无法使用暴力法来求解出x。



**Digital Commitment(数据保证)**

- 由collision resistance和hiding结合实现。

- 某个人对某个股票进行涨停预测，我们如何保证能够知晓其预测是否准确？<br>当提前发布预测后，可能会由于预测者本身对股市实际结果造成影响。<br>所以，应该将提前将其写于纸上并密封，交给第三方机构保管，等到实际结果出现后开启密封与实际对比，而第三方机构需要能够使人信服。<br>在实际生活中，有很多场景并不存在一个这样的第三方机构，而区块链技术正为此提供了一个很好的解决方法。



**Puzzle Friendly**

- 该性质要求哈希值计算事先不可预测，仅仅根据输入很难预测出输出。
- 例如：我们需要一个哈希值，存在于某一个范围内，只能通过不停运算查找出来。该性质保证了工作量证明(POW)机制可以运行。



### 数字签名

- 公钥和私钥的应用保证了“签名”的应用。
- 当在比特币网络中进行转账时，通过“签名”可以明确是由哪个账户转出的，从而防止不良分子对其他账户比特币的盗取。
- 在发布交易时，通过自己私钥签名，其他人可以根据公钥进行验证，从而保证该交易由自己发起。<br>私钥在这里的作用是，声明比特币是从自己转出的(只能用对应公钥成功验证)。<br>



## 区块链数据结构

> https://www.jianshu.com/p/330736abc7e7

> 具体比特币结构 未总结



### Hash Pointer

**哈希指针**

- 包括指向前一个区块的<s>普通指针和</s>数据哈希值的指针。
- 它保证了验证前一个数据真实性的能力。



**区块链数据结构**

- 由区块作为节点，由哈希指针作为链接的链表。
- 区块头部包括：版本号，前一个区块的哈希指针，Ｍarkle树的根哈希指针，挖矿难度target，随机数nonce；<br>区块体包括：交易列表<br>全节点保存整个区块的所有内容，而轻节点仅仅保存区块的块头信息。
- 区块必须保证以下规则，才能是一个有意义的区块:

  1. `Hash(Block Header) <= target`；

  2. `target`是协议中有效的；

  3. 在最长合法链上，即不是一个分支。


- 整个区块链保证了数据难以篡改的能力，前依法而动全身。




### Merkle Tree

**Merkle Tree**

- 将二叉树的非叶节点替换为哈希指针，叶节点替换为交易数据的树。
- 作用是提供Merkle Proof，即证明某个交易存在(可计算hash并能够索引到，即Hash Pointer)。<br>即根据其他节点提供的Merkle Tree的路径节点和自己节点的根哈希指针计算和比较。
- 排序Merkle Tree可以提供证明交易不存在的快速算法Ｏ(logn)：<br>即对每个交易节点的hash进行排序，二分查找该索引两边的节点，再进行Merkle Proof证明两个节点相邻。<br>(无中间交易即不存在目标交易)



**其他数据结构**

- 只要满足DAG即可，回环会有循环依赖。



## 共识协议

**分布式协议前置知识**

- FLP不可能结论：在一个异步系统中，网络时延无上限，即使只有一个成员是有问题的，也不可能达成共识。
- CAP理论：（Consistency一致性、Availability可靠性、Partition tolerance分区容错性），任何一个分布式系统中，最多只能满足其中两个性质。



**比特币的核心问题**

- 谁来发行币? <br>唯一可以凭空产生比特币的操作是创建区块，（处理交易获得的交易费，不是凭空产生）。

- 如何验证货币合法性? 即处理**双花攻击**<br>

  依赖于系统中维护的一个数据结构，记录货币的来源和去向（是否被花过？被谁花过？给了谁？）。该数据结构由系统中全体用户共同维护，保证了交易的有效性。该数据结构，便是区块链。<br>（相见案例说明）

- 注意：交易双方都要提供自己的公钥。<br>付款人需要公钥（收款人提供）来进行转账；<br>收款人需要公钥（付款人提供）来验证区块签名的有效性，同时这个公钥需要与上一个区块哈希匹配（防止付款人偷窃）。



**比特币共识协议**

- **女巫攻击**：如果基于用户数量投票机制，则某个节点可以生成大量公私钥对，当产生数量超过系统中一半数目，就可以获得支配地位。

- 如何获得记账权，并达成共识？：**根据算力投票，竞争记账权**

  在比特币系统中，每个节点都可以自行尝试各种nonce值组装一个候选区块（即挖矿），使`Hash(BH) <= target`。

- **分叉处理方法**：在发生分叉的情况下，暂时保存分叉情况，但区块链只承认最长合法链，随着时间推移，必然存在某一条链变成最长合法链。

- **分叉攻击**：因为大多数用户认可最长合法链，会沿着该链继续挖下去。而攻击者要想回退记录，就必须使得分叉链变得比原先的链还长。理论上来说，攻击者需要达到整个系统中51%的计算力。



**比特币激励机制**

- 区块创建奖励
  - 为什么系统中节点要竞争记账权？需要提供算力和电力成本，节点为什么要去做？
  - 比特币通过设置**出块奖励**来解决该问题，一个获得合法区块的节点，可以在区块中加入一个特殊交易（铸币交易）。
  - 每隔21万个区块（速度维持在10min/block，大概4年），奖励减半。
- 交易处理奖励
  - 为什么系统中节点要进行处理交易？
  - 引入**交易费**，在一个区块中，其输入>=输出，差值便是给区块所属节点的手续费。





## 比特币的账本



### 基于交易的账本

**交易**

- 由输入和输出构成，每个输入对应某个先前交易的输出（即交易hash和对应输出号码）。
- 可以有多个输出和多个输出构成，一般有三类：正常、聚合和分发。
- 输入和输出的大小不一定相同，差值为交易费。
- **如何找零？**：在某一个交易中，付款人输入降指向某个先前交易的输出。该输出和当前支付之间，多出来的货币再转入付款人。



**UTXO：未花费交易输出**

- 表示未被花费的一次交易输出，提供产生交易的hash和交易的id。
- 目的是为了快速检测双花攻击，即判断是否被花费过。



### 基于账户的账本

显式的记录每个账户的余额，不需要显式的声明货币的来源，比如以太坊。

 

### BTC系统中具体的区块信息

> https://www.blockchain.com/explorer



**挖矿难度大**

- `nonce`是一个32位的无符号整型数据，在挖矿时候是通过不断调整`nonce`进行的。<br>但`nonce`的取值最多为2^32种，并非将这些nonce全部遍历一遍，就一定能找到符合要求的`nonce`。
- 还可以修改`merkle root`根哈希值（通过`coinbase`域调整）。



**CoinBase Transaction 铸币交易**

- 是区块里第一个交易，包含对记账人的奖励。

- `coinbase`域里写什么都可以，可以用来调整`merkle root` hash值，使`nonce`范围到达2^96。



**脚本拼接**

- 如果输入脚本与先前交易输出脚本拼接后，可以运行，则是合法交易。



### 实际区块举例

**区块信息举例 - Block 654738**

| Key                    | Value                                                            |
|------------------------|------------------------------------------------------------------|
| Hash                   | 00000000000000000002295970b35a895c1e95a84f975e85d2ad42a6d1abaaf6 |
| Confirmations          | 5                                                                |
| Timestamp              | 2020-10-30 13:55                                                 |
| Height                 | 654738                                                           |
| Miner                  | BTC.com                                                          |
| Number of Transactions | 2,622                                                            |
| Difficulty             | 19,997,335,994,446.11                                            |
| Merkle root            | efe8d0a9df170079e1fae800e92e1635e5a18c3d2fd5e761d7e4de52190a0550 |
| Version                | 0x20000000                                                       |
| Bits                   | 386,798,414                                                      |
| Weight                 | 3,992,782 WU                                                     |
| Size                   | 1,288,720 bytes                                                  |
| Nonce                  | 2,007,029,204                                                    |
| Transaction Volume     | 7604.37761100 BTC                                                |
| Block Reward           | 6.25000000 BTC                                                   |
| Fee Reward             | 2.21125753 BTC                                                   |



**交易举例 - 31ed793e0f00b3588e390eb2255005762d6e0e2694a5c68885ac6be92adaca77**

| Key                   | Value                                                            |
|-----------------------|------------------------------------------------------------------|
| Hash                  | 31ed793e0f00b3588e390eb2255005762d6e0e2694a5c68885ac6be92adaca77 |
| Status                | Confirmed                                                        |
| Received Time         | 2020-10-29 14:54                                                 |
| Size                  | 559 bytes                                                        |
| Weight                | 1,267                                                            |
| Included in Block     | 654738                                                           |
| Confirmations         | 5                                                                |
| Total Input           | 0.02289312 BTC                                                   |
| Total Output          | 0.02272363 BTC                                                   |
| Fees                  | 0.00016949 BTC                                                   |
| Fee per byte          | 30.320 sat/B                                                     |
| Fee per weight unit   | 13.377 sat/WU                                                    |
| Value when transacted | $301.83                                                          |


**交易输入举例**

| Key       | Value                                                                        |
|-----------|------------------------------------------------------------------------------|
| Index     | 0                                                                            |
| Details   | Output                                                                       |
| Address   | 3PFZKYbNfLmwomuUHaPwqd1u9k1sXTkDwC                                           |
| Value     | 0.01006829 BTC                                                               |
| Pkscript  | a914ec8229291b7695e2602c6b3e83bbb099c3bdd99387                               |
| Sigscript | 160014fdb70cf7a7f51b6246db8270e1661ba345f32200                               |
| Witness   | 3044022000fb07f9841488...e549e4e28833851b06dba117f1e48de736eea98043f49d105bd |

**交易输出举例**

| Key      | Value                                              |
|----------|----------------------------------------------------|
| Index    | 0                                                  |
| Details  | Unspent                                            |
| Address  | 19cz4BPxLi4wQp8h4218NfGqaKLnF2vFHL                 |
| Value    | 0.02272363 BTC                                     |
| Pkscript | 76a9145e8f311fee03959643c1d007a34055f176ceca0a88ac |



### 统计学原理 

**无记忆性**

​	无论之前做多少大量试验，对后续继续试验没有任何影响。

- 保证公平性，无论算力多少都可以挖矿。
- 系统出块时间服从指数分布：指数分布本身也具有无记忆性。<br>对整个系统而言，已经过去10min，仍然没有人挖到区块，那么平均仍然还需要等10min。<br>也就是说，将来要挖多久和已经挖多久无关。



**系统货币总量**

- `coinbase`是凭空获得比特币的唯一途经。
- 可以计算得到总的比特币数量，无限接近`2100万`。



### 不诚实的节点

分析当不诚实节点获得记账权后的恶意行为，这里的攻击手段都可避免发生。



**伪造币**

​	不诚实节点能否在自己的区块里伪造交易？	

- 不能，它不能获知付款人的私钥。<br>诚实的节点不能认可，忽略此区块，沿着上一个区块进行。



**二次花费**

​	不诚实区块能否回滚掉诚实区块，从而在不诚实区块链里继续使用币，又在现实中获得商品？

- 如果在交易的一段时间里（后继较少），不诚实区块回滚掉了诚实区块，则确实可以。

- 但在交易的一段时间后，如果超过半数节点不诚实，则会与诚实节点竞争最长合法链。

- 解决方法：

  1. 等待后继足够长，即`confirmation`数。默认6次，即大概50分钟。

  2. 0次确认，即只验证交易合法。

     风险很大，但又有很大概率诚实节点不会接受二次花费的交易。



**selfish mining**

​	挖到区块首先不发布，等到自己的链比原链长时再发布，成为最长合法链。

1. 用来构造假区块：这种方法需要大多数算力才可以达到。

   （考虑欺骗大多数节点，让其拿到不诚实的区块hash作为前一个区块hash）

2. 用来制造不平等：第一个区块首先挖出，但不发布，而是继续挖矿。

   风险较高。



**不记录交易**

​	有些交易不去记录进区块中，想要达到扰乱系统的目的。

- 但终会有诚实节点记录此交易。
- 区块链本身会出现这种情况，即当前区块满，等待下一个区块记录时，会暂存至本地。



## 比特币的网络基础

比特币协议是一个引用层协议，底层则是P2P Overlay网络，基于TCP。

其底层P2P网络所有节点是对等的，没有超级节点。

加入网络则需要联系种子节点，他会告诉网络的节点信息。

比特币网络设计目标是简单鲁棒。



## 挖矿难度调整

1. **什么是挖矿难度？**

   出块的条件是令 `H(BH) <= target`。

   挖矿难度`difficulty`和目标阈值`target`成反比。

2. **如何调整挖矿难度？**

   比特币系统采用的哈希算法为SHA-256，所以整个输出空间大小为2^256。

   那么调整目标空间所占比例，简单的说需要目标值前需要多少个0，就可以作为调整难度的手段。

3. **为何调整挖矿难度？**
   系统总算力越来越强，若挖矿难度保持不变，则**出块时间**会越来越短。

   另：系统总算力越来越强，系统越安全。因为51%攻击的代价更大。
   
4. **出块时间越来越短是好事吗？**
   出块时间缩短，那么交易可以很快便被写入区块链，并且提高了系统响应时间，增加了区块链系统效率。

   但是出块时间太短，网络传播占用更多时间时，会造成经常性**分叉过多问题**：

   1. 不利于系统达成共识，增加不稳定性；
   2. 多个分叉会造成系统的**算力分散**，使得黑客攻击不再需要整个系统51%的算力。

5. **10min的出块间隔是最优吗？**
   不是，但系统出块时间需要维持在一个定值附近。

   以太坊中平均出块时间仅为15秒左右，同样在以太坊中也有相应难度调整算法维持其平均出块时间。当然15s的时间明显会产生经常性的分叉，所以以太坊设计了新的共识协议Ghost。
   当然，对于一个交易系统来说，10min这样一个交易时间是比较长的。但对于跨国交易来说，这个时间反而大大缩短了交易时间，减少了相应成本。



### BTC系统如何调整挖矿难度

在BTC协议中规定，每隔2016个区块需要调整一次难度，根据10min产生一个新区块可以得到，大概需要14天的时间。

考虑4倍限制的具体调整公式为：

$$ target = target * max(min(\frac{actual \space time}{expected \space  time}, 4), \frac{1}{4}) $$,

其中，`actual time`指产生2016区块需要的时间，`expected time`值14day * 10min。

同时，存在4倍的限制的原因是为了防止网络中出现**黑天鹅事件**。



## 矿池



### 全节点和轻节点

> 之前提到，由于硬件限制，BTC系统中分为轻节点和全节点，下表阐述了全节点和轻节点的区别

| 全节点                                         | 轻节点                                                   |
| ---------------------------------------------- | -------------------------------------------------------- |
| 一直在线                                       | 不是一直在线                                             |
| 在本地硬盘上维护完整区块链信息                 | 不保存整个区块链，只需要保存每隔区块块头                 |
| 在内存中维护UTXO集合，以便于快速检验交易合法性 | 不保存全部交易，只保存和自己有关的交易                   |
| 监听比特币网络中交易内容，验证每个交易合法性   | 无法验证大多数交易合法性，只能检验和自己相关的交易合法性 |
| 决定哪些交易会打包到区块中                     | 无法检测网上发布的区块正确性                             |
| 监听其他矿工挖出的区块，验证其合法性           | 可以验证挖矿难度                                         |
| 当出现等长分叉，决定选择哪一个分叉挖下去       | 只能检测哪个是最长链，不知道哪个是最长合法链             |



在挖矿过程中，如果监听到别人已经挖出区块延申了最长合法链，此时应该立刻放弃当前区块，重新沿着最后一个区块开始挖矿。

- 这样是不是有些可惜？之前花费好多资源，全部白挖了。
   不可惜。挖矿具有无记忆性，前面无论挖多久，对后续继续挖矿没有影响。

- 比特币系统如何安全性？
  1. 密码学的保证：别人没有自己的私钥，就无法伪造其合法签名，从而无法将其账户上BTC转走。（前提：系统中大多数算力掌握在好人手中）
  2. 二是共识机制：保证了恶意交易不被系统承认。



### 挖矿设备演化 - 单节点的发展
挖矿设备逐渐趋于专业化，其经历了三个过程，总体趋势从通用到越来越专用。从普通CPU -> GPU ->ASIC芯片。

**ASIC芯片的出现是好事吗？**

- 很明显，ASIC芯片并不是普通人可以参与的，一定程度上提升了挖矿的门槛，**违背了比特币系统去中心化**的初衷。
  理想状态下，所有人用CPU挖矿，这样只要有一台家用计算机便可以参与挖矿。
  当然，后续有一些货币便考虑到了这个问题，设计了**ASIC抵抗**的解决方案，后续介绍以太坊时会对这种方案进行介绍。



### 矿池的出现 - 多节点的发展



**单节点挖矿的局限**

1. 收入很不稳定；
2. 承担全节点其他责任（如打包交易、存储区块、存储UTXO等），造成了算力的消耗。



**矿池**

​	通常是一个全节点驱动多台矿机。矿工只需要计算哈希值，而全节点其他职责由矿主来承担（ASIC芯片只能计算哈希值）。同时矿主项矿工分发的任务是不同的，相当于并行计算。

- 解决了收益不稳定的问题。当获得收益后，所有矿工对收益进行分配，从而保证了收益的稳定性。
- 解决了挖矿专业化的问题。
- 威胁到了区块链系统的安全，使得51%攻击变得容易起来。例子见`GHash.IO`，这个矿池曾经达到过51%算力。



**矿池利益分配方法**

1. 平均分配：所有人平分出块奖励。
	不可取，会出现"大锅饭"现象。
2. 按劳分配：降低挖矿难度，收集更少零位的区块，作为工作量证明。
	我们将其称为一个share。当矿工每挖到一个share，将其提交给矿主，矿主对其进行记录，作为矿工工作量的证明。等到某个矿工真正挖到符合要求的的区块后，根据所有矿工提交的share数量进行分配。
	因为每个矿工尝试的nonce越多，挖到矿的可能性越大，所能得到的share也会越多，所以这种方案作为工作量证明方案是可行的。



注意：

1. 矿主向矿工发布的区块内使用的是矿主的公钥，所以可以防止矿共企图偷偷提交的情况。

2. 如果矿工刚开始就偷偷自己挖矿，同时又想获得分成，则何如？

   因为矿工的区块不会被矿主认可为share，所以它没有分成，相当于单干。

3. 间谍矿工是存在的，即挖出矿后不提交，企图拉低对手矿池的产量，提高自己矿池的相对算力。



###  51%算力矿池的攻击手段

这里出现的攻击都是可行的，拿到多数算力相当于掌控链的结构（但不能掌控某个交易本身，即不能伪造交易）。


1. **分叉攻击**
    对已经经过6次确认的交易分叉，利用51%算力将交易记录回滚。
	- 矿工只能计算哈希值，并不知道区块是否合规合法。

2. **封锁交易**（Boycott）
    假如攻击者不喜欢某个账户A，不想让A的交易上区块链，在监听到有其他人将A的交易发布到区块链上时，立刻发动分叉攻击，使A所在链无法成为”最长合法链“。这样，便实现了对A账户的封锁。



## 比特币的脚本

比特币的脚本基于栈的语言，它只能操作栈。



### 交易的数据结构

> https://blog.csdn.net/Mu_Xiaoye/article/details/104364191



### 输入输出脚本的计算方法

为了安全考虑，首先运行输入脚本并通过后，运行输出脚本验证。



注意：

1. 输入和输出脚本的交叉拼接。

2. 输入脚本是B给C的交易，由B提交。

   输出脚本是A给B的交易，由A提交。



**P2PK：Pay to Public Key**

- 输出脚本直接给出收款人公钥。（分割线以上的是B给C的输入脚本，下面是A给B的输出脚本）

  ```
  PUSHDATA(Sig)			B压栈B的签名
  -------------------------
  PUSHDATA(PubKey)		A压栈B的公钥
  CHECKSIG				验证签名和公钥		验证B的私钥
  ```

  

**P2PKH：Pay to Public Key Hash** 常用

- 输出脚本给出收款人公钥的哈希。

  ```
  PUSHDATA(Sig)			B压栈B的签名
  PUSHDATA(PubKey)		B压栈B的公钥
  -------------------------
  DUP						复制栈顶
  HASH160					栈顶Hash
  PUSHDATA(PubKeyHash)	A压栈B公钥的Hash
  EQUALVERIFY				验证栈顶两项相同	验证B的公钥
  CHECKSIG				验证签名和公钥		验证B的私钥
  ```

  

**P2SH：Pay to Script Hash** 基于BIP16

- 输出脚本给出收款人脚本Hash，相当于嵌入其他脚本做认证。

  目的是支持多重签名的封装。

  ```
  PUSHDATA(Sig)			B压栈B的签名
  PUSHDATA(ser script)	B压栈B的序列化赎回脚本
  -------------------------
  HASH160					栈顶Hash
  PUSHDATA(scriptHash)	A压栈B的序列化赎回脚本Hash
  EQUAL					验证栈顶两项相同	验证B的序列化赎回脚本，后续反序列化脚本执行验证。
  ```

  

**基于P2SH的多重签名**

- 在P2SH中封装多重签名的脚本，为用户提供了透明和便利性。

- 这里举电商的例子：用户A付款给电商B，电商B准备给C支付。

  ```
  x						为了避免硬分叉的升级，随便填一个
  PUSHDATA(SIG_1)			电商B提供第一个人的签名
  ...
  PUSHDATA(SIG_M)			第M个人的签名
  PUSHDATA(ser script)	赎回脚本
  -------------------------
  HASH160
  PUSHDATA(script)		用户A压栈电商B提供的序列化赎回脚本Hash	验证脚本合法
  EQUAL					验证栈顶两项相同
  
  ---------redeem----------
  M						电商B规定，需要输入脚本提供至少M个签名	当其中某个人私钥丢失的解决方案
  PUSHDATA(PubKey_1)		电商B提供第一个人的签名
  ...
  PUSHDATA(PubKey_N)
  N						输出脚本提供脚本的数量
  CHECKMULTLSIG			验证多重签名
  ```

  

**销毁比特币的输出脚本：Proof of Burn**

- 输出脚本仅包含`RETURN`，运行直接报错退出。
- 应用场景：
  1. AltCoin：替代币，需要销毁一部分比特币。使用这种方法证明付出了一定代价，才能得到小币种。
  2. digital commitment：向`RETURN`后填入一些Hash信息。可以保护知识产权，类似新建区块的`CoinBase`域。

 

## 分叉

根据对**比特币协议修改的不同**，可以将分叉分为硬分叉和软分叉。

注意：前提是这里的分叉中，**新节点作为多数算力存在**。



### 硬分叉

**什么情况会出现硬分叉？**

1. 对比特币协议增加新协议，**原版本不兼容**。

   未升级软件的旧节点会不认可这些修改，会认为这些特性是非法的。这也就是对比特币协议内容产生分歧，从而导致分叉。

2. 硬分叉的一个典型例子，就是对比特币区块大小的修改。

   在BTC系统中，区块大小最大为1MB，可以包含的交易最大数量为4000笔左右。而一个区块产生大概需要10min左右，也就是说，整个比特币系统，平均每10分钟最多只能处理4000笔交易(平均每秒7笔交易)，相比目前银行等金融机构每秒数十万数百万的交易量来说，根本不在一个数量级上，严重影响吞吐率和交易处理(即上链)时间。

  

**修改区块举例**

- 假设系统中大多数算力节点更新了软件。

- 由于旧节点不认可新节点的大区块（认为新分叉是最长不合法链），旧节点们会沿着原有小区块挖矿。

  而由于新节点认为新分叉是最长合法链，所以会沿着新分叉挖矿。

  于是出现了永久分叉。

  

出现硬分叉后，便变成了两条平行的链，也就造成了社区分裂。

社区中有一部分人，会认为下面的链才是”正统“(根正苗红)，**各个链上货币独立**。



**ETH硬分叉事件**

- 以太坊称为ETH，在历史上发生过硬分叉，另一个链称为ETC。

- 实际上，ETC才是以太坊设计原本的协议，而ETH是黑客攻击ETH上一个智能合约THE DAO后进行回滚的协议链(将黑客攻击偷取的以太币采用硬分叉方式回滚回到另一智能合约，然后退还给真正拥有者)。

  ```
  ─── ETH ─── Attack ─── ETC ───>
                └─── ETH (rollback with new protocol) ───>
  ```

- 硬分叉产生了很多麻烦。

  比如：在ETH链上有一笔转账B->C，有人便在ETC链上回放，将ETC链上的货币页转给了C(C收到两笔钱)。

  后来，对两条链各添加了一个chainID，才使得这两条链真正分开。



### 软分叉

**什么情况会出现软分叉？**

1. 对比特币协议增加新协议，**原版本兼容**。

   未升级软件的旧节点会认可这些修改，会在多数算力支持的新区块上挖矿。

   但旧节点新挖出的旧区块，不被新节点认可。新节点放弃此区块，并发展新区块为最长合法链。

2. 相当于**旧节点挖出的所有区块，是没用的**。

   但是**不会出现永久的平行分叉**。

3. 软分叉可能出现**多数人暴政**，从而侵犯少数人的利益。
   



**软分叉案例**

1. 给原协议中未规定的域，赋予新规则。
     如`coinbase`域的一部分作为UTXO集合的Merkle root hash，目的是提供轻节点认证全节点提供的UTXO。
     
     > 在CoinBase域中写入任何内容都可以，没有任何规定。提到挖矿本质是调整block header中的`nonce`，但其本身只有4个字节，搜索空间太小。
     >
    > 所以实际使用中，将CoinBase域前8个字节作为`extra nonce`，此时搜索空间从原本2^32增长到2^96，对于目前挖矿难度来说已经足够。
    
2. P2SH替代原有多重签名
    最初比特币版本中没有该功能，后来通过软分叉方法加入了进去。



### 总结

- **软分叉**：多数人暴政
   只要系统中拥有半数以上算力节点更新软件，系统就不会产生永久性分叉
- **硬分叉**：东西德国分裂
   必须系统中所有节点更新软件，系统才不会产生永久性分叉





## 匿名性

实际上，比特币中的匿名并非真正的匿名，而是假的匿名。

任何数字货币都会最终落脚在现实世界，只要在现实世界体现了交易，那么就一定不是完全的匿名。

1. 因为比特币中的数据是完全公开的，任何用户间的联系都能一清二楚。
2. 区块链的不可篡改性，让匿名性更加难以维持。
3. 网络交易是又要与实体世界进行联系。只要与现实世界建立多次联系，就可以过滤出账户和真实用户的对应关系。



### 什么情况会破坏其匿名性？

1. 用户可以生成多个地址账户，但这些地址账户可以被关联起来。

   同时作为付款人的账户可能是一个用户；

   收款人其中很可能存在收款人的用户，作为找零的接受账户。

2. 地址账户与个人在真实社会中的身份也可能会产生关联。

   任何使得BTC和实体世界中关联的操作都有可能泄露用户真实身份，其中最明显的就是资金的转入转出。要得到BTC，如果用钱买，就会与实体世界进行交互。想要将BTC转为现实中的货币，也同样需要与实体世界交互。



### 如何提高匿名性？

匿名的本质是不想要暴露身份。
对于普通人来说，BTC的现有机制已经足够保持个人隐私了。
但如果涉及违法，行政机关想要获得真实身份，其实很容易。

1. 在应用层，可以将各个不同用户的BTC混合在一起，使得追查变得混乱(Coin mixing)；
2. 在网络层，可以采用多路径转发的方法，数据不直接发送出去，而是经过很多跳(洋葱路由的基本思想)。

暴露用户隐私正是由于区块链的公开性和不可篡改性。不可篡改性对于隐私保护，实际上是灾难性的。



## 零知识证明

证明者向验证者证明某一个陈述是正确的，但不需要透露除该陈述是正确的之外的任何信息。



### 同态隐藏

零知识证明的数学基础是**同态隐藏**：

1. 如果有E(X)=E(y)，则必然有x=y。(无碰撞)
2. 给定加密值E(X)，很难反推出X。
3. 同态运算
	- 同态加法： E(x) + E(y) == E(x + y)
	- 同态乘法： E(x) * E(y) == E(x * y)



**例子**:

> Alice 想要向 Bob 证明 `x + y = 7`，但是不让 Bob 知道两个变量的具体值。

一个最简单的证明版本如下：

1. Alice将E(x)、E(y)发给Bob。（性质2，不可逆）
2. Bob通过收到的E(x)、E(y)计算得到E(X+Y)。（性质3，同态加法）
3. Bob进行验证E(x+y)和E(7)是否相等。若相等则验证通过，否则验证失败。（性质1，无碰撞）



### 盲签

盲签名是一种特殊的数字签名技术。盲签名因签名的人看不到所签署文件的具体内容而闻名，它有两个显著的特点：
1. 签名者对消息的内容是不可见的 ;
2. 签名被公开后，签名者不能追踪签名。


**例子**:

> Alice 向 Bob 转账。

1. A提供货币编号，银行在不知道货币编号的情况下（但知道编号是A的货币，防范双花），发送一个签名，并减少A的存款。
2. A提供货币编号和签名给B。
3. B将货币编号和签名发给银行，银行验证通过，B增加存款。

这个例子是中心化的，但是银行并不知道AB之间发生了联系。只知道A减少了存款，B增加了存款。



### 零钞和零币

零币在花费的时候，只需要用零知识证明来证明所花掉的币是系统中存在的某一个合法的币，但不用透露具体花掉的是系统中哪一个币。这样就破坏了关联性。
当然，这类货币并非主流加密货币，因为其为了设计匿名性，付出了一定代价，而且，需要强匿名性的用户并不多。

从数学上看，零币和零钞是安全的。但其并不是百分之百的匿名，其并未解决与系统外部实体发生交互时对匿名性的破坏。



## 一些比特币上的问题

- **如果账户私钥丢失怎么办？**

  1. 去中心化场景下，没有办法。
  2. 中心化机构场景，如果忘记私钥可以找交易所申请追回私钥。
     在历史上，有很多次交易所被黑客攻击偷走大量加密货币的事情，其中最著名的为Mt.GOX事件。该交易所曾经为全球最大比特币交易所。后来被攻击丢失大量比特币，导致交易所破产，其CEO被判刑入狱。
     此外，也有交易所监守自盗，工作人员卷款跑路。

- **私钥泄露怎么办？**
  尽快将剩余BTC转到其他安全账户上，没有第三方中心机构重置密码或冻结账户，只能自己对自己负责。
   BTC系统中账户便是公私钥对，密码就是私钥，无法更改。

- **转账写错地址怎么办？**
  没有办法，无法取消已经发布的交易。如果转入不存在地址，则该部分比特币便成为了死钱。当然，比特币系统中UTXO会永久保存该交易，记录该并不存在的地址。因此，对全节点来说，这是不友好的。

- **`RETURN`为什么能够被全节点接受？**

  因为`RETURN`写入的是输出脚本，交易的认证过程是那当前输入脚本和先前输出脚本拼接。跟当前包含`RETURN`的输出脚本无关。

  但是`RETURN`能够被全节点发现，并被认为该交易不能存入UTXO中。

  相对于把`digital commitment`作为收款人公钥hash来说（全节点记录该交易于UTXO中），`RETURN`方案是对全节点友好的。

- **BTC系统中会不会有矿工偷答案？**

  例如：某个矿工发现其他矿工发布了nonce，收到后验证该区块合法，将该nonce作为自己找到的nonce发布出去。
  实际上这是不可能的。发布的区块中包含铸币交易，其收款人地址为挖到矿的矿工地址，复制nonce无意义。

- **付款人为什么要交交易费？**

  为了快速被全节点打包上连，是作为一种优先级的存在。

- **用最低限度的比特币来提交`unspent`交易，能否撑爆所有节点内存上限？**

  自己算一下好了，就比较撑爆所花费的时间和电费撑不住挖矿的时间那个大。当挖矿的奖励不足成本时，没有新的区块，就没有新的交易了。临近这个时候的比特币的价值是会很快下跌的，很可能比结束时间更短。

- **在区块发布时候，哈希指针如何网络传播基于内存的指针？**

  哈希指针实际应用的时候，只有哈希而没有指针。

  全节点一般将区块存储于一个key-value数据库中，key为哈希，value为区块内容。常用的key-value数据库为levelDB，只要掌握到最后一个区块的哈希值即可依据哈希值一直往前找到区块链所有内容。

- **通过双方私钥截断再组合的方式，能否提供好的多用户绑定方法？**

  有N个不同用户，一起分享一些比特币。他们将私钥分为N份，如果用户不团结，少了一个用户的私钥，那么这部分钱就会永久锁死，谁也无法取出。

  1. 如果N个人中任意一个人忘记私钥，则无法将钱取出。
  2. 截断私钥长度，会降低安全性，因为私钥长度会直接影响破解难度(2^256 远远大于  2^128)
  3. 如果分手，该钱变成死钱，一直保存在UTXO集合中，对矿工不友好。

- **CAP理论下，分布式共识是如何达到的？**

  理论上来说，分布式系统不能达到共识。区块链中也有可能达到分叉攻击导致系统回滚。
  此外，理论和实际存在差异。可能结论针对特定模型，实际中对模型稍微修改或添加线下方法即可将不可能变为可能。

- **BTC的总量上限固定是好事么？**

  不是，具有通胀的货币才是好的货币。

  人类总财富的发展，远远快于金矿的挖掘速度。

  如果用数量固定的东西作为财富，那么其只会越来越之前，如房价问题。

  以太坊没有定期减半的出块奖励，新型币多设有通胀的功能。
