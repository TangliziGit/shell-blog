# [MIT6.824] Lecture11 - Frangipani

## Lecture 11 - Frangipani(1997)：缓存一致性 & 原子更新 & WAL故障恢复

> - http://nil.lcs.mit.edu/6.824/2020/papers/thekkath-frangipani.pdf
> - https://timilearning.com/posts/mit-6.824/lecture-11-cache-consistency-frangipani
> - http://nil.lcs.mit.edu/6.824/2020/papers/frangipani-faq.txt

Frangipani是一个分布式网络文件存储的客户端，它在系统内核中实现了文件系统。对应的，Petal作为它的服务端，是共享虚拟磁盘服务。Petal包含文件系统的数据结构，例如文件内容、inode、目录、目录的文件列表、inode 和块的空闲状态。

![frangipani-layering](/static/image/2022-01-10/frangipani-layering.png)

这个系统在工作站（或者说系统中）里面做了大量的缓存，并且文件的修改可以在本地缓存完成。因为这样数据可以在微秒级别读出来，而不是毫秒级别的从文件服务器获取它们。注意这里的缓存是支持Write-Back的。

（缓存有两种：Write-Direct在数据更新时同时写cache和存储、Write-Back在数据替换出cache时更新存储）

在这个系统中，有三个主要的挑战：

- **缓存一致性**：当有人在大厅里说自己在文件系统里面做了修改，其他人应该能看到这个修改。缓存一致性，在这里我认为就是在缓存的系统中的读写强一致性。
- **原子性更新**：我们希望写操作不会与相同时间其他工作站的操作相互干扰。即使对于复杂的操作，涉及到修改很多状态，我们也希望这些操作表现的好像在一个时间点发生。
- **故障恢复**：由于 Write-Back 缓存，可能会在本地的缓存中堆积了大量的修改。如果我的工作站崩溃了，但是这时这些修改只有部分同步到了 Petal，还有部分仍然只存在于本地。不管如何，其他客户端/应该看到一个一致的文件系统，而不是一个损坏了的文件系统数据。

需要注意的是：

- 本论文是1997年发布的，所以硬件资源不高，而且它的目标是50人的小工作组。所以这不是分布式存储的主要应用场景。真正的应用场景是一些大型的数据中心、大型网站、大数据运算，在这些场景中，文件系统的接口相比数据库接口来说，就不是那么有用了。
- 而且，在大数据的场景下，缓存就显得累赘。如果你读取 10TB 的数据，缓存基本上没什么用，并且会适得其反。所以，随着时间的推移，Frangipani 在一些场合还是有用的，但是并不符合在设计新系统时候的需求。

### 缓存一致性 & 原子更新：锁服务

在 Frangipani 系统中还有第三类服务器：锁服务器。在锁服务器里面，有一个locks表单。我们假设对于每一个文件都有一个锁，它可能会被某个工作站所持有。同时，每个工作站都会记录跟踪它所持有的锁，和锁对应的文件内容。所以在每个工作站中，Frangipani 模块也会有一个 lock 表单，表单会记录文件名、对应的锁的状态和文件的缓存内容。

当一个 Frangipani 服务器决定要读取文件，比如读取目录 `/`、读取文件 `A`、查看一个 inode，首先，它会向一个锁服务器请求文件对应的锁，之后才会向 Petal 服务器请求文件或者目录的数据。收到数据之后，工作站会记住，本地有一个文件 X 的拷贝，对应的锁的状态，和相应的文件内容。

每一个工作站的锁至少有两种模式。工作站可以读或者写相应的文件或者目录的最新数据，可以在创建，删除，重命名文件的过程中，如果这样的话，我们认为锁在 Busy 状态。只要系统调用结束了，工作站会在内部释放锁，现在工作站不再使用那个文件。但是从锁服务器的角度来看，工作站仍然持有锁。工作站内部会标明，这是锁是 Idle 状态，它不再使用这个锁。

这里的锁在使用上有一些规则：

- 工作站不允许持有缓存的数据，除非同时也持有了与数据相关的锁。实际上，我认为这里的**锁是请求对某个文件的缓存能力**。仅当持有写锁时，客户端才有一份可写的数据缓存；同样，只有获得读锁才能有读的缓存。
- 释放锁之前，应先向 Petal 存储系统写数据，再从客户端 lock 表单中删除锁和缓存。这里可以说释放缓存的能力，但在这之前需要将缓存写回。

下面介绍客户端与锁服务之间的缓存一致性协议 / 接口：

- Request。指客户端请求锁服务获得文件的锁。
- Grant。指锁服务授权客户端这个文件锁。注意这里Request和Grant是异步的，锁服务接受Request后会再请求其他客户端释放锁。
- Revoke。指锁服务请求客户端释放锁。
  - 如果工作站收到 Revoke 消息时，它还在使用锁（Busy状态）。那么直到它完成了相应的文件系统操作，才会放弃锁。
  - 如果是Idle状态，那么首先客户端要同步元数据的WAL到Petal，接着将文件数据写入Petal，最后再释放锁。
  - 工作站会每隔 30 秒会将所有修改了的缓存写回到 Petal 中
- Release。客户端根据锁的状态来放弃锁，是Revoke的响应。二者异步。

### 故障恢复：记录元数据的WAL、故障恢复代理人

Frangipani 与其他的系统一样，需要通过预写式日志WAL，实现故障可恢复的事务：（似乎原子性的逻辑(事务、分布式锁)都需要提供WAL来恢复）

- 当工作站向 Petal 写入任何数据之前，它会在自己的Petal Log列表中追加一个 Log 条目。此Log会描述整个的需要完成的操作。
- 只有当这个描述了完整操作的 Log 条目安全的存在于 Petal 之后，工作站才会开始向 Petal 发送数据。

所以如果工作站可以向 Petal 写入哪怕是一个数据，那么描述了整个操作、整个更新的 Log 条目必然已经存在于 Petal 中。

除了经典的WAL外，Frangipani还提到Petal的Log列表是一个环形空间，且每个Log都需要自增的序号（用于检测Log结尾）。同时每个Log还会描述每个操作，包括数据块号、版本号和一些数据。注意，Log 只包含了对于元数据的修改，比如说文件系统中的目录、inode、bitmap 的分配。Log 本身**不会包含需要写入文件的数据**。（所以故障恢复是不会恢复文件内容的，这与现代Unix文件系统缓存一样。引用见FAQ。）

Frangipani 总是会先将自身的 Log 先写入到 Petal。这意味着如果发生了故障，那么发生故障时可能会有这几种场景：

- 要么工作站正在向 Petal **写入 Log**，所以这个时候工作站必然还没有向 Petal 写入任何文件或者目录。
- 要么工作站正在向 Petal **写入修改的文件**，所以这个时候工作站必然已经写入了完整的 Log。

假设一个其他的工作站需要崩溃了的工作站所持有的一个锁，锁服务器会发出 Revoke 消息，但是锁服务器永远也不会从崩溃了的工作站收到 Release 消息。Frangipani 出于一些原因对锁使用了租约，当租约到期了，锁服务器会认定工作站已经崩溃了，之后它会初始化恢复过程。实际上，锁服务器会通知另一个还活着的工作站说：看，工作站 1 看起来崩溃了，请读取它的 Log，重新执行它最近的操作并确保这些操作完成了，在你完成之后通知我。

那么详细来谈故障场景：

- 当WAL未写入时崩溃。当其他代理人 WS2 执行恢复，查看崩溃了的工作站的 Log 时，发现里面没有任何信息，自然也就不会做任何操作。之后 WS2 会释放 WS1 所持有的锁。
- 当WAL部分写入时崩溃。执行恢复的工作站 WS2 会检查每个 Log 条目，并重新向 Petal 执行 WS1 的每一条 Log。当 WS2 执行完 WS1 存放在 Petal 中的 Log，它会通知锁服务器，之后锁服务器会释放 WS1。注意这里会检查Log完整性，存在校验和机制。
  - 这里说明在事务层面故障回复不是原子性的，或者说针对每个文件是原子性的。
- 当块数据写入时崩溃。执行恢复的工作站 WS2 并不知道 WS1 在哪个位置崩溃的，它只能看到一些 Log 条目。所以WS2 会以相同的方式重新执行 Log。尽管部分修改已经写入了 Petal，WS2 会重新执行修改。（这里是怎么知道要从哪个操作开始执行恢复？应该是每次释放锁只有一个Log，它包含了所有操作，也就是为什么需要递增序号）

这里有一个时序的例子能够说明当前的方法还有缺陷：

```
WS1:   delete(/a)                 CRASH
WS2:                create(/a)
WS3:                                        RECOVER
```

当WS3恢复WS1的WAL时，不能直接执行delete操作，因为对应文件已经不是原有的文件了。所以我们不能只是不经思考的重新执行 WS1 的 Log，WS1 的 Log 在我们执行的时候可能已经过时了，其他的一些工作站可能已经以其他的方式修改了相同的数据，所以我们不能盲目的重新执行 Log 条目。Frangipani 是这样解决这个问题的，通过对每一份存储在 Petal 文件系统**块数据增加一个版本号**，同时将**版本号与 Log 中描述的更新关联**起来。如果一个工作站没有故障，并且成功的将数据写回到了 Petal。这样元数据的版本号会大于等于 Log 条目中的版本号。如果有其他的工作站之后修改了同一份元数据，版本号会更高。
