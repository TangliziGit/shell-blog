# ES6 标准学习

> 大部分参考 [ECMAScript 6 入门](https://es6.ruanyifeng.com/#docs/intro)

注意 ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称

需要特别注意的特性：

1. `let`：存在**暂时性死区**
2. 解构赋值：注意对象也可以解构
3. 正则的具名组匹配



## 变量声明

> https://es6.ruanyifeng.com/#docs/let

- ES6 一共有 6 种声明变量的方法：`var`、`function`、`let`、`const`、`import`、`class`



### let 与 var

使用`let`替代`var`，这里讲`var`的特殊和差异之处。例子请看参考链接。

- `var`声明是**全局范围**的，并且可以**重复声明**。
- `var`命令会发生“**变量提升**”现象：变量可以在声明之前使用，值为`undefined`。
- `let`命令会存在一个**暂时性死区**的问题：只要块级作用域内存在`let`命令，它所声明的变量就“绑定”这个区域，不再受外部的影响。
  - 强行使用会`ReferenceError`。
  - 这样的设计是为了让大家养成良好的编程习惯，<u>变量一定要在声明之后使用，否则就报错。</u>

- `var`声明只有全局作用域和函数作用域，**没有块级作用域**。
  - 第一种场景，内层变量可能会覆盖外层变量。函数作用域优先变量提升，从而覆盖全局作用域。
  - 第二种场景，用来计数的循环变量泄露为全局变量。
  - 块级作用域的出现，实际上使得获得广泛应用的<u>匿名立即执行函数表达式</u>（匿名 IIFE）不再必要了。
  - ES6 规定，块级作用域之中，<u>函数声明语句的行为类似于`let`</u>，在块级作用域之外不可引用。

总结一下，`let`是作用于**块级作用域**上的**不可重复声明**的声明语句，但使用它降存在**暂时性死区**的问题



### const

`const`与`let`在三个方面上一样：**块级作用域**、**不可重复声明**、**暂时性死区**

但是注意：`const`保证的是变量指向的内存地址所保存的数据不得改动，即对于基本数据是不变的，对于对象则内容可变而它存储的指针不变。

如果真的想将**对象冻结**，应该使用`Object.freeze`方法。而且除了将对象本身冻结，对象的属性也应该冻结。



### 顶层对象

ES5 之中，顶层对象的属性与全局变量是等价的。顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。



#### 脱钩

ES6 为了改变这一点，一方面规定，为了保持兼容性，`var`命令和`function`命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，`let`命令、`const`命令、`class`命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。



#### 统一的顶层对象

JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。

[ES2020](https://github.com/tc39/proposal-global) 在语言标准的层面，引入`globalThis`作为顶层对象。也就是说，任何环境下，`globalThis`都是存在的，都可以从它拿到顶层对象，指向全局环境下的`this`。

垫片库[`global-this`](https://github.com/ungap/global-this)模拟了这个提案，可以在所有环境拿到`globalThis`。



## 解构赋值

- 解构赋值的规则是，只要等号右边的值不是对象或数组，就**先将其转为对象**。由于`undefined`和`null`无法转为对象，所以对它们进行解构赋值，都会报错。



### 数组的解构

以下是一些例子：

```javascript
let [foo, [[bar], baz]] = [1, [[2], 3]];
let [ , , third] = ["foo", "bar", "baz"];
let [x, , y] = [1, 2, 3];
let [head, ...tail] = [1, 2, 3, 4];
let [x, y, ...z] = ['a'];
// y === undefined
// z === []
```

- **解构失败值**是`undefined`；解构**支持不完全解构**`let [x, y] = [1, 2, 3];`

- 只要某种数据结构具有 **Iterator 接口**，都可以采用数组形式的解构赋值。如果不是，则报错。

  - Set 结构，也可以使用数组的解构赋值。
  - Generator 函数，原生具有 Iterator 接口。

- **默认值**：ES6 内部使用严格相等运算符（`===`），判断一个位置是否有值。所以，只有当一个数组成员严格等于`undefined`，默认值才会生效。同时如果默认值是一个表达式，那么这个**表达式是惰性求值**的

  ```javascript
  let [x = 1] = [undefined];
  x // 1
  
  let [x = 1] = [null];
  x // null
  ```

- 可以将一个已经声明的变量用于解构赋值。



### 对象的解构

```javascript
let { bar, foo } = { foo: 'aaa', bar: 'bbb' };
foo // "aaa"
bar // "bbb"

let { baz } = { foo: 'aaa', bar: 'bbb' };
baz // undefined

let { first: f, last: l } = { first: 'hello', last: 'world' };
f // 'hello'
l // 'world'

var {x: y = 3} = {x: 5};
y // 5
```

- **解构失败值**是`undefined`
- 解构可以给定替换的 key，如例3。**注意**被替换的是后者，而不是前者。就像声明一对kv一样，把它当作模式匹配。



**注意**：

- 如果要将一个已经声明的变量用于解构赋值：

  ```javascript
  let x;
  ({x} = {x: 1});
  ```



### 形参的解构

```javascript
const add = ([x, y]) => x + y;
```



### 用处

1. **快速提取 JSON 数据**
2. **函数参数的默认值**：避免了在函数体内部再写`var foo = config.foo || 'default foo';`这样的语句。
3. **遍历 Map 结构**：任何部署了 Iterator 接口的对象，都可以用`for...of`循环遍历。



## 字符串的扩展

1. **字符的 Unicode 表示法**：ES6 允许采用`\uxxxx`形式表示一个字符，其中`xxxx`表示字符的 Unicode 码点。

2. **字符串的遍历器接口**：除了遍历字符串，这个遍历器最大的优点是可以识别大于`0xFFFF`的码点，传统的`for`循环无法识别这样的码点。

3. **模板字符串**：可以用来定义多行字符串，或者在字符串中嵌入变量。

   - **标签模板**：它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。

     ```javascript
     alert`hello`
     // 等同于
     alert(['hello'])
     
     // 下面是一些应用，是自定义函数对标签模板进行处理：
     // 1. 过滤 HTML 字符串
     // 2. 多语言转换
     // 3. 嵌入其他语言
     ```



### 新增方法

1. `String.fromCharPoint()`：用于从 Unicode 码点返回对应字符，相比 ES5 它能识别码点大于`0xFFFF`的字符。

2. `String.raw()`：返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串。

3. **实例方法`codePointAt()`**：能够正确处理 4 个字节储存的字符，返回一个字符的码点。

   - JavaScript 内部，**字符以 UTF-16 的格式储存**。当遇到2个字节组成的字符时：

   - `charAt()`方法无法读取整个字符

   - `charCodeAt()`方法只能分别返回前两个字节和后两个字节的值。

   - `codePointAt()`方法返回一个字符的码点。**注意**：为了对齐字符串长度，当索引指向字符后半段时，返回值等于`charCodeAt()`

     ```javascript
     var s = "𠮷";
     
     s.length // 2
     s.charAt(0) // ''
     s.charAt(1) // ''
     s.charCodeAt(0) // 55362
     s.charCodeAt(1) // 57271
     s.codePointAt(0) // 134071
     s.codePointAt(1) // 57271
     s.codePointAt(0).toString(16) // "20bb7"
     ```

4. 实例方法`normalize()`：用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。

5. **实例方法`includes() startsWith() endsWith()`**

6. **实例方法`repeat()`**

7. **实例方法`padStart() padEnd()`**：引入了字符串补全长度的功能。

   ```javascript
   // 常见用途是为数值补全指定位数
   '1'.padStart(10, '0') // "0000000001"
   '12'.padStart(10, '0') // "0000000012"
   '123456'.padStart(10, '0') // "0000123456"
   
   // 另一个用途是提示字符串格式
   '12'.padStart(10, 'YYYY-MM-DD') // "YYYY-MM-12"
   '09-12'.padStart(10, 'YYYY-MM-DD') // "YYYY-09-12"
   ```

8. **实例方法`trimStart() trimEnd()`**
9. **实例方法`matchAll() replaceAll()`**



## 正则的扩展

> https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions



### 各种修饰符

ES6 为正则表达式新增了`flags`属性，会返回正则表达式的修饰符。

```javascript
// ES5 的 source 属性： 返回正则表达式的正文
/abc/ig.source
// "abc"

// ES6 的 flags 属性：返回正则表达式的修饰符
/abc/ig.flags
// 'gi'

/hello\d/y.sticky	// true
/hello/u.unicode	// true
```



1. **u修饰符**：含义为“Unicode 模式”，用来正确处理大于`\uFFFF`的 Unicode 字符。

2. **y修饰符**：首先`g`修饰符是从头开始向后搜索，直到发现匹配为止。而`y`修饰符则是从头开始，如果当前不匹配则返回`null`。这称为粘连模式。它需要与`g`修饰符连用，否则只会匹配第一个元素。

3. **s修饰符**：`dotAll`模式，即点（dot）代表一切字符。

   - 正则表达式中，点（`.`）是一个特殊字符，代表任意的单个字符，但是有两个例外；<br>一个是四个字节的 UTF-16 字符，这个可以用`u`修饰符解决；<br>另一个是行终止符：换行符、回车符、行分隔符、段分隔符
   ```javascript
   /foo.bar/s.test('foo\nbar') // true
   ```



### Unicode 属性类

允许正则表达式匹配符合 Unicode 某种属性的所有字符。

- Unicode 属性类要指定属性名和属性值。对于某些属性，可以只写属性名，或者只写属性值。
- `\P{…}`是`\p{…}`的反向匹配，即匹配不满足条件的字符。
- 这两种类只对 Unicode 有效，所以使用的时候一定要加上`u`修饰符。

```javascript
const regexGreekSymbol = /\p{Script=Greek}/u;
regexGreekSymbol.test('π') // true

const regex = /^\p{Decimal_Number}+$/u;
regex.test('𝟏𝟐𝟑𝟜𝟝𝟞𝟩𝟪𝟫𝟬𝟭𝟮𝟯𝟺𝟻𝟼') // true

// 匹配所有数字
const regex = /^\p{Number}+$/u;
regex.test('²³¹¼½¾') // true
regex.test('㉛㉜㉝') // true
regex.test('ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ') // true

// 匹配所有空格
\p{White_Space}
// 匹配各种文字的所有字母，等同于 Unicode 版的 \w
[\p{Alphabetic}\p{Mark}\p{Decimal_Number}\p{Connector_Punctuation}\p{Join_Control}]
// 匹配各种文字的所有非字母的字符，等同于 Unicode 版的 \W
[^\p{Alphabetic}\p{Mark}\p{Decimal_Number}\p{Connector_Punctuation}\p{Join_Control}]
// 匹配 Emoji
/\p{Emoji_Modifier_Base}\p{Emoji_Modifier}?|\p{Emoji_Presentation}|\p{Emoji}\uFE0F/gu

// 匹配所有的箭头字符
const regexArrows = /^\p{Block=Arrows}+$/u;
regexArrows.test('←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩') // true
```



### 具名组匹配

原有组匹配的使用方法：

```javascript
const RE_DATE = /(\d{4})-(\d{2})-(\d{2})/;

const matchObj = RE_DATE.exec('1999-12-31');
const year = matchObj[1]; // 1999
const month = matchObj[2]; // 12
const day = matchObj[3]; // 31
```

ES2018 引入了**具名组匹配**，允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。

“具名组匹配”在圆括号内部，模式的头部添加“**问号 + 尖括号 + 组名**”（`?<year>`），然后就可以在`exec`方法返回结果的`groups`属性上引用该组名。同时，数字序号（`matchObj[1]`）依然有效。

```javascript
const RE_DATE = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/;

const matchObj = RE_DATE.exec('1999-12-31');
const year = matchObj.groups.year; // "1999"
const month = matchObj.groups.month; // "12"
const day = matchObj.groups.day; // "31"
```



#### 解构赋值和替换

1. 有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。

    ```javascript
    let {groups: {one, two}} = /^(?<one>.*):(?<two>.*)$/u.exec('foo:bar');
    one  // foo
    two  // bar
    ```

2. 字符串替换时，使用`$<组名>`引用具名组。

    ```javascript
    let re = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/u;

    '2015-01-02'.replace(re, '$<day>/$<month>/$<year>')
    // '02/01/2015'
    ```

    上面代码中，`replace`方法的第二个参数是一个字符串，而不是正则表达式。

    `replace`方法的第二个参数也可以是函数，该函数的参数序列如下。

    ```javascript
    '2015-01-02'.replace(re, (
       matched, // 整个匹配结果 2015-01-02
       capture1, // 第一个组匹配 2015
       capture2, // 第二个组匹配 01
       capture3, // 第三个组匹配 02
       position, // 匹配开始的位置 0
       S, // 原字符串 2015-01-02
       groups // 具名组构成的一个对象 {year, month, day}
     ) => {
     let {day, month, year} = groups;
     return `${day}/${month}/${year}`;
    });
    ```

    具名组匹配在原来的基础上，新增了最后一个函数参数：具名组构成的一个对象。函数内部可以直接对这个对象进行解构赋值。



#### 引用

如果要在正则表达式内部引用某个“具名组匹配”，可以使用`\k<组名>`的写法。

```javascript
const RE_TWICE = /^(?<word>[a-z]+)!\k<word>$/;
RE_TWICE.test('abc!abc') // true
RE_TWICE.test('abc!ab') // false
```

数字引用（`\1`）依然有效。

```javascript
const RE_TWICE = /^(?<word>[a-z]+)!\1$/;
RE_TWICE.test('abc!abc') // true
RE_TWICE.test('abc!ab') // false
```

这两种引用语法还可以同时使用。

```javascript
const RE_TWICE = /^(?<word>[a-z]+)!\k<word>!\1$/;
RE_TWICE.test('abc!abc!abc') // true
RE_TWICE.test('abc!abc!ab') // false
```



### 其他

1. 支持后行断言：

   ```javascript
   // 先行断言
   /\d+(?=%)/.exec('100% of US presidents have been male');  // ["100"]
   /\d+(?!%)/.exec('that’s all 44 of them');                 // ["44"]
   
   // 后行断言
   /(?<=\$)\d+/.exec('Benjamin Franklin is on the $100 bill');  // ["100"]
   /(?<!\$)\d+/.exec('it’s is worth about €90');                // ["90"]
   ```

2. `matchAll`

   - 原有正则匹配全局应使用`g`，并用循环取得结果`while (match = regex.exec(string))`

   - [ES2020](https://github.com/tc39/proposal-string-matchall) 增加了`String.prototype.matchAll()`方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。

     ```javascript
     const string = 'test1test2test3';
     const regex = /t(e)(st(\d?))/g;
     
     for (const match of string.matchAll(regex)) {
       console.log(match);
     }
     // ["test1", "e", "st1", "1", index: 0, input: "test1test2test3"]
     // ["test2", "e", "st2", "2", index: 5, input: "test1test2test3"]
     // ["test3", "e", "st3", "3", index: 10, input: "test1test2test3"]
     
     // 转为数组的方法一
     [...string.matchAll(regex)]
     
     // 转为数组的方法二
     Array.from(string.matchAll(regex))
     ```



## 数值的扩展

此处内容大多用不到，故简写。

1. **指数运算符（`**`）**
2. **BigInt**：BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。字面量必须添加后缀`n`。



## 函数的扩展

1. **默认参数**：默认参数<u>惰性求值</u>；还可与解构赋值搭配；函数的`length`属性返回没有指定默认值的参数个数
2.  **rest 参数**：获取函数的多余参数，例：`function add(...xs)`。同时它只能是最后一个参数。
3. **name 属性**：返回该函数的函数名。注意匿名函数则返回对应的变量名。
4. **尾调用优化（调用栈复用）**：尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。ES6 的尾调用优化只在严格模式下开启。
5. **catch语句参数省略**：很多时候，`catch`代码块可能用不到这个报错参数。



### 箭头函数

1. 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。
2. 箭头函数可以与变量解构结合使用。
3. 如果函数体很复杂，有许多行，或者函数内部有大量的读写操作，不单纯是为了计算值，这时也不应该使用箭头函数，而是要使用普通函数，这样可以提高代码可读性。



**注意**：

箭头函数里面根本没有自己的`this`，而是**引用外层<u>代码块</u>的`this`**。箭头函数让`this`指向固定化，从动态变为静态。

- （在 JavaScript 中，函数是对象的方法。如果一个函数不是 JavaScript 对象的方法，那么它就是全局对象的函数。`call`方法是指函数作用与某个指定对象上。）

- 所以，箭头函数转成 ES5 的代码如下。

  ```javascript
  // ES6
  function foo() {
    setTimeout(() => {
      console.log('id:', this.id);
    }, 100);
  }
  
  // ES5
  function foo() {
    var _this = this;
  
    setTimeout(function () {
      console.log('id:', _this.id);
    }, 100);
  }
  ```



这导致了：

1. **不可以当作构造函数**，也就是说，不可以使用`new`命令，否则会抛出一个错误。
2. 不可以使用`arguments`对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。
3. 不可以使用`yield`命令，因此箭头函数不能用作 Generator 函数。



## 数组的扩展

1. **展开运算符**：展开数组（Iterator接口对象）转为用逗号分隔的参数序列。仅用于<u>函数调用</u>和<u>数组中展开</u>。下面给出一些例子。

   ```javascript
   // 1. 数组浅拷贝
   const a1 = [1, 2];
   // 写法一
   const a2 = [...a1];
   // 写法二
   const [...a2] = a1;
   
   // 2. 合并数组
   [...arr1, ...arr2, ...arr3]
   
   // 3. 解构赋值
   const [first, ...tail] = [1, 2, 3, 4, 5];
   
   // 4. 分解 unicode 字符串
   str.split('').reverse().join('')
   // 'y\uDE80\uD83Dx'
   
   [...str].reverse().join('')
   // 'y\uD83D\uDE80x'
   ```

2. **`Array.from`方法**：用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象。

   - 类似数组的对象实现了`ArrayLike`接口

       ```typescript
       interface ArrayLike<T> {
           readonly length: number;
           readonly [n: number]: T;
       }
       ```

   - 可以接受第二个参数，作用类似于数组的`map`方法，用来对每个元素进行处理，将处理后的值放入返回的数组。
   
3. **`Array.of`方法**：用于将一组值，转换为数组。用于替换混乱的原有构造方法。

4. 实例方法**`find`  和 `findIndex`**：接受函数，返回遇到的第一个值或索引。

5. **实例方法`flat`和`flatMap`**

6. `sort()`的默认排序算法是<u>稳定</u>的

7. 实例方法`fill`

8. 实例方法`entries` `keys` `values`：返回Iterator对象



## 对象的扩展

1. **属性和方法的简洁表示法**：允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。

   ```javascript
   const foo = "foo";
   const o = {
     foo,
     method() {
       return "Hello!";
     }
   };
   ```

2. **属性名表达式**：用表达式作为属性名，这时要将表达式放在方括号之内。

   ```javascript
   let propKey = 'foo';
   let obj = {
     [propKey]: true,
     ['a' + 'bc']: 123
   };
   ```



### 复习对象

#### 构造函数

为了提供一个便捷的构造方法，使用`this`和`new`并不设置返回值：

```javascript
function Person(name) {
  this.name = name;
  this.greeting = function() {
    alert('Hi! I\'m ' + this.name + '.');
  };
}

const p = new Person("foo");
```



##### 其他方式

1. 还可以将对象文本传递给**Object()** 构造函数作为参数， 以便用属性/方法填充它。请尝试以下操作：  

    ```javascript
    var person1 = new Object({
      name : 'Chris',
      age : 38,
      greeting : function() {
        alert('Hi! I\'m ' + this.name + '.');
      }
    });
    ```

2. JavaScript有个内嵌的方法`create()`, 它允许您基于原型链对现有对象创建新的对象。  

   ```javascript
   var person2 = Object.create(person1);
   person2.__proto__ === person1
   ```



#### 原型链

1. **原型**：每个对象拥有一个**原型对象**，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。

2. **原型链**：这种关系常被称为**原型链 (prototype chain)**，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。

3. 每个实例访问属性的过程，类似与<u>自动解引用</u>。

   

##### 举例

```javascript
// 除了箭头函数以外，都可以作为构造函数
let Cons = function(){};
let Ins = new doSomething()

console.assert( Ins.__proto__ === Cons.prototype )
console.assert( Ins.__proto__.proto === Object.prototype )
console.assert( Cons.__proto__ === Function.prototype )
```

![prototype_chain](/static/image/2021-01-16/prototype_chain.png)

- **构造函数**：拥有`prototype`和`__proto__`
- **原型**：拥有`__proto__`、`constructor`和<u>自定义的属性</u>；但注意`Object.prototype.__proto`为`null`
- **实例**：拥有`__proto__`



**注意**

- 在构造函数中对`this`添加属性时，它会随着`new`而出现在实例对象的属性上。**所以它不在原型链上，不被继承。**

- 在构造函数的原型上添加属性时，它会被添加在原型上，在实例访问时“自动解引用”。

  ```javascript
  function Person() {
    this.name = 'Chris';
    this.age = 38;
    this.greeting = function() {
      alert('Hi! I\'m ' + this.name + '.');
    };
  }
  
  Person.prototype.hello = function() {
    console.log("hello");
  }
  
  console.log(new Person())
  // {
  //   age: 38,
  //   greeting: function greeting(),
  //   name: "Chris",
  //   __proto__: {
  //     hello: hello(),
  //     ...
  //   },
  // }
  ```

  

#### 原型链继承 / 委托

- `this`对应的属性，只有当`new`语句作用时，才生成出来作为**实例的属性**。

- **原型链继承的步骤**
  1. 构造函数中使用父类的构造函数，作用于当前的`this`
  2. 子类的原型关联父类的原型，使用`Object.create()`
  3. 设置子类原型的构造函数

```javascript
// Person
function Person(first, last, age, gender, interests) {
  this.name = { first, last };
  this.age = age;
  this.gender = gender;
  this.interests = interests;
}

Person.prototype.greeting = function() {
  alert('Hi! I\'m ' + this.name.first + '.');
};


// Teacher
function Teacher(first, last, age, gender, interests, subject) {
  // 1. call 指明了在运行这个函数时想对“this”指定的值 
  Person.call(this, first, last, age, gender, interests);

  this.subject = subject;
}

// 2. 关联原型，并且设置构造函数
Teacher.prototype = Object.create(Person.prototype);
Teacher.prototype.constructor = Teacher;
```





### 对象的可枚举性

对象的每个属性都有一个**描述对象**（Descriptor），用来控制该属性的行为。`Object.getOwnPropertyDescriptor`方法可以获取该属性的描述对象。

```javascript
let obj = { foo: 123 };
Object.getOwnPropertyDescriptor(obj, 'foo')
//  {
//    value: 123,
//    writable: true,
//    enumerable: true,
//    configurable: true
//  }
```

描述对象的`enumerable`属性，称为“可枚举性”，如果该属性为`false`，就表示某些操作会忽略当前属性。

目前，有四个操作会忽略`enumerable`为`false`的属性。

- `for...in`循环：只遍历对象自身的和继承的可枚举的属性。
- `Object.keys()`：返回对象自身的所有可枚举的属性的键名。
- `JSON.stringify()`：只串行化对象自身的可枚举的属性。
- `Object.assign()`： 忽略`enumerable`为`false`的属性，只拷贝对象自身的可枚举的属性。

其中，只有`for...in`会返回继承的属性，其他三个方法都会忽略继承的属性，只处理对象自身的属性。



### 其他

- `super`关键字：`super === this.__proto__`或者`super === Object.getPrototype(this)`

- **展开运算符的解构赋值**：注意，**解构赋值的拷贝是浅拷贝**

  ```javascript
  let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
  x // 1
  y // 2
  z // { a: 3, b: 4 }
  ```

- **链判断运算符**：判断左侧的对象是否为`null`或`undefined`。是则返回`undefined`。

  - 链判断运算符有三种用法:`obj?.prop`、`obj?.[expr]`、`func?.(...args)` 

  ```javascript
  const firstName = message?.body?.user?.firstName || 'default';
  const fooValue = myForm.querySelector('input[name=foo]')?.value
  const result = it.func?.()
  ```

- **Null 判断运算符**：

  - 读取对象属性的时候，如果某个属性的值是`null`或`undefined`，有时候需要为它们指定默认值。常见做法是通过`||`运算符指定默认值。<u>但是属性的值如果为空字符串或`false`或`0`，默认值也会生效。</u>

  - [ES2020](https://github.com/tc39/proposal-nullish-coalescing) 引入了一个新的 Null 判断运算符`??`。它的行为类似`||`，但是只有运算符左侧的值为`null`或`undefined`时，才会返回右侧的值。

    ```javascript
    const headerText = response.settings.headerText ?? 'Hello, world!';
    ```



## Symbol

ES6 引入了一种新的原始数据类型`Symbol`，表示**独一无二**的值。凡是对象的属性名属于 Symbol 类型，就可以保证不会与其他属性名产生冲突。

（它是 JavaScript 语言的第七种数据类型，前六种是：`undefined`、`null`、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。）

- **描述**：`Symbol`函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述`sym.description`。不管提供不提供描述，`Symbol`之间都是不相等的。

  - 如果 Symbol 的参数是一个对象，就会调用该对象的`toString`方法作为描述，然后才生成一个 Symbol 值。

- **登记机制**：`Symbol.for()`会生成新的 Symbol，同时会查找被登记在全局环境中的`Symbol`。`Symbol.keyFor()`方法返回一个已登记的 Symbol 类型值的`key`。

- **对象属性的用途**：下面给出一些用途。

  - 独一无二的属性名，能保证不会出现同名的属性，防止改写或覆盖。

  - 定义非私有的、但又希望只用于内部的方法：

    ```javascript
    let size = Symbol('size');
    
    class Collection {
      constructor() {
        this[size] = 0;
      }
    
      add(item) {
        this[this[size]] = item;
        this[size]++;
      }
    
      static sizeOf(instance) {
        return instance[size];
      }
    }
    
    let x = new Collection();
    Collection.sizeOf(x) // 0
    
    x.add('foo');
    Collection.sizeOf(x) // 1
    
    Object.keys(x) // ['0']
    Object.getOwnPropertyNames(x) // ['0']
    Object.getOwnPropertySymbols(x) // [Symbol(size)]
    ```
  
- **内置方法**：ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法。

  - `Symbol.hasInstance`：当其他对象使用`instanceof`运算符，判断是否为该对象的实例时，会调用这个方法。注意提供此方法时使用`static`。

  - `Symbol.species`：实例对象在运行过程中，需要再次调用自身的构造函数时，使用它就可以调用该属性指定的构造函数。

    ```javascript
    class MyArray extends Array {
      static get [Symbol.species]() { return Array; }
    }
    
    const a = new MyArray();
    const b = a.map(x => x);
    
    b instanceof MyArray // false
    b instanceof Array // true
    ```
    
  - `Symbol.match`、`Symbol.replace`、`Symbol.search`、`Symbol.split`：表示使用对应的字符串实例方法时，调用这些属性的方法。
  
  - `Symbol.iterator`：该对象的默认遍历器方法。
  
  - `Symbol.toPrimitive`：该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。
  
  - `Symbol.toStringTag`：用来定制`[object Object]`或`[object Array]`中`object`后面的那个字符串。



## 数据结构的扩展



### Set

- `Set`函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。
- Set 内部判断两个值是否不同，使用的算法叫做“**Same-value-zero** equality”，它类似于精确相等运算符（`===`），主要的区别是向 Set 加入值时认为`NaN`等于自身，而精确相等运算符认为`NaN`不等于自身。



### WeakSet

- WeakSet 的成员只能是对象，而不能是其他类型的值。
- WeakSet 中的对象都是弱引用，都不计入垃圾回收机制。如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。常用于弱相关的对象间，比如仅当A对象存在时，才会访问B对象。如果删除实例，它们也就随之消失，不会造成内存泄漏。



### Map

Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应。

- 作为构造函数，Map 也可以接受一个数组（不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构）作为参数。该数组的成员是一个个表示键值对的数组。

- Map 的转换

  ```javascript
  // Map 转为对象
  function strMapToObj(strMap) {
    let obj = Object.create(null);
    for (let [k,v] of strMap) {
      obj[k] = v;
    }
    return obj;
  }
  
  const myMap = new Map()
    .set('yes', true)
    .set('no', false);
  strMapToObj(myMap)
  // { yes: true, no: false }
  
  // ---
  // 对象转为 Map
  let obj = {"a":1, "b":2};
  let map = new Map(Object.entries(obj));
  
  // ---
  // Map 转为 JSON
  function strMapToJson(strMap) {
    return JSON.stringify(strMapToObj(strMap));
  }
  function mapToArrayJson(map) {
    return JSON.stringify([...map]);
  }
  ```



### WeakMap

- `WeakMap`只接受对象作为键名
- `WeakMap`的键名所指向的对象，不计入垃圾回收机制。常用于弱相关的对象间，比如仅当A对象存在时，才会访问B对象。如果删除实例，它们也就随之消失，不会造成内存泄漏。



## Proxy & Reflect



### Proxy

Proxy 即代理模式，在方法外层进行拦截。Proxy 实际上重载了点运算符，即用自己的定义覆盖了语言的原始定义。

下面是一个例子：

```javascript
var proxy = new Proxy({}, {
  get: function(target, propKey) {
    return 35;
  }
});

proxy.time // 35
proxy.name // 35
proxy.title // 35
```

-  Proxy 支持的拦截操作一览，一共 13 种。[参考](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy)
- **场景**：
  - 实现数据库的 ORM 层
  - 观察者模式
  - 数据的双向绑定：先前使用`Object.defineProporty`递归重写对象的属性的`set`和`get`方法；现在使用`Proxy`能捕获更多的操作。



### Reflect

`Reflect`对象与`Proxy`对象一样，也是 ES6 为了操作对象而提供的新 API。

`Reflect`对象的设计目的有这样几个：

- 将`Object`对象的一些明显属于语言内部的方法，放到`Reflect`对象上。
- 修改某些`Object`方法的返回结果，让其变得更合理。
-  让`Object`的某些语法上的操作都变成函数行为。
- `Reflect`对象的方法与`Proxy`对象的方法一一对应。

`Reflect`对象一共有 13 个静态方法，事实上与 Proxy 的内置方法的意味相同。



## Promise

Promise 是<u>异步编程的一种解决方案</u>，比传统的解决方案：回调函数、事件驱动、发布/订阅，更合理和更强大。

- **对象的状态不受外界影响**。`Promise`对象代表一个异步操作，有三种状态：`pending`（进行中）、`fulfilled`（已成功）和`rejected`（已失败）。
- **一旦状态改变，就不会再变**，任何时候都可以再得到这个结果。这时就称为 resolved（已定型）。
- 缺陷：
  - 无法中途取消`Promise`。
  - 处于`pending`状态时，无法得知目前进展到哪一个阶段。
- **注意**：`Promise.then`是一个微任务。详见<https://fourstacks.codes/node/>



### Monad

> https://zhuanlan.zhihu.com/p/260966706

这里提一下 Monad，它是有一个函数`flatMap`构成的一种类型。`flatMap`的函数签名是`M a -> (a -> M b) -> M b`。

不难发现 Promise 的 `then`函数是一个 `flatMap`，所以 Promise 是一个 Monad。关于 Monad 的作用：

- Monad 主要的作用是消除 IO 的副作用，将 IO 的影响控制在 Monad 的范围内。
  - 比如读用户输入的操作，`getLine`返回的是一个 IO Monad。开发者只能使用`flatMap`对内容字符串进行操作，同时只能返回另一个 Monad。将动作隔离在Monad的世界里，这样就不会将副作用带出来了。
- 另一个作用是使用 Monad 将会少写很多逻辑判断语句。此处考虑 Go 语言处理错误的情景，同时对比 Rust 和 Haskell 的同样写法。



同时注意，由于 `Promise.prototype.then` 是一个`flatMap`，所以一定要注意它接收的函数的签名`a -> M b`和返回值`M b`。同时，它接受的函数的签名却是`a -> b`，看来`then`底层封装了包括报错在内的方法。



### 基本用法

```javascript
promise
.then(result => {···})
.catch(error => {···})
.finally(() => {···});
```

```javascript
const promise = new Promise(function(resolve, reject) {
  // ... some code

  if (/* 成功 */){
    resolve(value);
  } else {
    reject(error);
  }
});


promise.then(function(value) {
  // success
}, function(error) {
  // failure
});


const p2 = new Promise(function (resolve, reject) {
  setTimeout(() => resolve(p1), 1000)
})

p2
  .then(result => console.log(result))
  .catch(error => console.log(error))
```

**注意**：

- **构造函数接受的函数**：
  - `resolve`和`reject`函数，不要写丢。
  - 调用`resolve`或`reject`并不会终结 Promise 的参数函数的执行。
- **错误处理**：
  - 在构造函数接受的函数中，报错可以通过`reject`也可以通过`throw`。
  - Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个`catch`语句捕获。
- **`then`方法接受的函数**：是一个`a -> b`的函数，而不是`a -> M b`的函数。它的实现上考虑了报错的问题。



### 新增方法

- **`Promise.prototype.finally()`**：指定不管 Promise 对象最后状态如何，都会执行的操作。注意它接受的函数没有参数。

- 多个 Promise 包装成一个 Promise 的方法：

  - `all`：相当于**and**。

    - 当数组中的状态都变成`fulfilled`，总的结果才会变成`fulfilled`
    - 当其中有一个被`rejected`，结果的状态就变成`rejected`。

  - `any`：相当于**or**。

  - `race`：返回率先改变状态的 Promise。相当于**短路操作**。

    - 下面是一个例子，如果指定时间内没有获得结果，则`reject`

      ```javascript
      const p = Promise.race([
        fetch('/resource-that-may-take-a-while'),
        new Promise(function (resolve, reject) {
          setTimeout(() => reject(new Error('request timeout')), 5000)
        })
      ]);
      
      p
      .then(console.log)
      .catch(console.error);
      ```

  - `allSettled`：等到所有这些参数实例都返回结果，固定返回`fulfilled`。相当于**非短路操作**。

- **`Promise.try`**：用 Promise 来处理同步函数和异步操作。

  - 用统一的接口来处理同步和异步，目的是提供了良好的错误捕获、可交互性和可读性。
  - 见<http://cryto.net/~joepie91/blog/2016/05/11/what-is-promise-try-and-why-does-it-matter/>
  
  
  
  

### 关于 Stream

如果某些事件不断地反复发生，一般来说，使用 [Stream](https://nodejs.org/api/stream.html) 模式是比部署`Promise`更好的选择。

JS 中的异步主要体现在 IO 的异步上。同样可以处理 IO 的方法之一是使用 Stream。它具有两种特点：

- **事件驱动**：你可以在 IO 的过程中添加一些事件回调函数，用来得知进展或处理错误。

  ```javascript
  var readerStream = fs.createReadStream('input.txt');
  readerStream.setEncoding('UTF8');
  
  readerStream.on('data', function(chunk) {
     data += chunk;
  });
  
  readerStream.on('end',function(){
     console.log(data);
  });
  
  readerStream.on('error', function(err){
     console.log(err.stack);
  });
  ```

  

- **管道**：用于从一个流中获取数据并将数据传递到另外一个流中。

  ```javascript
  fs.createReadStream('input.txt')
    .pipe(zlib.createGzip())
    .pipe(fs.createWriteStream('input.txt.gz'));
  ```



#### 流的类型

流可以是可读的、可写的、或者可读可写的。 所有的流都是 [`EventEmitter`](http://nodejs.cn/api/events.html#events_class_eventemitter) 的实例。

Node.js 中有四种基本的流类型：

- [`Writable`](http://nodejs.cn/api/stream.html#stream_class_stream_writable) - 可写入数据的流（例如 [`fs.createWriteStream()`](http://nodejs.cn/api/fs.html#fs_fs_createwritestream_path_options)）。
- [`Readable`](http://nodejs.cn/api/stream.html#stream_class_stream_readable) - 可读取数据的流（例如 [`fs.createReadStream()`](http://nodejs.cn/api/fs.html#fs_fs_createreadstream_path_options)）。
- [`Duplex`](http://nodejs.cn/api/stream.html#stream_class_stream_duplex) - 可读又可写的流（例如 [`net.Socket`](http://nodejs.cn/api/net.html#net_class_net_socket)）。
- [`Transform`](http://nodejs.cn/api/stream.html#stream_class_stream_transform) - 在读写过程中可以修改或转换数据的 `Duplex` 流（例如 [`zlib.createDeflate()`](http://nodejs.cn/api/zlib.html#zlib_zlib_createdeflate_options)）。



## Iterator 接口

对象的`Symbol.iterator`方法，等于该对象的**遍历器生成函数**，调用该函数会返回该对象的一个遍历器对象。

Iterator 接口的作用有三个：

- 为各种数据结构，提供一个统一的、简便的**访问接口**
- 使得数据结构的成员能够按某种**次序排列**
- ES6 创造了一种新的遍历命令`for...of`循环，Iterator 接口主要供`for...of`消费。

**使用场景**：

1. 解构赋值
2. 展开运算符
3. `yield*`
4. `for ... of`
5. `entries()`、`keys()`、`values()`
6. 其他调用 Iterator 的函数



### 实现

在 TS 中：

```typescript
interface Iterable {
  [Symbol.iterator]() : Iterator,
}

interface Iterator {
  next(value?: any) : IterationResult,
}

interface IterationResult {
  value: any,
  done: boolean,
}
```

在 JS 中：

```javascript
// 使用 Symbol.iterator 来声明
const obj = {
  [Symbol.iterator] : function () {
    return {
      next: function () {
        return {
          value: 1,
          done: true
        };
      }
    };
  }
};

// 使用 Generator
let myIterable = {
  [Symbol.iterator]: function* () {
    yield 1;
    yield 2;
    yield 3;
  }
};

// 或者采用下面的简洁写法
let obj = {
  * [Symbol.iterator]() {
    yield 'hello';
    yield 'world';
  }
};

// return()
function readLinesSync(file) {
  return {
    [Symbol.iterator]() {
      return {
        next() {
          return { done: false };
        },
        return() {
          file.close();
            // 必须返回一个对象，这是 Generator 语法决定的。
          return { done: true };
        }
      };
    },
  };
}

```

**注意**：

- Iterator 对象还可以具有`return()`方法和`throw()`方法。
  - `return()`方法的使用场合是，如果`for...of`循环提前退出，就会调用`return()`方法。它必须返回一个对象，这是 Generator 语法决定的。
  - `throw()`方法主要是配合 Generator 函数使用。



## Generator

- Generator 函数可以理解为一个状态机，封装了多个内部状态。它是**类似函数栈切换的操作，并没有任何同时执行的含义**。是一种惰性求值的方式（其实只要有闭包就可以惰性求值）。

- 调用 Generator 函数，**返回一个遍历器对象**，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的`next`方法，就会返回一个有着`value`和`done`两个属性的对象。`value`属性表示当前的内部状态的值，是`yield`表达式后面那个表达式的值；`done`属性是一个布尔值，表示是否遍历结束。

```javascript
function* helloWorldGenerator() {
  yield 'hello';
  yield 'world';
  return 'ending';
}

let hw = helloWorldGenerator();

// 如果一个对象的属性是 Generator 函数，可以简写成下面的形式。

let obj = {
  * myGeneratorMethod() {
    // ···
  }
};
```



**与 Iterator 的关系**

- 由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的`Symbol.iterator`属性，从而使得该对象具有 Iterator 接口。



### 切换函数栈的方式

- **`next`方法**： `yield`表达式本身没有返回值，或者说总是返回`undefined`。但`next`方法可以带一个参数，该参数就会被当作上一个`yield`表达式的返回值。相当于<u>在函数栈切换时，向内部注入值</u>，从而调整函数行为。
- **`throw`方法**：是将`yield`表达式替换成一个`throw`语句。
- **`return`方法**：是将`yield`表达式替换成一个`return`语句。

```javascript
const g = function* (x, y) {
  let result = yield x + y;
  return result;
};

const gen = g(1, 2);

gen.next(1); // Object {value: 1, done: true}
// 相当于将 let result = yield x + y
// 替换成 let result = 1;

gen.throw(new Error('出错了')); // Uncaught Error: 出错了
// 相当于将 let result = yield x + y
// 替换成 let result = throw(new Error('出错了'));

gen.return(2); // Object {value: 2, done: true}
// 相当于将 let result = yield x + y
// 替换成 let result = return 2;
```



### 原型链的考虑

- Generator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的`prototype`对象上的方法。

- Generatr 函数不应该当作普通的构造函数，因为它返回的总是遍历器对象，而不是`this`对象。

  - 所以 Generator 函数也不能跟`new`命令一起用，会报错。

    ```javascript
    function* g() {
      this.a = 11;
    }
    
    let obj = g();
    obj.next();
    obj.a // undefined
    ```
  -  但是使用call方法绑定 Generator 函数内部的this，在外部使用绑定的变量，在内部继续使用this。




### yield*

ES6 提供了`yield*`表达式，作为解决办法，用来在一个 Generator 函数里面执行另一个 Generator 函数。

```javascript
function* concat(iter1, iter2) {
  yield* iter1;
  yield* iter2;
}

// 等同于
function* concat(iter1, iter2) {
  for (var value of iter1) {
    yield value;
  }
  for (var value of iter2) {
    yield value;
  }
}

// 但是注意，concat 的 yield* 是可以接受切换函数栈的方法，如next, return 和 throw。
```



### 应用

1. **异步操作的同步化表达**

   利用 Generator 函数的暂停执行的效果，可以把异步操作写在`yield`表达式里面，等到调用`next`方法时再往后执行。

   这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在`yield`表达式下面。但是流程管理却不方便，你需要不断的`next`，而且不清楚目前在什么阶段上。

   最后需要注意，Generator 交换执行权是依赖于回调函数或 Promise。这里如何理解？其实 Promise 和 Thunk 本质都是对回调函数的包装，只是 API 更友好而已。

   ```javascript
   // 一个典型的异步操作
   function* main() {
     var result = yield request("http://some.url");
     var resp = JSON.parse(result);
     console.log(resp.value);
   }
   
   function request(url) {
     makeAjaxCall(url, function(response){
       it.next(response);
     });
   }
   
   var it = main();
   it.next();
   ```

   ![generator_synchronous_representation](/static/image/2021-01-22/generator_synchronous_representation.png)

2. **控制流管理**

   采用回调函数会导致回调地狱；采用 Promise 则不能像命令式语言那样处理错误，且样板代码冗余；使用 Generator 则考虑了二者。

3. **实现 Iterator 接口**



## 异步编程中的 Generator

异步编程的传统方法有：回调函数、事件监听、发布/订阅、Promise。

首先要明确一个问题，什么是同步，什么是异步？

- 同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。**由调用者主动等待这个调用的结果。**
- 异步是指，在调用函数或执行任务后，调用者不会立刻得到结果。而是通过其他方式，**由被调用者向调用者通知或回调的方式。**
  - 实际上一个更舒服的表述是，**任务不是连续进行**的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备（相关的外部的IO或计算完成），再回过头执行第二段。



### 协程

协程（coroutine）是一种程序运行的方式，可以理解成“协作的线程”或“协作的函数”。

- 协程是指，多个线程（单线程情况下，即多个函数）可以并行执行，但是只有一个线程（或函数）处于正在运行的状态，其他线程（或函数）都处于暂停态，线程（或函数）之间可以交换执行权。协程是同时存在多个栈，但只有一个栈是在运行状态，也就是说，协程是以多占用内存为代价，实现多任务的并行。

- 多线程和协程的不同之处在于：
  - 同一时间可以有多个线程处于运行状态，但是运行的协程只能有一个，其他协程都处于暂停状态。
  - 普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。



**总结一下**，<u>协程是指这样的程序运行方式</u>：

1. 同时存在多个函数栈，但只有其中一个在运行；
2. 协程拥有线程一样的生存周期状态。多个协程（各拥有一个函数栈）之间的执行权，由协程自己分配从而切换函数栈。



注意，Generator 函数是 ES6 对协程的**不完全实现**。Generator 函数称为“半协程”（semi-coroutine），意思是只有 Generator 函数的调用者，才能将程序的执行权还给 Generator 函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。



### Thunk

Thunk 函数原本的设计是在编译器上实现“**传名调用**”。它其实是惰性求值在参数上的体现，即将参数表达式传入函数，当需要时再计算。

原理是利用闭包，捕获表达式中的变量上下文，在需要调用函数时再计算。

```javascript
// 一个函数调用的例子
const f = m => m * 2;
f(x + 5);

// 在传名调用语言下，编译器实现它的策略之一是：
const f = thunk =>  thunk() * 2;
const thunk = () => x + 5;
f(thunk);
```



#### JS 中的 Thunk

Generator 的异步操作同步化表达，解决了回调地狱和 Promise 的两个缺点（错误/异常处理、样本代码冗余）。但是流程管理却不方便，你需要不断的next，而且不清楚目前在什么阶段上。

Thunk 函数是自动执行 Generator 函数的一种方法（并不是唯一方案）。

它本身其实是利用柯里化方式，将参数置于闭包中，目的是提取出 callback 函数，以此来自动执行含有回调函数的异步操作。

```javascript
// 定义一些函数
var readFileThunk = thunkify(fs.readFile);
function* g() {
  var f1 = yield readFileThunk('fileA');
  var f2 = yield readFileThunk('fileB');
  // ...
  var fn = yield readFileThunk('fileN');
}

// 自动执行 Generator
function run(fn) {
  var gen = fn();

  function next(err, data) {
    var result = gen.next(data);
    // result.value 是 Thunk 提取的回调函数
    // result.done 描述 Generator 是否结束
    if (result.done) return;
    result.value(next);
  }

  next();
}

run(g);
```

co 函数库提供了更强的自动执行能力，它的使用条件是`yield`右侧必须是 Thunk 后的函数或 Promise。

需要注意的是，`yield`右侧的函数仍然可能是同步执行的。这里只是拿`fs.readFile`举例而已，如果需要异步执行请调用异步函数或者自己写原生方法。



## async

async 函数就是 Generator 函数的语法糖。`async`函数就是将 Generator 函数的星号（`*`）替换成`async`，将`yield`替换成`await`，仅此而已。

`async`函数对 Generator 函数的改进，体现在以下四点。

1. **内置执行器**：不再需要 co 模块等自动执行 Generator 的函数。
2. **更准确的语义**：使用 Generator 作为异步调用的主逻辑，会有一种文不对题的感觉。
3. **更广的适用性**：co模块中的`yield`接受 Thunk 函数或 Promise 对象，但是`await`后面可以接 Promise 和基本类型（虽然会自动转换为 resolved 的 Promise）
4. **返回值是 Promise**：比 Generator 函数的返回值是 Iterator 对象方便多了。



```javascript
// 函数声明
async function foo() {}

// 函数表达式
const foo = async function () {};

// 箭头函数
const foo = async () => {};

// 对象的方法
let obj = { async foo() {} };
obj.foo().then(...)

// Class 的方法
class Storage {
  constructor() {
    this.cachePromise = caches.open('avatars');
  }

  async getAvatar(name) {
    const cache = await this.cachePromise;
    return cache.match(`/avatars/${name}.jpg`);
  }
}

const storage = new Storage();
storage.getAvatar('jake').then(…);
```



### 语法

1. 返回值是 Promise
2. `await`语句可以返回一个值，它是异步函数返回的 Promise 内部的值



**注意**

1. `await`命令后面的`Promise`对象，运行结果可能是`rejected`，所以最好把`await`命令放在`try...catch`代码块中，或`catch`它。
2. 多个`await`命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。
3. `await`命令只能用在`async`函数之中



**新提案 - 顶层await**

允许在模块的顶层独立使用`await`命令，目的是借用`await`解决模块异步加载的问题。

注意，顶层`await`只能用在 ES6 模块，不能用在 CommonJS 模块。这是因为 CommonJS 模块的`require()`是同步加载，如果有顶层`await`，就没法处理加载了。



### 原理

async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。

```javascript
async function fn(args) {
  // ...
}

// 等同于
function fn(args) {
  return spawn(function* () {
    // ...
  });
}

// 这是 spawn 函数的实现，即内置的自动执行器
function spawn(genF) {
  return new Promise(function(resolve, reject) {
    const gen = genF();
    function step(nextF) {
      let next;
      try {
        next = nextF();
      } catch(e) {
        return reject(e);
      }
      if(next.done) {
        return resolve(next.value);
      }
      Promise.resolve(next.value).then(function(v) {
        step(function() { return gen.next(v); });
      }, function(e) {
        step(function() { return gen.throw(e); });
      });
    }
    step(function() { return gen.next(undefined); });
  });
}

```



## Class

ES6 的`class`可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的`class`写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。

```javascript
class Point {
  // 构造函数：写法完全一样
  constructor(x, y, ...args) {
    this.x = x;
    this.y = y;
    this.args = args;
  }

  // 实例方法，不需要加 function 关键字
  toString() {
    return '(' + this.x + ', ' + this.y + ')';
  }
    
  * [Symbol.iterator]() {
    for (let arg of this.args) {
      yield arg;
    }
  }
}
```



- class 完全可以看作是构造函数

    ```javascript
    typeof Point // "function"
    Point === Point.prototype.constructor // true
    ```
    
- 类的所有方法都定义在类的`prototype`属性上面。

    ```javascript
    class Point {
      constructor() {}
      toString() {}
      toValue() {}
    }
    
    // 等同于
    Point.prototype = {
      constructor() {},
      toString() {},
      toValue() {},
    };
    ```

- 另外，类的内部所有定义的方法，都是不可枚举的。这一点与 ES5 的行为不一致。



###  语法

1. `constructor`：不同于普通构造函数，类必须使用`new`调用，否则会报错。这里提一下**`new`关键字的作用**：

   1. 创建一个空的简单JavaScript对象（即`**{}**`）；
   2. 设置该对象的**constructor**到构造函数 ；
   3. 将步骤1新创建的对象作为`**this**`的上下文 ；
   4. 如果该函数没有返回对象，则返回`**this**`。

2. 原型对象：实例的属性除非显式定义在`this`对象上，否则都是定义在原型上。

   - 如各类方法和静态成员

3. `setter / getter`

   ```javascript
   class MyClass {
     constructor() {
       // ...
     }
     get prop() {
       return 'getter';
     }
     set prop(value) {
       console.log('setter: '+value);
     }
   }
   ```

4. Class 表达式：可以写出立即执行的 Class

   ```javascript
   // Class 的内部，只能用类本身的名字。
   // Class 的外部，只能用绑定的名字。
   const MyClass = class Me {
     getClassName() {
       return Me.name;
     }
   };
   
   // 如果类的内部没用到的话，可以省略名字
   const MyClass = class { /* ... */ };
   
   // 采用 Class 表达式，可以写出立即执行的 Class。
   let person = new class {
     constructor(name) {
       this.name = name;
     }
   
     sayName() {
       console.log(this.name);
     }
   }('张三');
   ```

5. `this`的指向：注意如果将某个方法提取出来作为函数单独使用，那么`this`的指向会改变。详见另一个文章，讨论`this`的指向。



#### 静态方法

```javascript
class Foo {
  static bar() {
    return 'hello';
  }
}

Foo.bar()
// 'hello'

new Foo().bar()
// TypeError: foo.bar is not a function
```



本质上，静态方法是直接写入类对象中的，即`Foo.bar`上；而不是写在`Foo.prototype.bar`上。

- 注意：静态方法中的`this`关键字指的是类，而不是实例。

  ```javascript
  class Foo {
    static bar() {
      this.baz();
    }
  }
  Foo.bar();
  ```

- 父类的静态方法，可以被子类继承。



#### 实例属性

实例属性除了定义在`constructor()`方法里面的`this`上面，也可以定义在类的最顶层。

```javascript
class IncreasingCounter {
  _count = 0;

  get value() {
    console.log('Getting the current value!');
    return this._count;
  }
  increment() {
    this._count++;
  }
}
```



#### 静态属性

ES6 明确规定，Class 内部只有静态方法，没有静态属性。

但是现在有一个[提案](https://github.com/tc39/proposal-class-fields)提供了类的静态属性，写法是在实例属性的前面，加上`static`关键字。

```javascript
class MyClass {
  static myStaticProp = 42;

  constructor() {
    console.log(MyClass.myStaticProp); // 42
  }
}
```



#### 私有方法 / 私有属性

 ES6 不提供私有方法和私有属性。

有两种比较好的模拟方法：

1. 将私有方法移出类，在导出模块时不包含即可。
2. 将私有方法命名`Symbol`值，并且不暴露`Symbol`。但是`Reflect.ownKeys()`依然可以拿到它们。

目前，有一个[提案](https://github.com/tc39/proposal-private-methods)，为`class`加了私有属性和方法。

```javascript
class IncreasingCounter {
  #count = 0;
  get value() {
    console.log('Getting the current value!');
    return this.#count;
  }
  increment() {
    this.#count++;
  }
}

class Foo {
  #a;
  #b;
  constructor(a, b) {
    this.#a = a;
    this.#b = b;
  }
  #sum() {
    return this.#a + this.#b;
  }
  printSum() {
    console.log(this.#sum());
  }
}
```



### 继承

Class 可以通过`extends`关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。

```javascript
class ColorPoint extends Point {
  constructor(x, y, color) {
    // 调用父类的constructor(x, y)
    super(x, y);
    this.color = color;
  }

  toString() {
    // 调用父类的toString()
    return this.color + ' ' + super.toString();
  }
}
```

- 子类必须在`constructor`方法中调用`super`方法，否则新建实例时会报错。
  - 因为子类的`this`对象，必须先通过父类的构造函数，得到父类的实例属性和实例方法（注意：不包含父类原型上的方法，这是需要`Object.create`的）
- 父类的静态方法，也会被子类继承。



#### super 关键字

`super`这个关键字，既可以当作函数使用，也可以当作对象使用。

1. **作为函数**：`super()`只能并且必须用在子类的构造函数之中。
2. **作为对象**：在静态方法中指父类名字，在实例方法中指父类原型。

注意，使用`super`的时候，必须显式指定是作为函数、还是作为对象使用，否则会因为二义性报错。



#### Mixin 模式

ES6 如何继承多个类？

一种方法是将多个类的属性合并在一起，得到一个新的类，再继承这个新类。

```javascript
function mix(...mixins) {
  class Mix {
    constructor() {
      for (let mixin of mixins) {
        copyProperties(this, new mixin()); // 拷贝实例属性
      }
    }
  }

  for (let mixin of mixins) {
    copyProperties(Mix, mixin); // 拷贝静态属性
    copyProperties(Mix.prototype, mixin.prototype); // 拷贝原型属性
  }

  return Mix;
}

function copyProperties(target, source) {
  for (let key of Reflect.ownKeys(source)) {
    if ( key !== 'constructor'
      && key !== 'prototype'
      && key !== 'name'
    ) {
      let desc = Object.getOwnPropertyDescriptor(source, key);
      Object.defineProperty(target, key, desc);
    }
  }
}

// Mixin 模式
class DistributedEdit extends mix(Loggable, Serializable) {
  // ...
}
```



## Module

在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。

ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。

```javascript
// ES6模块
import { stat, exists, readFile } from 'fs';
```

上面代码的实质是从`fs`模块加载 3 个方法，其他方法不加载。这种加载称为“**编译时加载**”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。



### 严格模式

严格模式是 ES5 引入的。而 ES6 的**<u>模块</u>自动采用严格模式**，不管你有没有在模块头部加上`"use strict";`。

严格模式主要有以下限制。

- 变量必须声明后再使用
- 函数的参数不能有同名属性，否则报错
- 不能使用`with`语句
- 不能对只读属性赋值，否则报错
- 不能使用前缀 0 表示八进制数，否则报错
- 不能删除不可删除的属性，否则报错
- 不能删除变量`delete prop`，会报错，只能删除属性`delete global[prop]`
- `eval`不会在它的外层作用域引入变量
- `eval`和`arguments`不能被重新赋值
- `arguments`不会自动反映函数参数的变化
- 不能使用`arguments.callee`
- 不能使用`arguments.caller`
- **禁止`this`指向全局对象**
- 不能使用`fn.caller`和`fn.arguments`获取函数调用的堆栈
- 增加了保留字（比如`protected`、`static`和`interface`）



### 语法



#### 导出

- `export`命令可以输出变量、函数或类。

    ```javascript
    // 写法一
    export var m = 1;

    // 写法二
    var m = 1;
    export {m};

    // 写法三
    var n = 1;
    export {n as m};
    ```
    
- `export default` ：当使用`import`命令的时候，用户需要知道所要加载的变量名或函数名。但为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到`export default`命令，为模块指定默认输出。

    ```javascript
    // export-default.js
    export default function () {
      console.log('foo');
    }
    ```

    ```javascript
    // import-default.js
    import customName from './export-default';
    customName(); // 'foo'
    ```

    本质上，`export default`就是输出一个叫做`default`的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。

    ```javascript
    // modules.js
    function add(x, y) {
      return x * y;
    }
    export {add as default};
    // 等同于
    // export default add;
    
    // app.js
    import { default as foo } from 'modules';
    // 等同于
    // import foo from 'modules';
    ```

- **导出其他模块**

  如果在一个模块之中，先输入后输出同一个模块，`import`语句可以与`export`语句写在一起。

  ```javascript
  export { foo, bar } from 'my_module';
  
  // 可以简单理解为
  import { foo, bar } from 'my_module';
  export { foo, bar };
  ```

  



#### 导入

```javascript
import { lastName as surname } from './profile.js';
import { firstName, lastName, year } from './profile.js';
import * as circle from './circle';
```

- `import`命令输入的变量都是**只读**（注意并非是`freeze`的效果）的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。
- 注意，`import`命令**具有提升效果**，会提升到整个模块的头部，首先执行。
- 由于`import`是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。



#### 动态导入

前面介绍过，`import`命令会被 JavaScript 引擎静态分析，在语法上，条件加载就不可能实现。

[ES2020提案](https://github.com/tc39/proposal-dynamic-import) 引入`import()`函数，支持动态加载模块。

```javascript
import(specifier)
// 参数 specifier，指定所要加载的模块的位置
// 与 import 语句完全一致
```

`import()`返回一个 <u>Promise 对象</u>。下面是一个例子。

```javascript
const main = document.querySelector('main');

import(`./section-modules/${someVariable}.js`)
  .then(module => {
    module.loadPageInto(main);
  })
  .catch(err => {
    main.textContent = err.message;
  });
```



**使用场合**

- 按需/条件加载
- 动态的模块路径



### 加载的实现



#### 浏览器的加载

- 浏览器是默认同步加载 JavaScript 脚本，遇到`<script>`就等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。

- 浏览器允许脚本异步加载，下面就是两种异步加载的语法。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行。

  - `defer`是“渲染完再执行”，`async`是“下载完就执行”。

  ```html
  <script src="path/to/myModule.js" defer></script>
  <script src="path/to/myModule.js" async></script>
  ```

- 浏览器也可以加载 ES6 模块，需要在标签上加入`type="module"`属性。默认异步加载，等同于打开了`defer`属性。

  ```html
  // 默认 defer 模式
  <script type="module" src="./foo.js"></script>
  // 也可以使用 async 模式
  <script type="module" src="./foo.js" async></script>
  ```

  ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。

  ```html
  <script type="module">
    import utils from "./utils.js";
  
    // other code
  </script>
  ```

  注意，对于外部模块脚本（上面的`foo.js`），代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。（利用顶层的`this`等于`undefined`这个语法点，可以侦测当前代码是否在 ES6 模块之中。）



#### Node.js 的加载

JavaScript 现在有两种模块。一种是 ES6 模块，简称 ESM；另一种是 CommonJS 模块，简称 CJS。

首先，必须了解 ES6 模块与 CommonJS 模块完全不同。

它们有三个重大差异。

- CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是**值的引用**。
  - CommonJS 模块内部的变化对外部没有影响。
  - ES6 的方式是动态地去被加载的模块取值，并且变量总是绑定其所在的模块。相当于<u>模块是含有自己的状态的</u>，加载多次只有一个状态。一个模块变量的改变，可以影响所以引用它的模块。
- CommonJS 模块是运行时加载，ES6 模块是**编译时输出**接口。
  -  CommonJS 加载的是一个对象（即`module.exports`属性），该对象只有在脚本运行完才会生成。
- CommonJS 模块的`require()`是同步加载模块，ES6 模块的`import`命令是**异步加载**，有一个独立的模块依赖的解析阶段。

<br>



接下来讲 Node.js 的方案。

CommonJS 模块是 Node.js 专用的，与 ES6 模块不兼容。它们采用不同的加载方案。从 Node.js v13.2 版本开始，Node.js 已经默认打开了 ES6 模块支持。

- **标识一个 ESM / CJS**：Node.js 要求能够识别 ES6 模块，有一些几个方法
  - 使用`.mjs`/`.cjs`后缀文件名；
  - 在项目的`package.json`文件中，指定`type`字段为`module`/`commonjs`；

- **模块加载的入口文件**：`package.json`文件有两个字段可以指定模块的入口文件：`main`和`exports`。

  关于`exports`，它有多种用法：脚本或子目录别名、主入口别名、条件加载。

  ```javascript
  // ./node_modules/es-module-package/package.json
  {
    "type": "module",
    "main": "./src/index.js"
  }
  ```

- **入口文件的`import`加载**：Node.js 根据入口文件会到`./node_modules`目录下面，寻找对应模块，然后根据该模块`package.json`的`main`字段去执行入口文件。

  ```javascript
  // ./my-app.mjs
  
  import { something } from 'es-module-package';
  // 实际加载的是 ./node_modules/es-module-package/src/index.js
  ```

- **关于加载路径**
  - ES6 模块的加载路径必须给出脚本的完整路径，**不能省略脚本的后缀名**。
  - 为了与浏览器的`import`加载规则相同，Node.js 的`.mjs`文件支持 URL 路径。<u>同一个脚本只要参数不同，就会被加载多次，并且保存成不同的缓存。</u>



### 循环依赖

循环依赖（circular dependency），这里也可以叫循环加载。

目前最常见的两种模块格式 CommonJS 和 ES6，处理“循环加载”的方法是不一样的，返回的结果也不一样。



#### CommonJS

CommonJS 的一个模块，就是一个脚本文件。`require`命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。无论加载多少次，都只会运行一次。即**带缓存的加载时执行**。

而一旦出现某个模块被‘循环加载’，就**只输出已经执行的部分**，还未执行的部分不会输出。

```javascript
{
  id: '...',        // 模块名
  exports: { ... }, // 输出的各个接口
  loaded: true,     // 该模块的脚本是否执行完毕
  ...
}
```



#### ES6

ES6 模块是动态引用，如果使用`import`从一个模块加载变量，那些变量不会被缓存，而是成为一个指向被加载模块的引用。

<u>此处原作者的意思非常模糊，故不做讨论。</u>