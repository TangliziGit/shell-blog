# ES6 标准学习

> 大部分参考 [ECMAScript 6 入门](https://es6.ruanyifeng.com/#docs/intro)

需要特别注意的特性：

1. `let`：存在**暂时性死区**
2. 解构赋值：注意对象也可以解构
3. 正则的具名组匹配



## 变量声明

> https://es6.ruanyifeng.com/#docs/let

- ES6 一共有 6 种声明变量的方法：`var`、`function`、`let`、`const`、`import`、`class`



### let 与 var

使用`let`替代`var`，这里讲`var`的特殊和差异之处。例子请看参考链接。

- `var`声明是**全局范围**的，并且可以**重复声明**。
- `var`命令会发生“**变量提升**”现象：变量可以在声明之前使用，值为`undefined`。
- `let`命令会存在一个**暂时性死区**的问题：只要块级作用域内存在`let`命令，它所声明的变量就“绑定”这个区域，不再受外部的影响。
  - 强行使用会`ReferenceError`。
  - 这样的设计是为了让大家养成良好的编程习惯，<u>变量一定要在声明之后使用，否则就报错。</u>

- `var`声明只有全局作用域和函数作用域，**没有块级作用域**。
  - 第一种场景，内层变量可能会覆盖外层变量。函数作用域优先变量提升，从而覆盖全局作用域。
  - 第二种场景，用来计数的循环变量泄露为全局变量。
  - 块级作用域的出现，实际上使得获得广泛应用的<u>匿名立即执行函数表达式</u>（匿名 IIFE）不再必要了。
  - ES6 规定，块级作用域之中，<u>函数声明语句的行为类似于`let`</u>，在块级作用域之外不可引用。

总结一下，`let`是作用于**块级作用域**上的**不可重复声明**的声明语句，但使用它降存在**暂时性死区**的问题



### const

`const`与`let`在三个方面上一样：**块级作用域**、**不可重复声明**、**暂时性死区**

但是注意：`const`保证的是变量指向的内存地址所保存的数据不得改动，即对于基本数据是不变的，对于对象则内容可变而它存储的指针不变。

如果真的想将**对象冻结**，应该使用`Object.freeze`方法。而且除了将对象本身冻结，对象的属性也应该冻结。



### 顶层对象

ES5 之中，顶层对象的属性与全局变量是等价的。顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。



#### 脱钩

ES6 为了改变这一点，一方面规定，为了保持兼容性，`var`命令和`function`命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，`let`命令、`const`命令、`class`命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。



#### 统一的顶层对象

JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。

[ES2020](https://github.com/tc39/proposal-global) 在语言标准的层面，引入`globalThis`作为顶层对象。也就是说，任何环境下，`globalThis`都是存在的，都可以从它拿到顶层对象，指向全局环境下的`this`。

垫片库[`global-this`](https://github.com/ungap/global-this)模拟了这个提案，可以在所有环境拿到`globalThis`。



## 解构赋值

- 解构赋值的规则是，只要等号右边的值不是对象或数组，就**先将其转为对象**。由于`undefined`和`null`无法转为对象，所以对它们进行解构赋值，都会报错。



### 数组的解构

以下是一些例子：

```javascript
let [foo, [[bar], baz]] = [1, [[2], 3]];
let [ , , third] = ["foo", "bar", "baz"];
let [x, , y] = [1, 2, 3];
let [head, ...tail] = [1, 2, 3, 4];
let [x, y, ...z] = ['a'];
// y === undefined
// z === []
```

- **解构失败值**是`undefined`；解构**支持不完全解构**`let [x, y] = [1, 2, 3];`

- 只要某种数据结构具有 **Iterator 接口**，都可以采用数组形式的解构赋值。如果不是，则报错。

  - Set 结构，也可以使用数组的解构赋值。
  - Generator 函数，原生具有 Iterator 接口。

- **默认值**：ES6 内部使用严格相等运算符（`===`），判断一个位置是否有值。所以，只有当一个数组成员严格等于`undefined`，默认值才会生效。同时如果默认值是一个表达式，那么这个**表达式是惰性求值**的

  ```javascript
  let [x = 1] = [undefined];
  x // 1
  
  let [x = 1] = [null];
  x // null
  ```

- 可以将一个已经声明的变量用于解构赋值。



### 对象的解构

```javascript
let { bar, foo } = { foo: 'aaa', bar: 'bbb' };
foo // "aaa"
bar // "bbb"

let { baz } = { foo: 'aaa', bar: 'bbb' };
baz // undefined

let { first: f, last: l } = { first: 'hello', last: 'world' };
f // 'hello'
l // 'world'

var {x: y = 3} = {x: 5};
y // 5
```

- **解构失败值**是`undefined`
- 解构可以给定替换的 key，如例3。**注意**被替换的是后者，而不是前者。就像声明一对kv一样，把它当作模式匹配。



**注意**：

- 如果要将一个已经声明的变量用于解构赋值：

  ```javascript
  let x;
  ({x} = {x: 1});
  ```



### 形参的解构

```javascript
const add = ([x, y]) => x + y;
```



### 用处

1. **快速提取 JSON 数据**
2. **函数参数的默认值**：避免了在函数体内部再写`var foo = config.foo || 'default foo';`这样的语句。
3. **遍历 Map 结构**：任何部署了 Iterator 接口的对象，都可以用`for...of`循环遍历。



## 字符串的扩展

1. **字符的 Unicode 表示法**：ES6 允许采用`\uxxxx`形式表示一个字符，其中`xxxx`表示字符的 Unicode 码点。

2. **字符串的遍历器接口**：除了遍历字符串，这个遍历器最大的优点是可以识别大于`0xFFFF`的码点，传统的`for`循环无法识别这样的码点。

3. **模板字符串**：可以用来定义多行字符串，或者在字符串中嵌入变量。

   - **标签模板**：它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。

     ```javascript
     alert`hello`
     // 等同于
     alert(['hello'])
     
     // 下面是一些应用，是自定义函数对标签模板进行处理：
     // 1. 过滤 HTML 字符串
     // 2. 多语言转换
     // 3. 嵌入其他语言
     ```



### 新增方法

1. `String.fromCharPoint()`：用于从 Unicode 码点返回对应字符，相比 ES5 它能识别码点大于`0xFFFF`的字符。

2. `String.raw()`：返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串。

3. **实例方法`codePointAt()`**：能够正确处理 4 个字节储存的字符，返回一个字符的码点。

   - JavaScript 内部，**字符以 UTF-16 的格式储存**。当遇到2个字节组成的字符时：

   - `charAt()`方法无法读取整个字符

   - `charCodeAt()`方法只能分别返回前两个字节和后两个字节的值。

   - `codePointAt()`方法返回一个字符的码点。**注意**：为了对齐字符串长度，当索引指向字符后半段时，返回值等于`charCodeAt()`

     ```javascript
     var s = "𠮷";
     
     s.length // 2
     s.charAt(0) // ''
     s.charAt(1) // ''
     s.charCodeAt(0) // 55362
     s.charCodeAt(1) // 57271
     s.codePointAt(0) // 134071
     s.codePointAt(1) // 57271
     s.codePointAt(0).toString(16) // "20bb7"
     ```

4. 实例方法`normalize()`：用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。

5. **实例方法`includes() startsWith() endsWith()`**

6. **实例方法`repeat()`**

7. **实例方法`padStart() padEnd()`**：引入了字符串补全长度的功能。

   ```javascript
   // 常见用途是为数值补全指定位数
   '1'.padStart(10, '0') // "0000000001"
   '12'.padStart(10, '0') // "0000000012"
   '123456'.padStart(10, '0') // "0000123456"
   
   // 另一个用途是提示字符串格式
   '12'.padStart(10, 'YYYY-MM-DD') // "YYYY-MM-12"
   '09-12'.padStart(10, 'YYYY-MM-DD') // "YYYY-09-12"
   ```

8. **实例方法`trimStart() trimEnd()`**
9. **实例方法`matchAll() replaceAll()`**



## 正则的扩展

> https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions



### 各种修饰符

ES6 为正则表达式新增了`flags`属性，会返回正则表达式的修饰符。

```javascript
// ES5 的 source 属性： 返回正则表达式的正文
/abc/ig.source
// "abc"

// ES6 的 flags 属性：返回正则表达式的修饰符
/abc/ig.flags
// 'gi'

/hello\d/y.sticky	// true
/hello/u.unicode	// true
```



1. **u修饰符**：含义为“Unicode 模式”，用来正确处理大于`\uFFFF`的 Unicode 字符。

2. **y修饰符**：首先`g`修饰符是从头开始向后搜索，直到发现匹配为止。而`y`修饰符则是从头开始，如果当前不匹配则返回`null`。这称为粘连模式。它需要与`g`修饰符连用，否则只会匹配第一个元素。

3. **s修饰符**：`dotAll`模式，即点（dot）代表一切字符。

   - 正则表达式中，点（`.`）是一个特殊字符，代表任意的单个字符，但是有两个例外；<br>一个是四个字节的 UTF-16 字符，这个可以用`u`修饰符解决；<br>另一个是行终止符：换行符、回车符、行分隔符、段分隔符
   ```javascript
   /foo.bar/s.test('foo\nbar') // true
   ```



### Unicode 属性类

允许正则表达式匹配符合 Unicode 某种属性的所有字符。

- Unicode 属性类要指定属性名和属性值。对于某些属性，可以只写属性名，或者只写属性值。
- `\P{…}`是`\p{…}`的反向匹配，即匹配不满足条件的字符。
- 这两种类只对 Unicode 有效，所以使用的时候一定要加上`u`修饰符。

```javascript
const regexGreekSymbol = /\p{Script=Greek}/u;
regexGreekSymbol.test('π') // true

const regex = /^\p{Decimal_Number}+$/u;
regex.test('𝟏𝟐𝟑𝟜𝟝𝟞𝟩𝟪𝟫𝟬𝟭𝟮𝟯𝟺𝟻𝟼') // true

// 匹配所有数字
const regex = /^\p{Number}+$/u;
regex.test('²³¹¼½¾') // true
regex.test('㉛㉜㉝') // true
regex.test('ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ') // true

// 匹配所有空格
\p{White_Space}
// 匹配各种文字的所有字母，等同于 Unicode 版的 \w
[\p{Alphabetic}\p{Mark}\p{Decimal_Number}\p{Connector_Punctuation}\p{Join_Control}]
// 匹配各种文字的所有非字母的字符，等同于 Unicode 版的 \W
[^\p{Alphabetic}\p{Mark}\p{Decimal_Number}\p{Connector_Punctuation}\p{Join_Control}]
// 匹配 Emoji
/\p{Emoji_Modifier_Base}\p{Emoji_Modifier}?|\p{Emoji_Presentation}|\p{Emoji}\uFE0F/gu

// 匹配所有的箭头字符
const regexArrows = /^\p{Block=Arrows}+$/u;
regexArrows.test('←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩') // true
```



### 具名组匹配

原有组匹配的使用方法：

```javascript
const RE_DATE = /(\d{4})-(\d{2})-(\d{2})/;

const matchObj = RE_DATE.exec('1999-12-31');
const year = matchObj[1]; // 1999
const month = matchObj[2]; // 12
const day = matchObj[3]; // 31
```

ES2018 引入了**具名组匹配**，允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。

“具名组匹配”在圆括号内部，模式的头部添加“**问号 + 尖括号 + 组名**”（`?<year>`），然后就可以在`exec`方法返回结果的`groups`属性上引用该组名。同时，数字序号（`matchObj[1]`）依然有效。

```javascript
const RE_DATE = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/;

const matchObj = RE_DATE.exec('1999-12-31');
const year = matchObj.groups.year; // "1999"
const month = matchObj.groups.month; // "12"
const day = matchObj.groups.day; // "31"
```



#### 解构赋值和替换

1. 有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。

    ```javascript
    let {groups: {one, two}} = /^(?<one>.*):(?<two>.*)$/u.exec('foo:bar');
    one  // foo
    two  // bar
    ```

2. 字符串替换时，使用`$<组名>`引用具名组。

    ```javascript
    let re = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/u;

    '2015-01-02'.replace(re, '$<day>/$<month>/$<year>')
    // '02/01/2015'
    ```

    上面代码中，`replace`方法的第二个参数是一个字符串，而不是正则表达式。

    `replace`方法的第二个参数也可以是函数，该函数的参数序列如下。

    ```javascript
    '2015-01-02'.replace(re, (
       matched, // 整个匹配结果 2015-01-02
       capture1, // 第一个组匹配 2015
       capture2, // 第二个组匹配 01
       capture3, // 第三个组匹配 02
       position, // 匹配开始的位置 0
       S, // 原字符串 2015-01-02
       groups // 具名组构成的一个对象 {year, month, day}
     ) => {
     let {day, month, year} = groups;
     return `${day}/${month}/${year}`;
    });
    ```

    具名组匹配在原来的基础上，新增了最后一个函数参数：具名组构成的一个对象。函数内部可以直接对这个对象进行解构赋值。



#### 引用

如果要在正则表达式内部引用某个“具名组匹配”，可以使用`\k<组名>`的写法。

```javascript
const RE_TWICE = /^(?<word>[a-z]+)!\k<word>$/;
RE_TWICE.test('abc!abc') // true
RE_TWICE.test('abc!ab') // false
```

数字引用（`\1`）依然有效。

```javascript
const RE_TWICE = /^(?<word>[a-z]+)!\1$/;
RE_TWICE.test('abc!abc') // true
RE_TWICE.test('abc!ab') // false
```

这两种引用语法还可以同时使用。

```javascript
const RE_TWICE = /^(?<word>[a-z]+)!\k<word>!\1$/;
RE_TWICE.test('abc!abc!abc') // true
RE_TWICE.test('abc!abc!ab') // false
```



### 其他

1. 支持后行断言：

   ```javascript
   // 先行断言
   /\d+(?=%)/.exec('100% of US presidents have been male');  // ["100"]
   /\d+(?!%)/.exec('that’s all 44 of them');                 // ["44"]
   
   // 后行断言
   /(?<=\$)\d+/.exec('Benjamin Franklin is on the $100 bill');  // ["100"]
   /(?<!\$)\d+/.exec('it’s is worth about €90');                // ["90"]
   ```

2. `matchAll`

   - 原有正则匹配全局应使用`g`，并用循环取得结果`while (match = regex.exec(string))`

   - [ES2020](https://github.com/tc39/proposal-string-matchall) 增加了`String.prototype.matchAll()`方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。

     ```javascript
     const string = 'test1test2test3';
     const regex = /t(e)(st(\d?))/g;
     
     for (const match of string.matchAll(regex)) {
       console.log(match);
     }
     // ["test1", "e", "st1", "1", index: 0, input: "test1test2test3"]
     // ["test2", "e", "st2", "2", index: 5, input: "test1test2test3"]
     // ["test3", "e", "st3", "3", index: 10, input: "test1test2test3"]
     
     // 转为数组的方法一
     [...string.matchAll(regex)]
     
     // 转为数组的方法二
     Array.from(string.matchAll(regex))
     ```



## 数值的扩展

此处内容大多用不到，故简写。

1. **指数运算符（`**`）**
2. **BigInt**：BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。字面量必须添加后缀`n`。



## 函数的扩展

1. **默认参数**：默认参数<u>惰性求值</u>；还可与解构赋值搭配；函数的`length`属性返回没有指定默认值的参数个数
2.  **rest 参数**：获取函数的多余参数，例：`function add(...xs)`。同时它只能是最后一个参数。
3. **name 属性**：返回该函数的函数名。注意匿名函数则返回对应的变量名。
4. **尾调用优化（调用栈复用）**：尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。ES6 的尾调用优化只在严格模式下开启。
5. **catch语句参数省略**：很多时候，`catch`代码块可能用不到这个报错参数。



### 箭头函数

1. 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。
2. 箭头函数可以与变量解构结合使用。
3. 如果函数体很复杂，有许多行，或者函数内部有大量的读写操作，不单纯是为了计算值，这时也不应该使用箭头函数，而是要使用普通函数，这样可以提高代码可读性。



**注意**：

箭头函数里面根本没有自己的`this`，而是**引用外层<u>代码块</u>的`this`**。箭头函数让`this`指向固定化，从动态变为静态。

- （在 JavaScript 中，函数是对象的方法。如果一个函数不是 JavaScript 对象的方法，那么它就是全局对象的函数。`call`方法是指函数作用与某个指定对象上。）

- 所以，箭头函数转成 ES5 的代码如下。

  ```javascript
  // ES6
  function foo() {
    setTimeout(() => {
      console.log('id:', this.id);
    }, 100);
  }
  
  // ES5
  function foo() {
    var _this = this;
  
    setTimeout(function () {
      console.log('id:', _this.id);
    }, 100);
  }
  ```



这导致了：

1. **不可以当作构造函数**，也就是说，不可以使用`new`命令，否则会抛出一个错误。
2. 不可以使用`arguments`对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。
3. 不可以使用`yield`命令，因此箭头函数不能用作 Generator 函数。



## 数组的扩展

1. **展开运算符**：展开数组（Iterator接口对象）转为用逗号分隔的参数序列。仅用于<u>函数调用</u>和<u>数组中展开</u>。下面给出一些例子。

   ```javascript
   // 1. 数组浅拷贝
   const a1 = [1, 2];
   // 写法一
   const a2 = [...a1];
   // 写法二
   const [...a2] = a1;
   
   // 2. 合并数组
   [...arr1, ...arr2, ...arr3]
   
   // 3. 解构赋值
   const [first, ...tail] = [1, 2, 3, 4, 5];
   
   // 4. 分解 unicode 字符串
   str.split('').reverse().join('')
   // 'y\uDE80\uD83Dx'
   
   [...str].reverse().join('')
   // 'y\uD83D\uDE80x'
   ```

2. **`Array.from`方法**：用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象。

   - 类似数组的对象实现了`ArrayLike`接口

       ```typescript
       interface ArrayLike<T> {
           readonly length: number;
           readonly [n: number]: T;
       }
       ```

   - 可以接受第二个参数，作用类似于数组的`map`方法，用来对每个元素进行处理，将处理后的值放入返回的数组。
   
3. **`Array.of`方法**：用于将一组值，转换为数组。用于替换混乱的原有构造方法。

4. 实例方法**`find` `includes` 和 `findIndex`**：接受函数，返回遇到的第一个值或索引。

5. **实例方法`flat`和`flatMap`**

6. `sort()`的默认排序算法是<u>稳定</u>的



## 对象的扩展

1. **属性和方法的简洁表示法**：允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。

   ```javascript
   const foo = "foo";
   const o = {
     foo,
     method() {
       return "Hello!";
     }
   };
   ```

2. **属性名表达式**：用表达式作为属性名，这时要将表达式放在方括号之内。

   ```javascript
   let propKey = 'foo';
   let obj = {
     [propKey]: true,
     ['a' + 'bc']: 123
   };
   ```

   