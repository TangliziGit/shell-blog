# ES6 标准学习

> 大部分参考 [ECMAScript 6 入门](https://es6.ruanyifeng.com/#docs/intro)

注意 ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称

需要特别注意的特性：

1. `let`：存在**暂时性死区**
2. 解构赋值：注意对象也可以解构
3. 正则的具名组匹配



## 变量声明

> https://es6.ruanyifeng.com/#docs/let

- ES6 一共有 6 种声明变量的方法：`var`、`function`、`let`、`const`、`import`、`class`



### let 与 var

使用`let`替代`var`，这里讲`var`的特殊和差异之处。例子请看参考链接。

- `var`声明是**全局范围**的，并且可以**重复声明**。
- `var`命令会发生“**变量提升**”现象：变量可以在声明之前使用，值为`undefined`。
- `let`命令会存在一个**暂时性死区**的问题：只要块级作用域内存在`let`命令，它所声明的变量就“绑定”这个区域，不再受外部的影响。
  - 强行使用会`ReferenceError`。
  - 这样的设计是为了让大家养成良好的编程习惯，<u>变量一定要在声明之后使用，否则就报错。</u>

- `var`声明只有全局作用域和函数作用域，**没有块级作用域**。
  - 第一种场景，内层变量可能会覆盖外层变量。函数作用域优先变量提升，从而覆盖全局作用域。
  - 第二种场景，用来计数的循环变量泄露为全局变量。
  - 块级作用域的出现，实际上使得获得广泛应用的<u>匿名立即执行函数表达式</u>（匿名 IIFE）不再必要了。
  - ES6 规定，块级作用域之中，<u>函数声明语句的行为类似于`let`</u>，在块级作用域之外不可引用。

总结一下，`let`是作用于**块级作用域**上的**不可重复声明**的声明语句，但使用它降存在**暂时性死区**的问题



### const

`const`与`let`在三个方面上一样：**块级作用域**、**不可重复声明**、**暂时性死区**

但是注意：`const`保证的是变量指向的内存地址所保存的数据不得改动，即对于基本数据是不变的，对于对象则内容可变而它存储的指针不变。

如果真的想将**对象冻结**，应该使用`Object.freeze`方法。而且除了将对象本身冻结，对象的属性也应该冻结。



### 顶层对象

ES5 之中，顶层对象的属性与全局变量是等价的。顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。



#### 脱钩

ES6 为了改变这一点，一方面规定，为了保持兼容性，`var`命令和`function`命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，`let`命令、`const`命令、`class`命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。



#### 统一的顶层对象

JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。

[ES2020](https://github.com/tc39/proposal-global) 在语言标准的层面，引入`globalThis`作为顶层对象。也就是说，任何环境下，`globalThis`都是存在的，都可以从它拿到顶层对象，指向全局环境下的`this`。

垫片库[`global-this`](https://github.com/ungap/global-this)模拟了这个提案，可以在所有环境拿到`globalThis`。



## 解构赋值

- 解构赋值的规则是，只要等号右边的值不是对象或数组，就**先将其转为对象**。由于`undefined`和`null`无法转为对象，所以对它们进行解构赋值，都会报错。



### 数组的解构

以下是一些例子：

```javascript
let [foo, [[bar], baz]] = [1, [[2], 3]];
let [ , , third] = ["foo", "bar", "baz"];
let [x, , y] = [1, 2, 3];
let [head, ...tail] = [1, 2, 3, 4];
let [x, y, ...z] = ['a'];
// y === undefined
// z === []
```

- **解构失败值**是`undefined`；解构**支持不完全解构**`let [x, y] = [1, 2, 3];`

- 只要某种数据结构具有 **Iterator 接口**，都可以采用数组形式的解构赋值。如果不是，则报错。

  - Set 结构，也可以使用数组的解构赋值。
  - Generator 函数，原生具有 Iterator 接口。

- **默认值**：ES6 内部使用严格相等运算符（`===`），判断一个位置是否有值。所以，只有当一个数组成员严格等于`undefined`，默认值才会生效。同时如果默认值是一个表达式，那么这个**表达式是惰性求值**的

  ```javascript
  let [x = 1] = [undefined];
  x // 1
  
  let [x = 1] = [null];
  x // null
  ```

- 可以将一个已经声明的变量用于解构赋值。



### 对象的解构

```javascript
let { bar, foo } = { foo: 'aaa', bar: 'bbb' };
foo // "aaa"
bar // "bbb"

let { baz } = { foo: 'aaa', bar: 'bbb' };
baz // undefined

let { first: f, last: l } = { first: 'hello', last: 'world' };
f // 'hello'
l // 'world'

var {x: y = 3} = {x: 5};
y // 5
```

- **解构失败值**是`undefined`
- 解构可以给定替换的 key，如例3。**注意**被替换的是后者，而不是前者。就像声明一对kv一样，把它当作模式匹配。



**注意**：

- 如果要将一个已经声明的变量用于解构赋值：

  ```javascript
  let x;
  ({x} = {x: 1});
  ```



### 形参的解构

```javascript
const add = ([x, y]) => x + y;
```



### 用处

1. **快速提取 JSON 数据**
2. **函数参数的默认值**：避免了在函数体内部再写`var foo = config.foo || 'default foo';`这样的语句。
3. **遍历 Map 结构**：任何部署了 Iterator 接口的对象，都可以用`for...of`循环遍历。



## 字符串的扩展

1. **字符的 Unicode 表示法**：ES6 允许采用`\uxxxx`形式表示一个字符，其中`xxxx`表示字符的 Unicode 码点。

2. **字符串的遍历器接口**：除了遍历字符串，这个遍历器最大的优点是可以识别大于`0xFFFF`的码点，传统的`for`循环无法识别这样的码点。

3. **模板字符串**：可以用来定义多行字符串，或者在字符串中嵌入变量。

   - **标签模板**：它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。

     ```javascript
     alert`hello`
     // 等同于
     alert(['hello'])
     
     // 下面是一些应用，是自定义函数对标签模板进行处理：
     // 1. 过滤 HTML 字符串
     // 2. 多语言转换
     // 3. 嵌入其他语言
     ```



### 新增方法

1. `String.fromCharPoint()`：用于从 Unicode 码点返回对应字符，相比 ES5 它能识别码点大于`0xFFFF`的字符。

2. `String.raw()`：返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串。

3. **实例方法`codePointAt()`**：能够正确处理 4 个字节储存的字符，返回一个字符的码点。

   - JavaScript 内部，**字符以 UTF-16 的格式储存**。当遇到2个字节组成的字符时：

   - `charAt()`方法无法读取整个字符

   - `charCodeAt()`方法只能分别返回前两个字节和后两个字节的值。

   - `codePointAt()`方法返回一个字符的码点。**注意**：为了对齐字符串长度，当索引指向字符后半段时，返回值等于`charCodeAt()`

     ```javascript
     var s = "𠮷";
     
     s.length // 2
     s.charAt(0) // ''
     s.charAt(1) // ''
     s.charCodeAt(0) // 55362
     s.charCodeAt(1) // 57271
     s.codePointAt(0) // 134071
     s.codePointAt(1) // 57271
     s.codePointAt(0).toString(16) // "20bb7"
     ```

4. 实例方法`normalize()`：用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。

5. **实例方法`includes() startsWith() endsWith()`**

6. **实例方法`repeat()`**

7. **实例方法`padStart() padEnd()`**：引入了字符串补全长度的功能。

   ```javascript
   // 常见用途是为数值补全指定位数
   '1'.padStart(10, '0') // "0000000001"
   '12'.padStart(10, '0') // "0000000012"
   '123456'.padStart(10, '0') // "0000123456"
   
   // 另一个用途是提示字符串格式
   '12'.padStart(10, 'YYYY-MM-DD') // "YYYY-MM-12"
   '09-12'.padStart(10, 'YYYY-MM-DD') // "YYYY-09-12"
   ```

8. **实例方法`trimStart() trimEnd()`**
9. **实例方法`matchAll() replaceAll()`**



## 正则的扩展

> https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions



### 各种修饰符

ES6 为正则表达式新增了`flags`属性，会返回正则表达式的修饰符。

```javascript
// ES5 的 source 属性： 返回正则表达式的正文
/abc/ig.source
// "abc"

// ES6 的 flags 属性：返回正则表达式的修饰符
/abc/ig.flags
// 'gi'

/hello\d/y.sticky	// true
/hello/u.unicode	// true
```



1. **u修饰符**：含义为“Unicode 模式”，用来正确处理大于`\uFFFF`的 Unicode 字符。

2. **y修饰符**：首先`g`修饰符是从头开始向后搜索，直到发现匹配为止。而`y`修饰符则是从头开始，如果当前不匹配则返回`null`。这称为粘连模式。它需要与`g`修饰符连用，否则只会匹配第一个元素。

3. **s修饰符**：`dotAll`模式，即点（dot）代表一切字符。

   - 正则表达式中，点（`.`）是一个特殊字符，代表任意的单个字符，但是有两个例外；<br>一个是四个字节的 UTF-16 字符，这个可以用`u`修饰符解决；<br>另一个是行终止符：换行符、回车符、行分隔符、段分隔符
   ```javascript
   /foo.bar/s.test('foo\nbar') // true
   ```



### Unicode 属性类

允许正则表达式匹配符合 Unicode 某种属性的所有字符。

- Unicode 属性类要指定属性名和属性值。对于某些属性，可以只写属性名，或者只写属性值。
- `\P{…}`是`\p{…}`的反向匹配，即匹配不满足条件的字符。
- 这两种类只对 Unicode 有效，所以使用的时候一定要加上`u`修饰符。

```javascript
const regexGreekSymbol = /\p{Script=Greek}/u;
regexGreekSymbol.test('π') // true

const regex = /^\p{Decimal_Number}+$/u;
regex.test('𝟏𝟐𝟑𝟜𝟝𝟞𝟩𝟪𝟫𝟬𝟭𝟮𝟯𝟺𝟻𝟼') // true

// 匹配所有数字
const regex = /^\p{Number}+$/u;
regex.test('²³¹¼½¾') // true
regex.test('㉛㉜㉝') // true
regex.test('ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ') // true

// 匹配所有空格
\p{White_Space}
// 匹配各种文字的所有字母，等同于 Unicode 版的 \w
[\p{Alphabetic}\p{Mark}\p{Decimal_Number}\p{Connector_Punctuation}\p{Join_Control}]
// 匹配各种文字的所有非字母的字符，等同于 Unicode 版的 \W
[^\p{Alphabetic}\p{Mark}\p{Decimal_Number}\p{Connector_Punctuation}\p{Join_Control}]
// 匹配 Emoji
/\p{Emoji_Modifier_Base}\p{Emoji_Modifier}?|\p{Emoji_Presentation}|\p{Emoji}\uFE0F/gu

// 匹配所有的箭头字符
const regexArrows = /^\p{Block=Arrows}+$/u;
regexArrows.test('←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩') // true
```



### 具名组匹配

原有组匹配的使用方法：

```javascript
const RE_DATE = /(\d{4})-(\d{2})-(\d{2})/;

const matchObj = RE_DATE.exec('1999-12-31');
const year = matchObj[1]; // 1999
const month = matchObj[2]; // 12
const day = matchObj[3]; // 31
```

ES2018 引入了**具名组匹配**，允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。

“具名组匹配”在圆括号内部，模式的头部添加“**问号 + 尖括号 + 组名**”（`?<year>`），然后就可以在`exec`方法返回结果的`groups`属性上引用该组名。同时，数字序号（`matchObj[1]`）依然有效。

```javascript
const RE_DATE = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/;

const matchObj = RE_DATE.exec('1999-12-31');
const year = matchObj.groups.year; // "1999"
const month = matchObj.groups.month; // "12"
const day = matchObj.groups.day; // "31"
```



#### 解构赋值和替换

1. 有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。

    ```javascript
    let {groups: {one, two}} = /^(?<one>.*):(?<two>.*)$/u.exec('foo:bar');
    one  // foo
    two  // bar
    ```

2. 字符串替换时，使用`$<组名>`引用具名组。

    ```javascript
    let re = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/u;

    '2015-01-02'.replace(re, '$<day>/$<month>/$<year>')
    // '02/01/2015'
    ```

    上面代码中，`replace`方法的第二个参数是一个字符串，而不是正则表达式。

    `replace`方法的第二个参数也可以是函数，该函数的参数序列如下。

    ```javascript
    '2015-01-02'.replace(re, (
       matched, // 整个匹配结果 2015-01-02
       capture1, // 第一个组匹配 2015
       capture2, // 第二个组匹配 01
       capture3, // 第三个组匹配 02
       position, // 匹配开始的位置 0
       S, // 原字符串 2015-01-02
       groups // 具名组构成的一个对象 {year, month, day}
     ) => {
     let {day, month, year} = groups;
     return `${day}/${month}/${year}`;
    });
    ```

    具名组匹配在原来的基础上，新增了最后一个函数参数：具名组构成的一个对象。函数内部可以直接对这个对象进行解构赋值。



#### 引用

如果要在正则表达式内部引用某个“具名组匹配”，可以使用`\k<组名>`的写法。

```javascript
const RE_TWICE = /^(?<word>[a-z]+)!\k<word>$/;
RE_TWICE.test('abc!abc') // true
RE_TWICE.test('abc!ab') // false
```

数字引用（`\1`）依然有效。

```javascript
const RE_TWICE = /^(?<word>[a-z]+)!\1$/;
RE_TWICE.test('abc!abc') // true
RE_TWICE.test('abc!ab') // false
```

这两种引用语法还可以同时使用。

```javascript
const RE_TWICE = /^(?<word>[a-z]+)!\k<word>!\1$/;
RE_TWICE.test('abc!abc!abc') // true
RE_TWICE.test('abc!abc!ab') // false
```



### 其他

1. 支持后行断言：

   ```javascript
   // 先行断言
   /\d+(?=%)/.exec('100% of US presidents have been male');  // ["100"]
   /\d+(?!%)/.exec('that’s all 44 of them');                 // ["44"]
   
   // 后行断言
   /(?<=\$)\d+/.exec('Benjamin Franklin is on the $100 bill');  // ["100"]
   /(?<!\$)\d+/.exec('it’s is worth about €90');                // ["90"]
   ```

2. `matchAll`

   - 原有正则匹配全局应使用`g`，并用循环取得结果`while (match = regex.exec(string))`

   - [ES2020](https://github.com/tc39/proposal-string-matchall) 增加了`String.prototype.matchAll()`方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。

     ```javascript
     const string = 'test1test2test3';
     const regex = /t(e)(st(\d?))/g;
     
     for (const match of string.matchAll(regex)) {
       console.log(match);
     }
     // ["test1", "e", "st1", "1", index: 0, input: "test1test2test3"]
     // ["test2", "e", "st2", "2", index: 5, input: "test1test2test3"]
     // ["test3", "e", "st3", "3", index: 10, input: "test1test2test3"]
     
     // 转为数组的方法一
     [...string.matchAll(regex)]
     
     // 转为数组的方法二
     Array.from(string.matchAll(regex))
     ```



## 数值的扩展

此处内容大多用不到，故简写。

1. **指数运算符（`**`）**
2. **BigInt**：BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。字面量必须添加后缀`n`。



## 函数的扩展

1. **默认参数**：默认参数<u>惰性求值</u>；还可与解构赋值搭配；函数的`length`属性返回没有指定默认值的参数个数
2.  **rest 参数**：获取函数的多余参数，例：`function add(...xs)`。同时它只能是最后一个参数。
3. **name 属性**：返回该函数的函数名。注意匿名函数则返回对应的变量名。
4. **尾调用优化（调用栈复用）**：尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。ES6 的尾调用优化只在严格模式下开启。
5. **catch语句参数省略**：很多时候，`catch`代码块可能用不到这个报错参数。



### 箭头函数

1. 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。
2. 箭头函数可以与变量解构结合使用。
3. 如果函数体很复杂，有许多行，或者函数内部有大量的读写操作，不单纯是为了计算值，这时也不应该使用箭头函数，而是要使用普通函数，这样可以提高代码可读性。



**注意**：

箭头函数里面根本没有自己的`this`，而是**引用外层<u>代码块</u>的`this`**。箭头函数让`this`指向固定化，从动态变为静态。

- （在 JavaScript 中，函数是对象的方法。如果一个函数不是 JavaScript 对象的方法，那么它就是全局对象的函数。`call`方法是指函数作用与某个指定对象上。）

- 所以，箭头函数转成 ES5 的代码如下。

  ```javascript
  // ES6
  function foo() {
    setTimeout(() => {
      console.log('id:', this.id);
    }, 100);
  }
  
  // ES5
  function foo() {
    var _this = this;
  
    setTimeout(function () {
      console.log('id:', _this.id);
    }, 100);
  }
  ```



这导致了：

1. **不可以当作构造函数**，也就是说，不可以使用`new`命令，否则会抛出一个错误。
2. 不可以使用`arguments`对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。
3. 不可以使用`yield`命令，因此箭头函数不能用作 Generator 函数。



## 数组的扩展

1. **展开运算符**：展开数组（Iterator接口对象）转为用逗号分隔的参数序列。仅用于<u>函数调用</u>和<u>数组中展开</u>。下面给出一些例子。

   ```javascript
   // 1. 数组浅拷贝
   const a1 = [1, 2];
   // 写法一
   const a2 = [...a1];
   // 写法二
   const [...a2] = a1;
   
   // 2. 合并数组
   [...arr1, ...arr2, ...arr3]
   
   // 3. 解构赋值
   const [first, ...tail] = [1, 2, 3, 4, 5];
   
   // 4. 分解 unicode 字符串
   str.split('').reverse().join('')
   // 'y\uDE80\uD83Dx'
   
   [...str].reverse().join('')
   // 'y\uD83D\uDE80x'
   ```

2. **`Array.from`方法**：用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象。

   - 类似数组的对象实现了`ArrayLike`接口

       ```typescript
       interface ArrayLike<T> {
           readonly length: number;
           readonly [n: number]: T;
       }
       ```

   - 可以接受第二个参数，作用类似于数组的`map`方法，用来对每个元素进行处理，将处理后的值放入返回的数组。
   
3. **`Array.of`方法**：用于将一组值，转换为数组。用于替换混乱的原有构造方法。

4. 实例方法**`find`  和 `findIndex`**：接受函数，返回遇到的第一个值或索引。

5. **实例方法`flat`和`flatMap`**

6. `sort()`的默认排序算法是<u>稳定</u>的

7. 实例方法`fill`

8. 实例方法`entries` `keys` `values`：返回Iterator对象



## 对象的扩展

1. **属性和方法的简洁表示法**：允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。

   ```javascript
   const foo = "foo";
   const o = {
     foo,
     method() {
       return "Hello!";
     }
   };
   ```

2. **属性名表达式**：用表达式作为属性名，这时要将表达式放在方括号之内。

   ```javascript
   let propKey = 'foo';
   let obj = {
     [propKey]: true,
     ['a' + 'bc']: 123
   };
   ```



### 复习对象

#### 构造函数

为了提供一个便捷的构造方法，使用`this`和`new`并不设置返回值：

```javascript
function Person(name) {
  this.name = name;
  this.greeting = function() {
    alert('Hi! I\'m ' + this.name + '.');
  };
}

const p = new Person("foo");
```



##### 其他方式

1. 还可以将对象文本传递给**Object()** 构造函数作为参数， 以便用属性/方法填充它。请尝试以下操作：  

    ```javascript
    var person1 = new Object({
      name : 'Chris',
      age : 38,
      greeting : function() {
        alert('Hi! I\'m ' + this.name + '.');
      }
    });
    ```

2. JavaScript有个内嵌的方法`create()`, 它允许您基于原型链对现有对象创建新的对象。  

   ```javascript
   var person2 = Object.create(person1);
   person2.__proto__ === person1
   ```



#### 原型链

1. **原型**：每个对象拥有一个**原型对象**，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。

2. **原型链**：这种关系常被称为**原型链 (prototype chain)**，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。

3. 每个实例访问属性的过程，类似与<u>自动解引用</u>。

   

##### 举例

```javascript
// 除了箭头函数以外，都可以作为构造函数
let Cons = function(){};
let Ins = new doSomething()

console.assert( Ins.__proto__ === Cons.prototype )
console.assert( Ins.__proto__.proto === Object.prototype )
console.assert( Cons.__proto__ === Function.prototype )
```

![prototype_chain](/static/image/2021-01-16/prototype_chain.png)

- **构造函数**：拥有`prototype`和`__proto__`
- **原型**：拥有`__proto__`、`constructor`和<u>自定义的属性</u>；但注意`Object.prototype.__proto`为`null`
- **实例**：拥有`__proto__`



**注意**

- 在构造函数中对`this`添加属性时，它会随着`new`而出现在实例对象的属性上。**所以它不在原型链上，不被继承。**

- 在构造函数的原型上添加属性时，它会被添加在原型上，在实例访问时“自动解引用”。

  ```javascript
  function Person() {
    this.name = 'Chris';
    this.age = 38;
    this.greeting = function() {
      alert('Hi! I\'m ' + this.name + '.');
    };
  }
  
  Person.prototype.hello = function() {
    console.log("hello");
  }
  
  console.log(new Person())
  // {
  //   age: 38,
  //   greeting: function greeting(),
  //   name: "Chris",
  //   __proto__: {
  //     hello: hello(),
  //     ...
  //   },
  // }
  ```

  

#### 原型链继承 / 委托

- `this`对应的属性，只有当`new`语句作用时，才生成出来作为**实例的属性**。

- **原型链继承的步骤**
  1. 构造函数中使用父类的构造函数，作用于当前的`this`
  2. 子类的原型关联父类的原型，使用`Object.create()`
  3. 设置子类原型的构造函数

```javascript
// Person
function Person(first, last, age, gender, interests) {
  this.name = { first, last };
  this.age = age;
  this.gender = gender;
  this.interests = interests;
}

Person.prototype.greeting = function() {
  alert('Hi! I\'m ' + this.name.first + '.');
};


// Teacher
function Teacher(first, last, age, gender, interests, subject) {
  // 1. call 指明了在运行这个函数时想对“this”指定的值 
  Person.call(this, first, last, age, gender, interests);

  this.subject = subject;
}

// 2. 关联原型，并且设置构造函数
Teacher.prototype = Object.create(Person.prototype);
Teacher.prototype.constructor = Teacher;
```





### 对象的可枚举性

对象的每个属性都有一个**描述对象**（Descriptor），用来控制该属性的行为。`Object.getOwnPropertyDescriptor`方法可以获取该属性的描述对象。

```javascript
let obj = { foo: 123 };
Object.getOwnPropertyDescriptor(obj, 'foo')
//  {
//    value: 123,
//    writable: true,
//    enumerable: true,
//    configurable: true
//  }
```

描述对象的`enumerable`属性，称为“可枚举性”，如果该属性为`false`，就表示某些操作会忽略当前属性。

目前，有四个操作会忽略`enumerable`为`false`的属性。

- `for...in`循环：只遍历对象自身的和继承的可枚举的属性。
- `Object.keys()`：返回对象自身的所有可枚举的属性的键名。
- `JSON.stringify()`：只串行化对象自身的可枚举的属性。
- `Object.assign()`： 忽略`enumerable`为`false`的属性，只拷贝对象自身的可枚举的属性。

其中，只有`for...in`会返回继承的属性，其他三个方法都会忽略继承的属性，只处理对象自身的属性。



### 其他

- `super`关键字：`super === this.__proto__`或者`super === Object.getPrototype(this)`

- **展开运算符的解构赋值**：注意，**解构赋值的拷贝是浅拷贝**

  ```javascript
  let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
  x // 1
  y // 2
  z // { a: 3, b: 4 }
  ```

- **链判断运算符**：判断左侧的对象是否为`null`或`undefined`。是则返回`undefined`。

  - 链判断运算符有三种用法:`obj?.prop`、`obj?.[expr]`、`func?.(...args)` 

  ```javascript
  const firstName = message?.body?.user?.firstName || 'default';
  const fooValue = myForm.querySelector('input[name=foo]')?.value
  const result = it.func?.()
  ```

- **Null 判断运算符**：

  - 读取对象属性的时候，如果某个属性的值是`null`或`undefined`，有时候需要为它们指定默认值。常见做法是通过`||`运算符指定默认值。<u>但是属性的值如果为空字符串或`false`或`0`，默认值也会生效。</u>

  - [ES2020](https://github.com/tc39/proposal-nullish-coalescing) 引入了一个新的 Null 判断运算符`??`。它的行为类似`||`，但是只有运算符左侧的值为`null`或`undefined`时，才会返回右侧的值。

    ```javascript
    const headerText = response.settings.headerText ?? 'Hello, world!';
    ```



## Symbol

ES6 引入了一种新的原始数据类型`Symbol`，表示**独一无二**的值。凡是对象的属性名属于 Symbol 类型，就可以保证不会与其他属性名产生冲突。

（它是 JavaScript 语言的第七种数据类型，前六种是：`undefined`、`null`、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。）

- **描述**：`Symbol`函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述`sym.description`。不管提供不提供描述，`Symbol`之间都是不相等的。

  - 如果 Symbol 的参数是一个对象，就会调用该对象的`toString`方法作为描述，然后才生成一个 Symbol 值。

- **登记机制**：`Symbol.for()`会生成新的 Symbol，同时会查找被登记在全局环境中的`Symbol`。`Symbol.keyFor()`方法返回一个已登记的 Symbol 类型值的`key`。

- **对象属性的用途**：下面给出一些用途。

  - 独一无二的属性名，能保证不会出现同名的属性，防止改写或覆盖。

  - 定义非私有的、但又希望只用于内部的方法：

    ```javascript
    let size = Symbol('size');
    
    class Collection {
      constructor() {
        this[size] = 0;
      }
    
      add(item) {
        this[this[size]] = item;
        this[size]++;
      }
    
      static sizeOf(instance) {
        return instance[size];
      }
    }
    
    let x = new Collection();
    Collection.sizeOf(x) // 0
    
    x.add('foo');
    Collection.sizeOf(x) // 1
    
    Object.keys(x) // ['0']
    Object.getOwnPropertyNames(x) // ['0']
    Object.getOwnPropertySymbols(x) // [Symbol(size)]
    ```
  
- **内置方法**：ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法。

  - `Symbol.hasInstance`：当其他对象使用`instanceof`运算符，判断是否为该对象的实例时，会调用这个方法。注意提供此方法时使用`static`。

  - `Symbol.species`：实例对象在运行过程中，需要再次调用自身的构造函数时，使用它就可以调用该属性指定的构造函数。

    ```javascript
    class MyArray extends Array {
      static get [Symbol.species]() { return Array; }
    }
    
    const a = new MyArray();
    const b = a.map(x => x);
    
    b instanceof MyArray // false
    b instanceof Array // true
    ```
    
  - `Symbol.match`、`Symbol.replace`、`Symbol.search`、`Symbol.split`：表示使用对应的字符串实例方法时，调用这些属性的方法。
  
  - `Symbol.iterator`：该对象的默认遍历器方法。
  
  - `Symbol.toPrimitive`：该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。
  
  - `Symbol.toStringTag`：用来定制`[object Object]`或`[object Array]`中`object`后面的那个字符串。



## 数据结构的扩展



### Set

- `Set`函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。
- Set 内部判断两个值是否不同，使用的算法叫做“**Same-value-zero** equality”，它类似于精确相等运算符（`===`），主要的区别是向 Set 加入值时认为`NaN`等于自身，而精确相等运算符认为`NaN`不等于自身。



### WeakSet

- WeakSet 的成员只能是对象，而不能是其他类型的值。
- WeakSet 中的对象都是弱引用，都不计入垃圾回收机制。如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。常用于弱相关的对象间，比如仅当A对象存在时，才会访问B对象。如果删除实例，它们也就随之消失，不会造成内存泄漏。



### Map

Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应。

- 作为构造函数，Map 也可以接受一个数组（不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构）作为参数。该数组的成员是一个个表示键值对的数组。

- Map 的转换

  ```javascript
  // Map 转为对象
  function strMapToObj(strMap) {
    let obj = Object.create(null);
    for (let [k,v] of strMap) {
      obj[k] = v;
    }
    return obj;
  }
  
  const myMap = new Map()
    .set('yes', true)
    .set('no', false);
  strMapToObj(myMap)
  // { yes: true, no: false }
  
  // ---
  // 对象转为 Map
  let obj = {"a":1, "b":2};
  let map = new Map(Object.entries(obj));
  
  // ---
  // Map 转为 JSON
  function strMapToJson(strMap) {
    return JSON.stringify(strMapToObj(strMap));
  }
  function mapToArrayJson(map) {
    return JSON.stringify([...map]);
  }
  ```



### WeakMap

- `WeakMap`只接受对象作为键名
- `WeakMap`的键名所指向的对象，不计入垃圾回收机制。常用于弱相关的对象间，比如仅当A对象存在时，才会访问B对象。如果删除实例，它们也就随之消失，不会造成内存泄漏。



## Proxy & Reflect



### Proxy

Proxy 即代理模式，在方法外层进行拦截。Proxy 实际上重载了点运算符，即用自己的定义覆盖了语言的原始定义。

下面是一个例子：

```javascript
var proxy = new Proxy({}, {
  get: function(target, propKey) {
    return 35;
  }
});

proxy.time // 35
proxy.name // 35
proxy.title // 35
```

-  Proxy 支持的拦截操作一览，一共 13 种。[参考](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy)
- **场景**：
  - 实现数据库的 ORM 层
  - 观察者模式
  - 数据的双向绑定：先前使用`Object.defineProporty`递归重写对象的属性的`set`和`get`方法；现在使用`Proxy`能捕获更多的操作。



### Reflect

`Reflect`对象与`Proxy`对象一样，也是 ES6 为了操作对象而提供的新 API。

`Reflect`对象的设计目的有这样几个：

- 将`Object`对象的一些明显属于语言内部的方法，放到`Reflect`对象上。
- 修改某些`Object`方法的返回结果，让其变得更合理。
-  让`Object`的某些语法上的操作都变成函数行为。
- `Reflect`对象的方法与`Proxy`对象的方法一一对应。

`Reflect`对象一共有 13 个静态方法，事实上与 Proxy 的内置方法的意味相同。



## Promise

Promise 是<u>异步编程的一种解决方案</u>，比传统的解决方案：回调函数、事件驱动，更合理和更强大。

- **对象的状态不受外界影响**。`Promise`对象代表一个异步操作，有三种状态：`pending`（进行中）、`fulfilled`（已成功）和`rejected`（已失败）。
- **一旦状态改变，就不会再变**，任何时候都可以再得到这个结果。这时就称为 resolved（已定型）。
- 缺陷：
  - 无法中途取消`Promise`。
  - 处于`pending`状态时，无法得知目前进展到哪一个阶段。
- **注意**：`Promise.then`是一个微任务。详见<https://fourstacks.codes/node/>



### Monad

> https://zhuanlan.zhihu.com/p/260966706

这里提一下 Monad，它是有一个函数`flatMap`构成的一种类型。`flatMap`的函数签名是`M a -> (a -> M b) -> M b`。

不难发现 Promise 的 `then`函数是一个 `flatMap`，所以 Promise 是一个 Monad。关于 Monad 的作用：

- Monad 主要的作用是消除 IO 的副作用，将 IO 的影响控制在 Monad 的范围内。
  - 比如读用户输入的操作，`getLine`返回的是一个 IO Monad。开发者只能使用`flatMap`对内容字符串进行操作，同时只能返回另一个 Monad。将动作隔离在Monad的世界里，这样就不会将副作用带出来了。
- 另一个作用是使用 Monad 将会少写很多逻辑判断语句。此处考虑 Go 语言处理错误的情景，同时对比 Rust 和 Haskell 的同样写法。



同时注意，由于 `Promise.prototype.then` 是一个`flatMap`，所以一定要注意它接收的函数的签名`a -> M b`和返回值`M b`。同时，它接受的函数的签名却是`a -> b`，看来`then`底层封装了包括报错在内的方法。



### 基本用法

```javascript
promise
.then(result => {···})
.catch(error => {···})
.finally(() => {···});
```

```javascript
const promise = new Promise(function(resolve, reject) {
  // ... some code

  if (/* 成功 */){
    resolve(value);
  } else {
    reject(error);
  }
});


promise.then(function(value) {
  // success
}, function(error) {
  // failure
});


const p2 = new Promise(function (resolve, reject) {
  setTimeout(() => resolve(p1), 1000)
})

p2
  .then(result => console.log(result))
  .catch(error => console.log(error))
```

**注意**：

- **构造函数接受的函数**：
  - `resolve`和`reject`函数，不要写丢。
  - 调用`resolve`或`reject`并不会终结 Promise 的参数函数的执行。
- **错误处理**：
  - 在构造函数接受的函数中，报错可以通过`reject`也可以通过`throw`。
  - Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个`catch`语句捕获。
- **`then`方法接受的函数**：是一个`a -> b`的函数，而不是`a -> M b`的函数。它的实现上考虑了报错的问题。



### 新增方法

- **`Promise.prototype.finally()`**：指定不管 Promise 对象最后状态如何，都会执行的操作。注意它接受的函数没有参数。

- 多个 Promise 包装成一个 Promise 的方法：

  - `all`：相当于**and**。

    - 当数组中的状态都变成`fulfilled`，总的结果才会变成`fulfilled`
    - 当其中有一个被`rejected`，结果的状态就变成`rejected`。

  - `any`：相当于**or**。

  - `race`：返回率先改变状态的 Promise。相当于**短路操作**。

    - 下面是一个例子，如果指定时间内没有获得结果，则`reject`

      ```javascript
      const p = Promise.race([
        fetch('/resource-that-may-take-a-while'),
        new Promise(function (resolve, reject) {
          setTimeout(() => reject(new Error('request timeout')), 5000)
        })
      ]);
      
      p
      .then(console.log)
      .catch(console.error);
      ```

  - `allSettled`：等到所有这些参数实例都返回结果，固定返回`fulfilled`。相当于**非短路操作**。

- **`Promise.try`**：用 Promise 来处理同步函数和异步操作。

  - 用统一的接口来处理同步和异步，目的是提供了良好的错误捕获、可交互性和可读性。
  - 见<http://cryto.net/~joepie91/blog/2016/05/11/what-is-promise-try-and-why-does-it-matter/>
  
  
  
  

### 关于 Stream

如果某些事件不断地反复发生，一般来说，使用 [Stream](https://nodejs.org/api/stream.html) 模式是比部署`Promise`更好的选择。

JS 中的异步主要体现在 IO 的异步上。同样可以处理 IO 的方法之一是使用 Stream。它具有两种特点：

- **事件驱动**：你可以在 IO 的过程中添加一些事件回调函数，用来得知进展或处理错误。

  ```javascript
  var readerStream = fs.createReadStream('input.txt');
  readerStream.setEncoding('UTF8');
  
  readerStream.on('data', function(chunk) {
     data += chunk;
  });
  
  readerStream.on('end',function(){
     console.log(data);
  });
  
  readerStream.on('error', function(err){
     console.log(err.stack);
  });
  ```

  

- **管道**：用于从一个流中获取数据并将数据传递到另外一个流中。

  ```javascript
  fs.createReadStream('input.txt')
    .pipe(zlib.createGzip())
    .pipe(fs.createWriteStream('input.txt.gz'));
  ```



#### 流的类型

流可以是可读的、可写的、或者可读可写的。 所有的流都是 [`EventEmitter`](http://nodejs.cn/api/events.html#events_class_eventemitter) 的实例。

Node.js 中有四种基本的流类型：

- [`Writable`](http://nodejs.cn/api/stream.html#stream_class_stream_writable) - 可写入数据的流（例如 [`fs.createWriteStream()`](http://nodejs.cn/api/fs.html#fs_fs_createwritestream_path_options)）。
- [`Readable`](http://nodejs.cn/api/stream.html#stream_class_stream_readable) - 可读取数据的流（例如 [`fs.createReadStream()`](http://nodejs.cn/api/fs.html#fs_fs_createreadstream_path_options)）。
- [`Duplex`](http://nodejs.cn/api/stream.html#stream_class_stream_duplex) - 可读又可写的流（例如 [`net.Socket`](http://nodejs.cn/api/net.html#net_class_net_socket)）。
- [`Transform`](http://nodejs.cn/api/stream.html#stream_class_stream_transform) - 在读写过程中可以修改或转换数据的 `Duplex` 流（例如 [`zlib.createDeflate()`](http://nodejs.cn/api/zlib.html#zlib_zlib_createdeflate_options)）。



## Iterator 接口

Iterator 接口的作用有三个：

- 为各种数据结构，提供一个统一的、简便的**访问接口**
- 使得数据结构的成员能够按某种**次序排列**
- ES6 创造了一种新的遍历命令`for...of`循环，Iterator 接口主要供`for...of`消费。

**使用场景**：

1. 解构赋值
2. 展开运算符
3. `yield*`
4. `for ... of`
5. `entries()`、`keys()`、`values()`
6. 其他调用 Iterator 的函数



### 实现

在 TS 中：

```typescript
interface Iterable {
  [Symbol.iterator]() : Iterator,
}

interface Iterator {
  next(value?: any) : IterationResult,
}

interface IterationResult {
  value: any,
  done: boolean,
}
```

在 JS 中：

```javascript
// 使用 Symbol.iterator 来声明
const obj = {
  [Symbol.iterator] : function () {
    return {
      next: function () {
        return {
          value: 1,
          done: true
        };
      }
    };
  }
};

// 使用 Generator
let myIterable = {
  [Symbol.iterator]: function* () {
    yield 1;
    yield 2;
    yield 3;
  }
};

// 或者采用下面的简洁写法
let obj = {
  * [Symbol.iterator]() {
    yield 'hello';
    yield 'world';
  }
};

// return()
function readLinesSync(file) {
  return {
    [Symbol.iterator]() {
      return {
        next() {
          return { done: false };
        },
        return() {
          file.close();
            // 必须返回一个对象，这是 Generator 语法决定的。
          return { done: true };
        }
      };
    },
  };
}

```

**注意**：

- Iterator 对象还可以具有`return()`方法和`throw()`方法。
  - `return()`方法的使用场合是，如果`for...of`循环提前退出，就会调用`return()`方法。它必须返回一个对象，这是 Generator 语法决定的。
  - `throw()`方法主要是配合 Generator 函数使用。