<!-- vim-markdown-toc GitLab -->

* [区块链技术实践 - Hyperledger Fabric 2 原理](#区块链技术实践-hyperledger-fabric-2-原理)
    * [简介](#简介)
    * [Fabric 架构](#fabric-架构)
    * [Fabric 核心组件](#fabric-核心组件)
        * [Network](#network)
        * [节点](#节点)
        * [共识](#共识)
        * [Ledger - 账本](#ledger-账本)
        * [Chaincode - 链码](#chaincode-链码)
    * [Fabric 交易流程](#fabric-交易流程)
    * [身份与PKI](#身份与pki)
    * [成员服务提供者](#成员服务提供者)
        * [本地MSP](#本地msp)
        * [通道MSP](#通道msp)
        * [组织](#组织)
        * [Organizational Units](#organizational-units)
        * [NodeOU](#nodeou)
    * [策略](#策略)
        * [实现方式](#实现方式)
        * [策略类型](#策略类型)
        * [策略定义的细节](#策略定义的细节)
        * [Fabric链码生命周期](#fabric链码生命周期)
    * [节点](#节点-1)
        * [节点与账本](#节点与账本)
        * [节点与应用程序](#节点与应用程序)
        * [节点与通道](#节点与通道)
        * [节点与组织](#节点与组织)
        * [节点与身份](#节点与身份)
        * [节点与排序服务与共识](#节点与排序服务与共识)
            * [第一阶段：提案](#第一阶段提案)
            * [第二阶段：排序和打包](#第二阶段排序和打包)
            * [第三阶段：验证和提交](#第三阶段验证和提交)
    * [账本](#账本)
        * [世界状态](#世界状态)
        * [区块链](#区块链)
        * [区块](#区块)
        * [交易](#交易)
        * [世界状态数据库选项](#世界状态数据库选项)
        * [命名空间](#命名空间)
        * [通道](#通道)
        * [更多信息](#更多信息)
    * [排序服务](#排序服务)
        * [排序节点与通道配置](#排序节点与通道配置)
        * [排序节点和交易流程](#排序节点和交易流程)
            * [阶段一：提案](#阶段一提案)
            * [阶段二：将交易排序并打包到区块中](#阶段二将交易排序并打包到区块中)
            * [阶段三：验证和提交](#阶段三验证和提交)
        * [排序服务实现](#排序服务实现)
        * [Raft](#raft)
            * [Raft 概念](#raft-概念)
            * [交易流程中的 Raft](#交易流程中的-raft)
        * [Raft 简介](#raft-简介)
            * [Raft 是如何选举领导者的](#raft-是如何选举领导者的)
            * [快照](#快照)
        * [更多信息](#更多信息-1)
    * [智能合约与链码](#智能合约与链码)
        * [背书](#背书)
        * [有效交易](#有效交易)
        * [通道](#通道-1)
        * [互通](#互通)
        * [系统链码](#系统链码)
        * [更多信息](#更多信息-2)
    * [链码生存周期](#链码生存周期)
        * [安装与定义流程](#安装与定义流程)
            * [第一步：打包](#第一步打包)
            * [第二步：安装](#第二步安装)
            * [第三步：批准](#第三步批准)
            * [第四步：提交链码定义给通道](#第四步提交链码定义给通道)
        * [升级链码流程](#升级链码流程)
        * [其他部署方案的流程](#其他部署方案的流程)
            * [新组织加入频道](#新组织加入频道)
            * [更新背书政策](#更新背书政策)
            * [批准定义而不安装链码的情况](#批准定义而不安装链码的情况)
            * [某组织不批准链码定义的情况](#某组织不批准链码定义的情况)
            * [链码定义未通过批准策略的情况](#链码定义未通过批准策略的情况)
            * [组织安装不同的链码包ID的情况](#组织安装不同的链码包id的情况)
            * [使用一个包创建多个链码的情况](#使用一个包创建多个链码的情况)
    * [私有数据](#私有数据)
    * [通道功能 Capabilities](#通道功能-capabilities)
        * [节点版本与功能版本](#节点版本与功能版本)

<!-- vim-markdown-toc -->

# 区块链技术实践 - Hyperledger Fabric 2 原理

> https://hyperledger-fabric.readthedocs.io/



## 简介

Hyperledger Fabric 是 Hyperledger 中的区块链项目之一。与其他区块链技术一样，它有一个账本，使用智能合约，是一个参与者管理交易的系统。

在功能上，其不同点有：

1. 提供多种可插拔选项

   有多种账本**数据格式存储**（LevelDB、CouchDB），**共识机制**可以交换替换（SOLO开发用、Kafka、Raft），并且支持**不同的MSP**。

2. **授权**提供安全性

   与公链不同，网络的成员需要从可信赖的 **成员服务提供者（MSP）** 注册。

3. 创建**通道**保护隐私

   允许一组参与者创建各自的交易账本，只有同一个通道的参与者才能查看数据，它提供了一种竞争者间保护隐私的方法。



## Fabric 架构

> https://learnblockchain.cn/books/enterprise/chapter3_03%20hyperledger_fabric_architecture.html

Fabric分为四大模块，分别是成员服务、区块链服务、智能合约和应用编程接口。



**成员服务**

- 成员服务（MSP）主要提供证书发布、验证及相关加密机制和协议。内置了Fabric CA证书颁发机构。
- Fabric CA提供客户端和SDK两种方式与CA进行交互，每个Fabric CA都有一个根CA或者中间CA。
- 为了便于证书管理，一般使用根证书、业务证书、用户证书三级证书结构。他们的关系是上级签发下级，呈树状。
- 业务证书又包含三种互相平行的证书：身份认证证书、交易签名证书、安全通讯证书。



**区块链服务**

1. **P2P协议**
   - Fabric网络中，节点Peer和排序服务Orderer采用gRPC对外提供远程服务，供客户端进行调用。
   - 节点之间通过 Gossip 协议来进行状态同步和分发。

2. **共识机制**
   - 交易必须按照发生的顺序写入**到分布式账本中。为此必须采用一种共识机制拒绝错误（或恶意）的交易数据，保证交易的顺序。
   - Fabric允许根据实际业务需要选择合适的共识机制，目前支持SOLO、Kafka、Raft三种共识机制。

3. **分布式账本**
   - 分布式账本包括两个组件：世界状态、事务日志，分布式账本是世界状态数据库和事务日志历史记录的组合。
   - **世界状态**（world state）组件记录的是最新的分布式账本状态，**事务日志**组件记录的是世界状态的更新历史。



**智能合约服务** 

- 智能合约服务用于保证智能合约在网络节点上安全运行。

- 是一组运行在验证节点上的去中心化交易程序。
- 在Fabric中被称为链码（chaincode），由外部应用程序（比如网页、APP）与分布式账本进行交互。
- 使用Docker存放链上的代码（而不需要依靠特定的虚拟机），Docker为链码执行提供了一个安全、轻便的语言执行环境。



**应用编程接口** 

- 应用编程接口提供SDK（开发工具包）和CLI（命令行）两种方式供开发人员使用区块链的各种服务。
- 主要是对分布式账本进行查询、更新。



## Fabric 核心组件

> https://learnblockchain.cn/books/enterprise/chapter3_04%20hyperledger_fabric_core_components.html



### Network

> 在Fabric网络中，Peer和Orderer采用gRPC对外提供远程服务，供客户端进行调用。
>
> 节点之间通过Gossip 协议来进行状态同步和分发。 

Gossip 协议是P2P 领域的常见协议，用于进行网络内多个节点之间的数据分发或信息交换。由于其设计简单，容易实现，同时容错性比较高，而被广泛应用到了许多分布式系。

Gossip  协议的基本思想十分简单，数据发送方从网络中随机选取若干节点，将数据发送过去，接收方重复这一过程（往往只选择发送方之外节点进行传播）。这一过程持续下去，网络中所有节点最终（时间复杂度为节点总个数的对数）都会达到一致。数据传输的方向可以是发送方发送或获取方拉取。



### 节点

> [PKI/CA工作原理及架构](https://www.jianshu.com/p/c65fa3af1c01)

**服务节点类型**

​	对网络中节点角色进行解耦是Fabric 设计中的一大创新，这也是联盟链场景下的特殊需求和环境所决定。

- **背书节点**（ Endorser ）

  负责对交易的<u>提案</u>（ proposal ）进行验证并模拟交易执行；

- **提交节点**（ Committer ）

  负责在接受交易结果前再次检查合法性，接受合法交易对账本的修改，并写入区块链结构；

- **排序节点**（ Orderer ）

  对所有发往网络中的交易进行排序，将排序后的交易按照配置中的约定整理为区块，之后提交给确认节点进行处理；

- **证书节点**（ CA ）

  负责对网络中所有的证书进行管理，提供标准的**PKI服务**。



注意：

1. 除了用户节点，网络所有的全节点都具备Commiter功能，部分节点具有Endorser、Orderer功能。
2. **锚节点**是一种外部可发现的节点，配置了对外服务的端口。可以被Orderer节点和其它任何节点发现。
3. 证书节点是一个相对独立证书管理机构，也可以由第三方证书机构来承担这个角色。



### 共识

广义的共识机制包含背书、排序和验证三个环节，狭义的共识指的是排序。



**背书**

- 就是相关组织对交易的认可，在Fabric中是相关节点对交易进行签名。
- 交易验证由网络中业务相关方进行。
- 对于一个链码交易来说，背书策略是在链码实例化的时候指定的；一笔有效交易必须是背书策略相关组织签名后才能生效。



**排序服务**

- 通常由排序节点来提供，用来对全网交易达成一致顺序。
- 排序服务只负责对交易顺序达成一致，这就有效避免了整个网络瓶颈，而且排序节点也很容易横向扩展，以提高整个网络的效率。
- 排序服务目前支持Kafka（v2弃用）和Raft（非拜占庭的共识机制）两种，可插拔架构也允许根据业务需要设计符合拜占庭的共识机制（如实用拜占庭）。



**验证**

- 是对排序后的交易提交到账本之前最终的检查。
- 检查的内容包含交易**结构的合法性**、**交易背书签名**是否符合背书策略等



### Ledger - 账本

区块是一组排序后的交易集合，将区块通过密码算法连接起来就是区块链。

在Fabric中交易可以存储相关业务信息。

账本包含状态数据库和历史数据库：

1. 状态数据库记录的是变更记录的最新结果，方便查询，使用CouchDB；
2. 历史数据库记录的是区块链结构，使用LevelDB。



### Chaincode - 链码

智能合约在Fabric中也被称为链码（chaincode）。



**用户链码和系统链码**

​	目前超级账本Fabric 项目中提供了用户链码和系统链码。

1. **用户链码**

   - 运行在单独的容器中，提供对上层应用的支持。
   - 一般所谈的链码为用户链码，用户通过链码相关的API 编写用户链码，即可对账本中状态进行更新操作。

2. **系统链码**则嵌入在系统内，提供对系统进行配置、管理的支持。

   - 系统链码有以下五个合约：

     - Configuration System Chaincode (CSCC)

       管理peer上通道相关的信息以及执行通道配置交易。

     - Life Cycle System Chaincode (LSCC) 

       用于管理链码的生命周期——在peer上安装链码、在通道上实例化和升级链码、用户从运行中的链码获取信息。

     - Query System Chaincode (QSCC) 

       运行在所有Peer上，提供账区块查询、交易查询等API。

     - Endorser System Chaincode (ESCC) 

       由背书节点调用，对一个交易响应进行密码签名。

     - Validator System Chaincode (VSCC) 

       由<u>记账节点</u>调用，包括检查背书策略和读写集版本。



**链码**

- 经过安装和实例化操作后，即可被调用。
  - 安装时，需要指定具体安装到哪个Peer 节点；
  - 实例化时，需要指定通道内及背书策略。
- Fabric 目前主要支持基于Go 语言、Java、Node.js。



## Fabric 交易流程

> https://learnblockchain.cn/books/enterprise/chapter3_05%20hyperledger_fabric_workflow_of_transaction.html

> https://hyperledger-fabric-cn.readthedocs.io/zh/latest/peers/peers.html

一个完整的交易要涉及应用程序、证书服务、背书节点、提交节点和排序节点。

- 应用程序（App）：调用Fabric SDK与区块链网络进行交互，这里的应用程序可以是网页，也可以是APP；



**客户端使用SDK与Fabric网络进行交互**：

1. 客户端先通过证书服务**获取合法的身份**并**加入到应用通道**（Channel）中。
2. 客户端构造**交易请求**（Proposal）提交给背书节点（Endorser）。
3. 背书节点对交易进行**验证和模拟**执行后（并不真正更新账本），反馈给客户端。
4. 客户端收到**足够的背书支持**后将交易发送给Orderer节点。
5. Orderer节点对网络中的交易进行**全局排序**，并将排序后的**交易打包成区块**，然后**广播**给网络中的提交节点。
6. 提交节点负责**维护区块链和账本结构**，对**交易进行最终检查**（交易结构的合法性、交易背书签名是否符合背书策略等），检查通过后写入账本。

![Peer6](https://hyperledger-fabric-cn.readthedocs.io/zh/latest/_images/peers.diagram.6.png)



**客户端使用SDK与Fabric网络查询**：

- 因为节点的本地账本副本中包含了账本查询所需的全部信息，所以节点可以立即将查询结果返回给应用程序。
- 但是，应用程序可以连接到一个或多个节点上来执行查询验证结果。
- 在图中，您可以看到账本查询是只需要三个步骤，非常简单。



## 身份与PKI

CA是用于生成权威可认证的身份，但不提供任何网络中的权限提供。



**数字证书**

 - 数字证书的申请、发布和使用

   ![数字证书的申请、发布和使用](https://upload-images.jianshu.io/upload_images/2960526-3bbf619ee9ab9547.png?imageMogr2/auto-orient/strip|imageView2/2/w/488)

 - 数字证书的生成与验证

   ![数字证书的生成与验证](https://upload-images.jianshu.io/upload_images/2960526-96b80db0b2fbfac2.png?imageMogr2/auto-orient/strip|imageView2/2/w/715)

 - 举例：

   ```yaml
   Certificate:
       Data:
           Version: 3 (0x2)
           Serial Number: 368716 (0x5a04c)
           Signature Algorithm: sha1WithRSAEncryption
           Issuer:C=US,O=Equifax,
               OU=Equifax Secure Certificate Authority
           Validity
               Not Before: Jan 4 17:09:06 2006 GMT
               Not After : Jan 4 17:09:06 2011 GMT
           Subject: C=US, ST=California, L=Santa Clara,
               O=Yahoo! Inc., OU=Yahoo, CN=login.yahoo
           Subject Public Key Info:
           Public Key Algorithm: rsaEncryption
           RSA Public Key: (1024 bit)
           Modulus (1024 bit):
   			00:b5:6c:4f:ee:ef:1b:04:5d:be:70:4a:d8:55:1d:
   			8a:77:0d:c1:45:00:f5:3b:1a:10:dd:d7:f7:bb:7a:
   			65:54:7f:60:d2:16:bb:bd:12:a5:78:78:d6:b3:50:
   			4e:ba:17:48:27:7a:22:6f:2a:7c:1d:a2:36:22:d8:
   			59:a2:ae:3a:0b:d4:d2:1b:8a:0e:5a:89:a9:e4:9a:
   			ff:db:3f:04:e2:9b:75:c1:8d:c5:8c:05:a1:f3:b5:
   			92:5e:a1:44:49:19:e4:90:b4:e9:ef:e4:5d:b2:20:
   			6d:f9:23:76:b8:b2:d4:af:a3:06:f5:9e:03:8f:b8:
   			82:05:21:11:25:44:3a:80:05
           Exponent: 65537 (0x10001)
           X509v3 extensions:
           X509v3 Key Usage: critical
           Digital Signature, Non Repudiation,
               Key Encipherment,Data Encipherment
           X509v3 Subject Key Identifier:
               A0:1E:6E:0C:9B:6E:6A:EB:D2:AE:5A:4A:18:FF:0E:93:
               46:1A:D6:32
           X509v3 CRL Distribution Points:
           URI:http://crl.geotrust/crls/secureca.crl
           X509v3 Authority Key Identifier:
           keyid:48:E6:68:F9:2B:D2:B2:95:D7:47:D8:23:20:10:
               4F:33:98:90:9F:D4
           X509v3 Extended Key Usage:
           TLS Web Server Authentication,
           TLS Web Client Authentication
           Signature Algorithm: sha1WithRSAEncryption
   			50:25:65:10:43:e1:74:83:2f:8f:9c:9e:dc:74:64:4e:71:27:
   			4e:2a:6e:4a:12:7b:4c:41:2e:61:4a:11:0b:41:a6:b1:52:cb:
   			13:76:b6:45:e4:8d:d4:00:9a:3b:02:c7:82:29:01:a3:ee:7d:
   			f7:b9:02:88:9d:3e:c3:1c:e6:3d:d3:90:fc:9c:56:db:19:9d:
   			ab:a8:03:80:7d:c4:e2:c4:09:33:9e:58:5b:77:37:89:59:a3:
   			86:8e:a1:df:b3:bb:02:ed:21:62:fb:ba:c2:ba:e8:d4:8f:66:
   			c1:a5:5f:ad:f9:3f:cf:22:9b:17:57:a0:ca:28:c6:76:03:a4:
   			c4:e7
   ```

   

   

**公钥和私钥**
- 略



**证书授权中心**

- 人员或节点能够通过由系统信任的机构为其发布的**数字身份**参与区块链网络。

- **根CA中间CA和信任链**：只要每个中间 CA 的证书的颁发 CA 是根 CA 本身或具有对根 CA 的信任链，就在根 CA 和一组中间 CA 之间建立信任链。



**证书撤销列表**
- 是 CA 知道由于某些原因而被撤销的证书的引用列表。
- 当第三方想要验证另一方的身份时，它首先检查颁发 CA 的 CRL 以确保证书尚未被撤销。验证者不是必须要检查 CRL，但如果不检查，则他们冒着接受无效身份的风险。



## 成员服务提供者

MSP的目的是将一个CA认证的身份，转换为一个具体的带有权限的角色。

注意CA的目的，只是发放了可认证的数字签名，而不提供任何关于权限的信息。



在区块链网络中，MSP 出现在两个位置，他们的区别在于**作用域**：

- 在参与者节点本地（**本地 MSP**）
- 在通道配置中（**通道 MSP**）



### 本地MSP

- 本地MSP是为了给客户端和节点，提供管理权限和参与权限的服务。
- 每一个节点都需要一个本地MSP，用于验证发来信息的人的权限。
- 注意一个组织内会有多个节点。



### 通道MSP

- 通道MSP在通道层面上，提供管理权限和参与权限的服务。

  - 应用程序层面上的节点共享通道MSP的相同视图，因此将能够正确地验证通道参与者。

  - 如果组织希望加入渠道，则需要在渠道配置中包含一个包含组织成员信任链的MSP。
  - 本地MSP在文件系统上表示为文件夹结构，而通道MSP在通道配置中描述。

- 每一个参与通道的组织，都需要一个通道MSP，建议组织与MSP之间存在一对一的映射。

- 系统通道MSP包括了参与排序服务的所有组织的MSP

- 本地MSP是存储于节点或用户的文件系统中；<br>通道MSP则是通过共识机制进行同步，一致性的存储于每个节点的文件系统中。



### 组织

- 组织拥有单一的MSP，在此基础上管理他们的成员。

- MSP允许绑定身份到组织。

- 组织与其MSP之间的一对一关系，使得以组织名称命名MSP更为合理。在大多数策略配置中，将采用这种约定。



### Organizational Units

- 一个组织也可以被划分为多个组织单位，每个单位都有一套特定的职责，也称为附属机构。可以把OU想象成组织内部的一个部门。

- 当CA颁发X.509证书时，证书中的OU字段指定了该标识所属的业务部门。

- 这样使用OUs的一个好处是，可以在**策略**定义中使用这些值来限制访问，或者在**智能合约**中使用它们来进行基于属性的**访问控制**。



### NodeOU

- 可将组织的成员限制为特定NodeOU角色。
- 例如，这种方式可以实现更细粒度的背书策略，该策略要求Org1的Peer节点背书一个事务，而不是Org1的其他节点。

- 一般而言，NodeOU具有`client`、`peer`、`admin`、`orderer`，4种角色。（v1.4.3才有后两者）

  ```yaml
  NodeOUs:
    Enable: true
    ClientOUIdentifier:
      Certificate: cacerts/ca.sampleorg-cert.pem
      OrganizationalUnitIdentifier: client
    PeerOUIdentifier:
      Certificate: cacerts/ca.sampleorg-cert.pem
      OrganizationalUnitIdentifier: peer
    AdminOUIdentifier:
      Certificate: cacerts/ca.sampleorg-cert.pem
      OrganizationalUnitIdentifier: admin
    OrdererOUIdentifier:
      Certificate: cacerts/ca.sampleorg-cert.pem
      OrganizationalUnitIdentifier: orderer
  
  ```

- X509证书的CommonName属性中的OU可以用于区分MSP角色。如OU=client将被标识为client等等。
- 当使用Fabric CA或SDK向CA注册用户时，这些角色和OU属性被分配给一个身份，在用户的/msp文件夹中生成证书。
- 生成的角色和OU属性在`/signcerts`文件夹中的X.509签名证书中可见。角色属性被标识为`hf.Type`。

![MSP1d](https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/signcert.png)



注意:对于通道MSPs，管理系统的身份分配方式，由管理系统资源的**策略**决定。例如，通道策略可能指定ORG1-MANUFACTURING管理员(即具有admin角色和ORG1-MANUFACTURING节点OU的身份)有权向通道添加新组织，而ORG1-DISTRIBUTION管理员没有这样的权利。

最后，当联盟中的不同组织信任相同的CA时，OUs可以被用来区分彼此。但当每个组织都拥有相同的CA或信任链时，这将使系统更加集中化，因此在区块链网络中值得仔细考虑。



## 策略

策略是一组规则，用来定义谁可以干什么的权限。

Fabric 策略表示成员如何同意或者拒绝网络、通道或者智能合约的变更。

策略在网络最初配置的时候由联盟成员一致同意，但是在网络演化的过程中可以进行修改。



### 实现方式

**系统通道配置**

排序系统通道是第一个被创建的通道。

该通道也包含着谁是排序服务，以及联盟组织的成员。

- 排序系统通道配置区块中的策略治理着排序服务使用的共识，并定义了新区块如何被创建。

- 治理着联盟中的哪些成员可以创建新通道。



 **应用通道配置**

应用 *通道* 用于向联盟中的组织间提供私有通信机制。

- 治理着从通道中添加和删除成员的能力。
- 治理着链码定义和提交到通道，需要哪些组织同意。
- 应用通道创建时，默认继承了排序系统通道的所有排序参数。



**权限控制列表**

ACL  通过将资源和已有策略相关联的方式提供了资源访问配置的能力。

ACL 参考应用通道配置中定义的策略并将它们扩展到了其他资源的控制。

Fabric ACL 的默认集合在 `configtx.yaml` 文件的 `Application 部分，但它们应该在生产环境中被重写。

`configtx.yaml` 中定义的资源列表是 Fabric 当前定义的所有内部资源的完整集合。

该文件中，ACL 以如下格式表示：

```
# ACL policy for chaincode to chaincode invocation
peer/ChaincodeToChaincode: /Channel/Application/Writers
```

`peer/ChaincodeToChaincode` 表示该资源是被保护的，相关的交易必须符合 `/Channel/Application/Writers` 引用侧策略才能被认为是有效的。



### 策略类型

**签名策略**

当需要某些用户提供签名后，才能进行某种操作时使用。
语法支持 `AND`、 `OR` 和 `NOutOf` 的任意组合。
例如： `AND (Org1, Org2)` ，表明同时需要 Org1 中的一个成员和 Org2 中的一个成员的签名。



**隐元策略**

`隐元`策略只在通道配置上下文中有效，通道配置在配置树策略中是基于分层的层次结构。

隐元策略有三种，分别是值任意一个子节点、所有子节点、大多数子节点，满足某策略。



![policies.policies](https://hyperledger-fabric.readthedocs.io/zh_CN/release-2.2/_images/FabricPolicyHierarchy-6.png)

正如你在上图看到的，`隐元`策略，Type = 3，使用了一种不同的语法 `"<ANY|ALL|MAJORITY> <SubPolicyName>"`，例如：`MAJORITY sub policy: Admins`


上边的图表展示了一个在配置树中所有 `Admins` 策略都引用了的 `Admins` 子策略。你可以创建你自己的子策略并随意命名。

隐元策略的主要优势在于当你向通道添加新组织的时候，你不必更新通道策略。

你也可以定义一个**应用级别的隐策略**来进行跨组织操作，例如在通道中，需要 ANY （任意）、 ALL （全部）或者 MAJORITY （大多数）组织来满足。这个格式有更好、更自然的默认值，因此组织可以决定有效背书的含义。

你可以通过在组织定义中引入 [`NodeOUs`](https://hyperledger-fabric.readthedocs.io/zh_CN/release-2.2/policies/msp.html#organizational-units) 来实现进一步的粒度和控制。OU （Organization Units，组织单元）定义在 Fabric CA 客户端配置文件中，当创建身份的时候就会与之关联。在 Fabric 中， `NodeOUs` 提供为数字证书层级分类的功能。例如，一个指定了 `NodeOUs` 的组织可以让一个 ‘Peer’ 签名合法背书，或者组织也可以简单设置为任何成员都可以签名。



### 策略定义的细节

- `configtx.yaml`的组织部分定义了默认策略，`Readers, Writers, Admins, and Endorsement`，但是你可以任意定义策略命名。每个策略都有一个 `Type` 和 `Rule`。



### Fabric链码生命周期

Fabric 2.0 中，引入了链码生命周期过程。它允许多个组织在链码应用到通道之前如何操作进行投票。

这个很重要，因为这是新生命周期过程和策略的融合，策略是在过程中指定的决定着网络的安全性。

新的流程指定策略包含两步，当链码被组织成员**批准**的时候，以及当它被**提交**到通道后。



## 节点

> https://hyperledger-fabric-cn.readthedocs.io/zh/latest/peers/peers.html



### 节点与账本

- 区块链网络由节点组成，每个节点都可以保存**账本副本和智能合约副本**。
- 它们使用相同的**链码来访问**各自的分布式**账本**的副本。
- 节点可保存多个账本，并且每个账本都可以有多个适用于它们的链码。



### 节点与应用程序

- 交互方式有两种：更新账本、查询账本，他们都是通过智能合约进行的。
- 步骤详见Fabric 交易流程。



### 节点与通道

- 通道允许一组特定的节点和应用程序在区块链网络中彼此通信。
- 组件通常是节点、排序节点和应用程序。

![Peer5](https://hyperledger-fabric-cn.readthedocs.io/zh/latest/_images/peers.diagram.5.png)



### 节点与组织

- 区块链网络是由不同组织所拥有和提供的节点构建而成的。
- 应用程序可以连接到其所在组织上的节点，也可以连接到另一个组织上的节点，这取决于所需账本交互的性质：
  - 对于账本查询交互来说，应用程序通常连接到它们自己组织的节点上。
  - 对于账本更新交互来说，应用程序需要连接到**每个**对账本更新背书的组织的节点上。

![Peer8](https://hyperledger-fabric-cn.readthedocs.io/zh/latest/_images/peers.diagram.8.png)



### 节点与身份

- 网络中的每个节点，都由所属组织的管理员分配一个数字证书，作为身份。
- 当节点连接到通道时，节点的数字证书通过该通道的 MSP 识别其所属组织。
  - 通道配置中的**策略使用节点的身份来确定其权限**
  - 而MSP规定了，如何在组织中**将某角色分配给一个节点**，并让节点**相应地获得**对区块链资源的适当**访问权**。
  - 例：通道 C 在其通道配置的策略中规定，由 CA1 颁发的身份应该被 ORG1.MSP 分配，从而与 Org1 关联。
- 所有与区块链网络交互的东西，都从它们的数字证书和 MSP 中获得身份。使用身份与区块链网络交互的每个实体，被称作主体`principal`。

![Peer9](https://hyperledger-fabric-cn.readthedocs.io/zh/latest/_images/peers.diagram.9.png)



### 节点与排序服务与共识

想要更新账本的应用程序会涉及到三个步骤，这些步骤确保了区块链网络中的所有节点能保持彼此账本始终一致。

1. 应用程序与一组*背书节点*合作，每个背书节点都向该应用程序提供对拟账本更新的背书，但是并不会把该拟更新应用到自己的账本副本上。
2. 把各背书节点做出的背书收集起来作为交易打包成区块。
3. 将这些区块分发给每个节点，节点会对每项交易进行验证，随后将交易提交到各自账本副本上。

排序节点是上述过程的核心，所以让我们来深入研究一下应用程序和节点如何使用排序节点生成账本更新，而这些更新可被持续应用到一个分布式、可复制的账本上。



#### 第一阶段：提案

- 目的：应用程序请求不同组织的背书节点，对拟链码调用的结果做出同意。

1. 应用程序必须先生成一个交易提案`Transaction & proposal`
2. **通过TCP？**，向每个节点发送交易提案。
3. 每个节点独立模拟调用，生成一个`Transaction & response & endorsement`，返回。

![Peer10](https://hyperledger-fabric-cn.readthedocs.io/zh/latest/_images/peers.diagram.10.png)



**注意**

1. 应用程序会选择哪些节点呢？这取决于*背书策略*（为链码定义的），它定义了一群组织，需要接受某项拟账本更新之前作出背书。
2. 节点通过**添加自己的数字签名**来对提案响应进行背书，并使用自己的**私钥为整个`payload`进行签名**。（类似与 message+私钥加密的hash 的过程?）
3. 应用程序可以按照自己的意愿丢弃不一致的交易响应，从而有效地提前终止交易流程。而如果其试图使用一组不一致的交易响应来更新账本，它将被拒绝。



#### 第二阶段：排序和打包

交易流程的第二阶段是打包阶段。

排序节点是该流程的关键——多个应用程序向排序节点发送交易，其中包含了已背书的交易提案响应，随后排序节点将这些交易排序进区块。

有关排序和打包阶段的更多细节，见排序服务标题。



**注意**

1. 这个过程中没有验证交易。
2. **比特币**由于出块时间很长，所以出现交易不一致的可能性很小，同时merkle tree不限制交易的顺序；<br>**以太坊**通过给叔父区块一些奖励，避免了因为不一致导致的矿工挖矿不积极的问题，交易始终存在于最长合法链中；<br>Hyperledger则通过较为中心化的排序节点组织，统一进行一致性处理。



#### 第三阶段：验证和提交

- **所有节点**都会对一个区块内的**每一笔交易进行验证**，以确保这些交易在应用到账本上之前已经得到所有相关组织的背书。
- **未成功的交易会被留下来进行审计**，但不会提交到账本上。*这意味着节点中的区块与从排序节点接收到的区块几乎完全相同，唯一不同的是节点区块中的每个交易上都存在有效或无效指示符。*
- 最后，每次将一个区块提交到节点的账本上时，该节点都会生成一个**适当的事件**。

![Peer12](https://hyperledger-fabric-cn.readthedocs.io/zh/latest/_images/peers.diagram.12.png)



**注意**

- 并不是每个 peer 节点都需要连接到一个排序节点上——peer 节点可以使用 **Gossip 协议**将区块信息发送给其他（未连接到排序节点的） Peer 节点，这些 Peer 节点在收到信息后也可以独立地处理新区块。
- 链码运行只发生在阶段一，这意味着**链码只需存在于背书节点**上。这样一来，只有参与背书的组织才能看到链码的逻辑。而链码输出会在通道上的各节点间共享，无论这些节点是否参与了该交易的背书。
- 关于适当的事件：
  - *区块事件*包括完整的区块内容；
  - 区块交易事件只包含总结信息，例如区块中的每个交易经验证显示有效还是无效；
  - 链码执行产生的*链码*事件也可以在这个时候发布出去。



## 账本

> https://hyperledger-fabric-cn.readthedocs.io/zh/latest/ledger/ledger.html

- 账本由“**世界状态**“和”**区块链**“这两部分组成，其中**世界状态由区块链决定**。

- **世界状态**是一个数据库，它存储了一组账本状态的**当前值**。通过世界状态，程序可以直接访问一个账本状态的当前值，不需要遍历整个交易日志来计算当前值。<br>默认情况下，账本状态是以键值对的方式来表示的，我们可以创建、更新和删除状态，所以世界状态**能够频繁更改**。
- **区块链**是交易日志，它记录了促成当前世界状态的所有改变。交易被收集在附加到区块链的区块中，促成当前世界状态的改变的历史。<br>区块链数据结构与世界状态相差甚远，因为它是**不可篡改的**。



### 世界状态

- 世界状态将业务对象属性，保存为唯一的账本状态，可以直接获取当前值。而不必遍历整个区块链来计算对象。
- **应用程序**可以调用**智能合约**，该合约使用简单的账本 API 来获取、写入和删除状态。
- 数据库为有效存储和状态检索提供了充分的算子。我们可以将 Hyperledger  Fabric 配置为使用不同的世界状态数据库来满足各种需求，例如复杂查询。
- 每个状态都有一个版本号。**版本号**是供 Hyperledger Fabric 内部使用的，并且每次**状态更改时版本号会发生递增**。每当更新状态时，都会检查该状态的版本，以确保当前状态与背书时的版本相匹配。这就确保了世界状态是按照预期进行更新的，没有发生并发更新。
- 由于任何时候都可以从区块链中重新生成世界状态。这样一来就变得非常方便，例如，创建节点时会自动生成世界状态。此外，如果某个节点发生异常，重启该节点时能够在接受交易之前重新生成世界状态。



### 区块链

- 区块链是一种历史记录，它记录了这些业务对象是如何到达各自当前状态的相关事实，记录了每个账本状态之前的所有版本以及状态是如何被更改的。
- 区块链的结构是一群相互链接的区块的**序列化日志**，其中每个区块都包含一系列交易，各项交易代表了一个对世界状态进行的查询或更新操作。
- 区块链总是被作为一个文件来实现，而与之相反的是，世界状态被作为一个数据库来实现。这是一个明智的设计，因为区块链数据结构高度偏向于非常小的一组简单操作。
- **创始区块**，它并不包含任何用户交易，但包含了一个配置交易，该交易含有网络配置的初始状态。



![ledger.blockchain](https://hyperledger-fabric-cn.readthedocs.io/zh/latest/_images/ledger.diagram.2.png)



### 区块

让我们仔细看看区块的结构。它由三个部分组成

- **区块头**

  这个部分包含三个字段，这些字段是在创建一个区块时候被写入的。

  - **区块编号**：编号从0（初始区块）开始，每在区块链上增加一个新区块，编号的数字都会加1。
  - **当前区块的哈希值**：当前区块中包含的所有交易的哈希值。
  - **前一个区块头的哈希值**：区块链中前一个区块头的哈希值。

  这些字段是通过在内部对区块数据进行加密哈希而生成的。它们确保了每一个区块和与之相邻的其他区块紧密相连，从而组成一个不可更改的账本。

  - 你可以通过`peer channel getinfo`获得当前区块头的信息。

    ```shell
    $ peer channel getinfo -c mychannel | awk -F ' ' '{print $3}' | jq .
      {
        "height": 6,
        "currentBlockHash": "IXxJ2uooO5V+m3om0il2CaLOdrKd2jF1n7VDyV0ZgmM=",
        "previousBlockHash": "n2yoE1rXuao71PR+jFwd7z+xy5gA6BH3MwgFOPLNnvM="
      }
    ```

    

  ![ledger.blocks](https://hyperledger-fabric-cn.readthedocs.io/zh/latest/_images/ledger.diagram.4.png)

  

- **区块数据**

  - 这部分包含了一个有序的交易列表。
  - 区块数据是在排序服务创建区块时被写入的。这些交易的结构很复杂但也很直接，我们会在后边进行讲解。

- **区块元数据**
  - 这个部分包含了区块被写入的时间，还有区块写入者的证书、公钥以及签名。
  - 随后，区块的提交者也会为每一笔交易添加一个**有效或无效的标记**，但由于这一信息与区块同时产生，所以**它不会被包含在哈希中**。



### 交易

正如我们所看到的，交易记录了世界状态发生的更新。让我们来详细了解一下这种把交易包含在区块中的**区块数据**结构。

![ledger.transaction](https://hyperledger-fabric-cn.readthedocs.io/zh/latest/_images/ledger.diagram.5.png)

在上面的例子中，我们可以看到以下字段：

- **（Header）交易头**

  这部分用 H4 表示，它记录了关于交易的一些重要元数据，比如，相关链码的名字以及版本。

- **（Signature）交易签名**

  这部分用 S4 表示，它包含了一个**由客户端应用程序创建**的加密签名。该字段是用来检查交易细节是否未经篡改，因为交易签名的生成需要用到应用程序的私钥。

- **（Proposal）交易提案**

  这部分用 P4 表示，它负责对应用程序供给智能合约的**输入参数**进行编码，随后该智能合约生成提案账本更新。在智能合约运行时，这个提案提供了一套输入参数，这些参数同当前的世界状态一起决定了新的账本世界状态。

- **（Response）交易响应**

  这部分用 R4 表示，它是以**读写集** （RW-set）的形式记录下世界状态之前和之后的值。交易响应**是智能合约的输出**，如果交易验证成功，那么该交易会被应用到账本上，从而更新世界状态。

- **（Endorsements）交易背书**

  就像 E4  显示的那样，它指的是一组签名交易响应，这些签名都来自背书策略规定的相关组织，并且这些组织的数量必须满足背书策略的要求。

  在交**易中只包含一个交易响应，但是会有多个背书**。这是因为每个背书包含了它的组织特定的交易响应，这意味着不需要包含无效的背书的交易响应，因为它会被作为无效的交易被拒绝，并且不会更新世界状态。

以上总结了交易的一些主要字段，其实还有其他字段，但是上述几种是您需要了解的基本字段，便于您对账本数据结构有一个很好的了解。



### 世界状态数据库选项

- 世界状态数据库可以多种形式实现。目前，世界状态数据库的选项包括 LevelDB 和 CouchDB 。

- LevelDB 是世界状态数据库的默认选项，当账本状态是简单的键值对时，使用 LevelDB 非常合适。LevelDB 数据库与 peer 节点位于相同位置，它被嵌入与 peer 节点相同的操作系统进程中。

- 当账本状态结构为 JSON 文档时，以 CouchDB 来实现世界状态非常合适。

  这是因为业务交易涉及的数据类型通常十分丰富，而  CouchDB 可支持对这些数据类型进行各种形式的查询和更新。

  在实现方面，CouchDB 是在单独的操作系统进程中运行的，但是节点和  CouchDB 实例之间仍然存在1:1的关系。智能合约无法看到上述任何内容。



### 命名空间

- 每个链码都有自己的世界状态，并且与所有其他链码的世界状态分离。**世界状态位于一个命名空间**中，因此只有**位于同一链码中的智能合约**才能访问一个给定的名称空间。

- **区块链没有命名空间**。它包含来自许多不同智能合约命名空间的交易。



### 通道

- 每个通道都有一个完全独立的账本。
- 这意味着完全独立的区块链和完全独立的世界状态，包括名称空间。
- 应用程序和智能合约可以在通道之间通信，以便在通道间访问账本信息。



### 更多信息

- [链码命名空间](https://hyperledger-fabric-cn.readthedocs.io/zh/latest/developapps/chaincodenamespace.html)
- [交易流程](https://hyperledger-fabric-cn.readthedocs.io/zh/latest/txflow.html)
- [读写集语义](https://hyperledger-fabric-cn.readthedocs.io/zh/latest/readwrite.html)
-  [CouchDB 作为状态数据库](https://hyperledger-fabric-cn.readthedocs.io/zh/latest/couchdb_as_state_database.html)



## 排序服务

- 许多分布式区块链，如以太坊和比特币，都是非许可链的，这意味着任何节点都可以参与共识过程，在共识过程中，交易被排序并捆绑成区块。因为这个事实，这些系统依靠**概率共识算法**最终保证账本一致性高的概率，但仍容易受到不同的账本（有时也称为一个账本“分叉”），在网络中不同的参与者对于交易顺序有不同的观点。
- Hyperledger Fabric 的工作方式不同。它有一种称为**排序节点**的节点使交易有序，并与其他排序节点一起形成一个**排序服务**。因为 Fabric 的设计依赖于**确定性的共识算法**，所以 Peer 节点所验证的排序服务生成的任何区块都是最终的和正确的。账本**不会像其他分布式区块链中那样产生分叉**。



### 排序节点与通道配置

- 排序节点还维护着**允许创建通道**的组织列表。

  此组织列表称为“联盟”，保存在“排序节点系统通道”（或“排序系统通道”）的配置中。

  默认情况下，此列表及其所在的通道**只能由排序节点管理员**编辑。

- 排序节点还对通道执行**基本访问控制**，限制谁可以读写数据，以及谁可以配置数据。

  请记住，谁有权修改通道中的配置元素取决于相关**管理员在创建联盟或通道时设置的策略**。配置交易由排序节点处理，因为它需要知道当前的策略集合，并根据策略来执行其基本的访问控制。

  在这种情况下，排序节点处理**配置更新**，以确保请求者拥有正确的管理权限。如果有权限，排序节点将根据现有配置验证更新请求，生成一个新的配置交易，并将其打包到一个区块中，该区块将转发给通道上的所有节点。然后节点处理配置交易，以验证排序节点批准的修改确实满足通道中定义的策略。



### 排序节点和交易流程



#### 阶段一：提案

略，详见节点与排序服务与共识。



#### 阶段二：将交易排序并打包到区块中

- 区块中的交易数量，取决于区块的期望大小和最大间隔时间相关的通道配置参数（即`BatchSize` 和 `BatchTimeout` 参数）。

- 然后将这些区块保存到排序节点的账本中，并分发给已经加入通道的所有节点。

  如果此时恰好有一个 Peer  节点关闭，或者稍后加入通道，它将在重新连接到排序服务节点或与另一个 Peer  节点通信之后接收到这些区块。

![Orderer1](https://hyperledger-fabric-cn.readthedocs.io/zh/latest/_images/orderer.diagram.1.png)

- 注意，一个区块中**交易的顺序不一定与排序服务接收的顺序相同**，因为可能有多个排序服务节点几乎同时接收交易。重要的是，排序服务将交易放入**严格的顺序**中，并且 Peer 节点在验证和提交交易时将使用这个顺序。

- 在 Hyperledger Fabric 中，由排序服务生成的区块是**最终的**。正如我们前面所说，Hyperledger Fabric 的最终性意味着没有**账本分叉**，也就是说，经过验证的交易永远不会被重写或删除。

- 到达排序节点的每个授权交易都被机械地打包在一个区块中，**排序节点不判断交易**的内容（前面提到的通道配置交易除外）。

在第二阶段的最后，我们看到排序节点负责一些简单但重要的过程，包括收集已提案的交易更新、排序并将它们打包成区块、准备分发。



#### 阶段三：验证和提交

略，详见节点与排序服务与共识。



### 排序服务实现

虽然当前可用的每个排序服务都以相同的方式处理交易和配置更新，但是仍然有几种不同的实现可以在排序服务节点之间就严格的交易排序达成共识。

有关如何建立排序节点（无论该节点将在什么实现中使用）的信息，请参阅[关于建立排序节点](https://hyperledger-fabric-cn.readthedocs.io/zh/latest/orderer_deploy.html)的文档。

- **Solo**（v2.x 已弃用）

  排序服务的 Solo 实现就像它的名字一样：它只具有一个排序节点。因此，它不是，也永远不会是容错的。它仅用于测试，并且已被弃用，在未来的版本中可能会被完全删除。Solo现有用户应转移到单节点Raft网络，实现同等功能。

- **Raft**（推荐）

  作为v1.4.1的新特性，Raft 是一种基于 [`etcd`](https://coreos.com/etcd/) 中 [Raft 协议](https://raft.github.io/raft.pdf)实现的崩溃容错（Crash Fault Tolerant，CFT）排序服务。Raft  遵循“leader and follower”模型，这个模型中，在每个通道上选举领导者节点，其决策被跟随者复制。Raft  排序服务会比基于 Kafka  的排序服务更容易设置和管理，它的设计允许不同的组织为分布式排序服务贡献节点。

- **Kafka**（v2.x 已弃用）

  和基于 Raft 的排序类似，Apache Kafka 是一个 CFT 的实现，它使用“领导者和跟随者”节点配置。Kafka 利用一个  ZooKeeper 进行管理。基于 Kafka 的排序服务从 Fabric v1.0开始就可以使用，但许多用户可能会发现管理 Kafka  集群的额外管理开销令人生畏或不受欢迎。



### Raft

- Fabric 实现了使用“领导者跟随者”模型的 Raft  协议，领导者是在一个通道的排序节点中动态选择的（这个集合的节点称为“批准者集合`consenter set`”），领导者将信息复制到跟随者节点。

- Raft  被称为“崩溃容错”是因为系统可以承受节点的损失，包括领导者节点，前提是要剩余大量的排序节点（称为“法定人数`quorum`”）。

  换句话说，如果一个通道中有三个节点，它可以承受一个节点的丢失（剩下两个节点）。如果一个通道中有五个节点，则可以丢失两个节点（剩下三个节点）。

与Kafka相比，Raft有几个主要的差异值得考虑，特别是如果你打算管理一个排序服务：

- Raft 更容易设置
  - 部署 Kafka 集群及其 ZooKeeper  集群会很棘手，需要在 Kafka 基础设施和设置方面拥有高水平的专业知识。
  - 使用 Kafka 管理的组件比使用 Raft  管理的组件多，这意味着有更多的地方会出现问题。Kafka 有自己的版本，必须与排序节点协调。
  - **使用 Raft，所有内容都会嵌入到您的排序节点中**。
- Kafka 和 Zookeeper 应该在一组紧密的主机中运行
  - 它们被设计为  CFT，但应该在一组紧密的主机中运行。这意味着实际上，您需要有一个组织运行 Kafka 集群。在使用 Kafka  时，让不同组织运行排序节点不会给您带来太多的分散性，因为这些节点都将进入同一个由单个组织控制的 Kafka 集群。
  - 使用  Raft，每个组织都可以有自己的排序节点参与排序服务，从而形成一个更加分散的系统。
- Raft 是原生支持的。
  - 虽然基于 Kafka 的排序服务目前与 Fabric 兼容，但用户需要获得相关的镜像，并学习如何单独使用 Kafka 和 ZooKeeper。同样，对 Kafka 相关问题的支持是通过 [Apache](https://kafka.apache.org/) 来处理的，Apache 是 Kafka 的开源开发者，而不是 Hyperledge Fabric。
  - 另一方面，Fabric Raft 的实现已经开发出来了，并将在 Fabric 开发人员社区及其支持设备中得到支持。
- Kafka 使用一个服务器池（称为“Kafka 代理”），而且排序组织的管理员要指定在特定通道上使用多少个节点，但是 Raft  允许用户指定哪个排序节点要部署到哪个通道。通过这种方式，节点组织可以确保如果他们也拥有一个排序节点，那么这个节点将成为该通道的排序服务的一部分，而不是信任并依赖一个中心来管理 Kafka 节点。
- Raft 是向开发拜占庭容错（BFT）排序服务迈出的第一步。正如我们将看到的，Fabric 开发中的一些决策是由这个驱动的。如果你对 BFT 感兴趣，学习如何使用 Raft 应该可以慢慢过渡。

**注意：与 Solo 和 Kafka 类似，在向客户发送回执后 Raft  排序服务也可能会丢失交易。例如，如果领导者和跟随者提供回执时同时崩溃。因此，应用程序客户端应该监听节点上的交易提交事件，而不是检查交易的有效性。但是应该格外小心，要确保客户机也能优雅地容忍在配置的时间内没有交易提交超时。根据应用程序的不同，在这种超时情况下可能需要重新提交交易或收集一组新的背书。**



#### Raft 概念

虽然 Raft 提供了许多与 Kafka 相同的功能（尽管它是一个简单易用的软件包）但它与 Kafka 的功能却大不相同，它向 Fabric 引入了许多新的概念，或改变了现有的概念。

**日志条目（Log entry）**

- Raft 排序服务中的主要工作单元是一个“日志条目”，该项的完整序列称为“日志”。如果大多数成员（换句话说是一个法定人数）同意条目及其顺序，则我们认为条目是一致的，然后将日志复制到不同排序节点上。

**批准者集合（Consenter set）**

- 主动参与给定通道的共识机制并接收该通道的日志副本的排序节点。这可以是所有可用的节点（在单个集群中或在多个集群中为系统通道提供服务），也可以是这些节点的一个子集。

**有限状态机（Finite-State Machine，FSM）**

- Raft 中的每个排序节点都有一个 FSM，它们共同用于确保各个排序节点中的日志序列是确定（以相同的顺序编写）。

**法定人数（Quorum）**

- 描述需要确认提案的最小同意人数。对于每个批准者集合，这是**大多数**节点。在具有五个节点的集群中，必须有三个节点可用，才能有一个法定人数。如果节点的法定人数因任何原因不可用，则排序服务集群对于通道上的读和写操作都不可用，并且不能提交任何新日志。

**领导者（Leader）**

- 这并不是一个新概念，正如我们所说，Kafka  也使用了领导者，但是在任何给定的时间，通道的批准者集合都选择一个节点作为领导者，这一点非常重要（我们稍后将在 Raft  中描述这是如何发生的）。领导者负责接收新的日志条目，将它们复制到跟随者的排序节点，并在认为提交了某个条目时进行管理。这不是一种特殊**类型**的排序节点。它只是排序节点在某些时候可能扮演的角色，而不是由客观环境决定的其他角色。

**跟随者（Follower）**

- 再次强调，这不是一个新概念，但是理解跟随者的关键是跟随者从领导者那里接收日志并复制它们，确保日志保持一致。我们将在关于领导者选举的部分中看到，跟随者也会收到来自领导者的“心跳”消息。如果领导者在一段可配置的时间内停止发送这些消息，跟随者将发起一次领导者选举，它们中的一个将当选为新的领导者。



#### 交易流程中的 Raft

- 在 Raft 中，交易由接收交易的排序节点自动路由到该通道的当前领导者。这意味着 Peer 节点和应用程序在任何特定时间都不需要知道谁是领导者节点。只有排序节点需要知道。
- 每个通道都在 Raft 协议的**单独**实例上运行，该协议允许每个实例选择不同的领导者。
- 这种配置还允许在集群由不同组织控制的排序节点组成的用例中进一步分散服务。
  - 虽然所有 Raft  节点都必须是系统通道的一部分，但它们不一定必须是所有应用程序通道的一部分。
  - 通道创建者（和通道管理员）能够选择可用排序节点的子集，并根据需要添加或删除排序节点（只要一次只添加或删除一个节点）。

虽然这种配置以冗余心跳消息和线程的形式产生了更多的开销，但它为 BFT 奠定了必要的基础。

当排序节点检查完成后，将按照我们交易流程的第二阶段的描述，对交易进行排序、打包成区块、协商并分发。



### Raft 简介

#### Raft 是如何选举领导者的

尽管选举领导者的过程发生在排序节点的内部过程中，但是值得注意一下这个过程是如何工作的。

- 节点总是处于以下三种状态之一：跟随者、候选人或领导者。
- 所有节点最初都是作为**跟随者**开始的。在这种状态下，他们可以接受

  - 来自领导者的日志条目（如果其中一个已经当选）

  - 为领导者投票。
- 如果在一段时间内没有接收到日志条目或心跳（例如，5秒），节点将自己提升到**候选**状态。
  - 在候选状态中，节点从其他节点请求选票。
- 如果候选人获得法定人数的选票，那么他就被提升为**领导者**。
  - 领导者必须接受新的日志条目并将其复制到跟随者。



#### 快照

如果一个排序节点宕机，它如何在重新启动时获得它丢失的日志？

虽然可以无限期地保留所有日志，但是为了节省磁盘空间，Raft 使用了一个称为“快照”的过程，在这个过程中，用户可以定义日志中要保留多少字节的数据。这个数据量将符合一定数量的区块（这取决于区块中的数据量。注意，快照中只存储完整的区块）。

> 例如，假设滞后副本 `R1` 刚刚重新连接到网络。它最新的区块是`100`。领导者 `L` 位于第 `196` 块，并被配置为快照20个区块。`R1` 因此将从 `L` 接收区块`180`，然后为区块`101`到`180`区块`发送`请求。然后`180`到`196`的区块将通过正常 Raft 协议复制到 `R1`。



### 更多信息

- <http://thesecretlivesofdata.com/raft/>
- [Gossip 数据传播协议](https://hyperledger-fabric-cn.readthedocs.io/zh/latest/gossip.html)
- [In Search of an Understandable Consensus Algorithm](https://raft.github.io/raft.pdf)



## 智能合约与链码

- 智能合约是一个特定领域的程序，与特定的业务流程相关；而链码则是一组相关智能合约的技术容器
- 多个智能合约也可以定义在同一个链码中。当一个链码部署完毕，该链码中的所有智能合约都可供应用程序使用。

![smart.diagram2](https://hyperledger-fabric-cn.readthedocs.io/zh/latest/_images/smartcontract.diagram.02.png)





### 背书

- 每个链码都有一个背书策略与之相关联，该背书策略适用于此链码中定义的所有智能合约。
  - 注意：命名空间是针对链码的，也就是说同一个链码下的智能合约是**共享同一个世界状态**。
- 背书策略指明了区块链网络中哪些组织，必须对一个既定智能合约所生成的交易进行签名，以此来宣布该交易**有效**。
- 背书策略的设计旨在让 Hyperledger Fabric 更好地模拟这些真实发生的交互。

![smart.diagram3](https://hyperledger-fabric-cn.readthedocs.io/zh/latest/_images/smartcontract.diagram.03.png)



一个示例背书策略可能这样定义：参与区块链网络的四个组织中有三个必须在交易被认为**有效**之前签署该交易。所有的交易，无论是**有效的**还是**无效的**，都会被添加到分布式账本中，但仅**有效**交易会更新世界状态。

如果一项背书策略指定，必须有不止一个组织来签署交易，那么只有当足够数量的组织都执行了智能合约，才能够生成有效交易。在[上面](https://hyperledger-fabric-cn.readthedocs.io/zh/latest/smartcontract/smartcontract.html#endorsement)的示例中，要使用于车辆 `transfer` 的智能合约交易有效，需要 `ORG1` 和 `ORG2` 都执行并签署该交易。

背书策略是 Hyperledger Fabric  与以太坊（Ethereum）或比特币（Bitcoin）等其他区块链的区别所在。在这些区块链系统中，网络上的任何节点都可以生成有效的交易。而  Hyperledger Fabric 更真实地模拟了现实世界；交易必须由 Fabric  网络中受信任的组织验证。例如，一个政府组织必须签署一个有效的 `issueIdentity` 交易，或者一辆车的 `buyer` 和 `seller` 都必须签署一个 `car` 转移交易。背书策略的设计旨在让 Hyperledger Fabric 更好地模拟这些真实发生的交互。



### 有效交易

- 当智能合约执行时，它会在区块链网络中组织所拥有的节点上运行：
  - 智能合约提取一组名为**交易提案**的输入参数，并将其与程序逻辑结合起来使用以读写账本。
  - 对世界状态的更改被捕获为**交易提案响应**（或简称**交易响应**）
  - 该响应包含一个**读写集**，其中既含有已读取的状态，也含有还未书写的新状态（如果交易有效的话）

![smart.diagram4](https://hyperledger-fabric-cn.readthedocs.io/zh/latest/_images/smartcontract.diagram.04.png)

**注意**

- 在执行智能合约时**世界状态没有更新**！
- 所有交易，无论是否有效，都会被记录在区块链上，但仅有效交易会更新世界状态。



### 通道

- Fabric 允许一个组织利用**通道**同时参与多个、彼此独立的区块链网络。
- 通道在**维持数据和通信隐私**的同时还提供了高效的基础设施共享。

![smart.diagram5](https://hyperledger-fabric-cn.readthedocs.io/zh/latest/_images/smartcontract.diagram.05.png)

​	链码定义是一种包含了许多参数的结构，这些参数管理着链码的运行方式，包含着链码名、版本以及背书策略。各通道成员批准各自组织的一个链码定义，以表示其对该链码的参数表示同意。当足够数量（默认是多数）的组织都已批准同一个链码定义，该定义可被提交至这些组织所在的通道。随后，通道成员可依据该链码定义中指明的背书策略来执行其中的智能合约



### 互通

一个智能合约既可以调用同通道上的其他智能合约，也可以调用其他通道上的智能合约。这样一来，智能合约就可以读写原本因为智能合约命名空间而无法访问的世界状态数据。



### 系统链码

链码还可以定义低级别程序代码，这些代码符合关于领域的*系统*交互，但与业务流程的智能合约无关。

以下是不同类型的系统链码及其相关缩写：

- `_lifecycle` 

  在所有 Peer 节点上运行，它负责管理节点上的链码安装、批准组织的链码定义、将链码定义提交到通道上。你可以在[这里](https://hyperledger-fabric-cn.readthedocs.io/zh/latest/chaincode4noah.html#chaincode-lifecycle)阅读更多关于 `_lifecycle` 如何实现 Fabric 链码生命周期的内容。

- 生命周期系统链码（LSCC）

  负责为1.x版本的 Fabric 管理链码生命周期。该版本的生命周期要求在通道上实例化或升级链码。你可以阅读更多关于LSCC如何实现这一[过程](https://hyperledger-fabric-cn.readthedocs.io/zh/latest/chaincode4noah.html#chaincode-lifecycle)。如果你的 V1_4_x 或更低版本设有通道应用程序的功能，那么你也可以使用LSCC来管理链码。

- **配置系统链码（CSCC）**

  在所有 Peer 节点上运行，以处理通道配置的变化，比如策略更新。你可以在[这里](https://hyperledger-fabric-cn.readthedocs.io/zh/latest/configtx.html#configuration-updates)阅读更多 CSCC 实现的内容。

- **查询系统链码（QSCC）**

  在所有 Peer 节点上运行，以提供账本 API（应用程序编码接口），其中包括区块查询、交易查询等。你可以在交易场景[主题](https://hyperledger-fabric-cn.readthedocs.io/zh/latest/developapps/transactioncontext.html)中查阅更多这些账本 API 的信息。

- **背书系统链码（ESCC）**

  在背书节点上运行，对一个交易响应进行密码签名。你可以在[这里](https://hyperledger-fabric-cn.readthedocs.io/zh/latest/peers/peers.html#phase-1-proposal)阅读更多 ESCC 实现的内容。

- **验证系统链码（VSCC）**

  验证一个交易，包括检查背书策略和读写集版本。你可以在[这里](https://hyperledger-fabric-cn.readthedocs.io/zh/latest/peers/peers.html#phase-3-validation)阅读更多 LSCC 实现的内容。

只有底层的 Fabric  开发人员和管理员可以根据自己的需要修改这些系统链码。



### 更多信息

- [链码命名空间](https://hyperledger-fabric-cn.readthedocs.io/zh/latest/developapps/chaincodenamespace.html)
- [链码操作者教程](https://hyperledger-fabric-cn.readthedocs.io/zh/latest/chaincode4noah.html#chaincode-lifecycle)
- [通道配置（configtx）](https://hyperledger-fabric-cn.readthedocs.io/zh/latest/configtx.html#configuration-updates)



## 链码生存周期

- 可以通过创建新通道并将通道功能设置为V2.0来使用Fabric链码生命周期。<br>同时，在V2.0的通道上无法使用旧命令安装，实例化或更新链码。<br>但仍然可以调用之前安装过的链码。



### 安装与定义流程

链码生命周期要求组织同意定义链码的参数，例如名称，版本和链码背书策略。

通道成员通过以下四个步骤达成协议。并非一个通道上的每个组织都需要完成每个步骤。

1. `package`**打包链码**

   可以由**某个**组织完成此步骤。

2. `install`**在您的对等方上安装链码**

   **每个**将使用链码来认可交易或查询分类帐的组织**对等方**都需要完成此步骤。

3. `approval`**批准组织的链码定义**

   **每个**将使用链码的**组织**都需要完成此步骤。

   链码定义需要得到足够多的组织的批准，才能满足通道的生命周期背书策略（默认是多数节点批准），然后才能在频道上启动链码。

4. `commit`**将链码定义提交到通道**

   一旦批准了渠道上所需数目的组织，提交事务就需要**由一个组织提交**。提交者首先从已经批准的组织的足够的同龄人那里收集认可，然后提交交易以提交链码定义。



#### 第一步：打包

链码必须先包装在tar文件中，然后才能安装在对等方上。

- 链码需要打包在tar文件中，并以`.tar.gz`文件扩展名结尾。

- tar文件需要包含两个文件：一个元数据文件`metadata.json`和另一个包含链码文件的`code.tar.gz`。

  - `metadata.json`包含用于指定链码语言，代码路径和程序包标签的JSON。

  ```shell
  $ tar -tvf sc.tar.gz
  -rw-r--r-- 0/0             118 1970-01-01 08:00 metadata.json
  -rw-r--r-- 0/0         2633369 1970-01-01 08:00 code.tar.gz
  
  $ cat metadata.json | jq .
  {
    "path": "sc",
    "type": "golang",
    "label": "sc_1.0"
  }
  
  $ tar tvf code.tar.gz
  drwxr-xr-x 500/500           0 1970-01-01 08:00 src/
  -rw-r--r-- 500/500          81 1970-01-01 08:00 src/go.mod
  -rw-r--r-- 500/500       13481 1970-01-01 08:00 src/go.sum
  -rw-r--r-- 500/500    15570905 1970-01-01 08:00 src/sc
  -rw-r--r-- 500/500        2158 1970-01-01 08:00 src/sc.go
  ```

  

#### 第二步：安装

- 你需要在将执行和认可交易的**每个对等方上安装**chaincode软件包。

- 同时需要使用**Peer 管理员**完成此步骤。

- 成功的安装命令将返回一个**链码软件包标识符`Package ID`**，该标识符是软件包标签和软件包的哈希值。

  ```shell
  basic_1.0:4ec191e793b27e953ff2ede5a8bcc63152cecb1e4c3f301a26e22692c61967ad
  ```



#### 第三步：批准

通道成员批准链码定义的行为，可视为组织对链码参数的投票。目的是允许通道成员， 在通道上使用链码之前，对链码定义达成共识。

链码定义包括以下参数，这些参数在组织之间必须保持一致：

- **Name：**应用程序在调用链码时将使用的名称。

- **Version：**版本号。

  - 如果升级链码二进制文件，则还需要更改链码版本。

- **Sequence：**定义链码的次数。

  - 该值是一个整数，用于跟踪链码升级。例如，当您第一次安装并批准链码定义时，序列号将为1。下次升级链码时，序列号将增加为2。

- **Endorsement Policy 背书策略：**定义了哪些组织需要执行和验证交易输出。

  - 背书策略可以是传递给CLI的参数，也可以引用通道配置`configtx.yaml`中的策略。

  - 默认情况下，背书策略设置为`Channel/Application/Endorsement`，默认情况下要求渠道中的大多数组织对交易进行背书。

    ```yaml
    Application: &ApplicationDefaults
    
        # Policies defines the set of policies at this level of the config tree
        # For Application policies, their canonical path is
        #   /Channel/Application/<PolicyName>
        Policies:
            Readers:
                Type: ImplicitMeta
                Rule: "ANY Readers"
            Writers:
                Type: ImplicitMeta
                Rule: "ANY Writers"
            Admins:
                Type: ImplicitMeta
                Rule: "MAJORITY Admins"
            LifecycleEndorsement:
                Type: ImplicitMeta
                Rule: "MAJORITY Endorsement"
            Endorsement:
                Type: ImplicitMeta
                Rule: "MAJORITY Endorsement"
    
    ```

- **Collection Configuration 集合配置：**与您的链码关联的私有数据集合定义文件的路径。

- **ESCC / VSCC插件：**此链码将使用的自定义背书或验证插件的名称。

- **Initialization 初始化：**

  - 如果使用Shim API提供的底层API，则您的链码需要包含一个`Init`用于初始化链码的函数。该功能是chaincode接口所必需的，但不一定需要由您的应用程序调用。批准链码定义时，可以指定是否`Init`必须在调用之前调用。如果指定了此`Init`要求，Fabric将确保在`Init` 调用链码中的任何其他函数之前先调用该函数，并且仅调用一次。请求执行`Init`功能使您可以实现在初始化链码时运行的逻辑，例如，设置一些初始状态。每次链码版本号升级时，都要初始化链码，递增版本的链码定义表明`Init`是必需的。

  - 如果使用的是peer CLI，则可以使用`--init-required`在批准并提交链码定义时，指示`Init` 必须调用该函数来初始化新的链码版本。若要使用peer CLI调用`Init`，可以在`peer chaincode invoke`命令后添加`--isInit`。

  - 如果您使用的是Contract API，则无需`Init` 在链码中包含方法。但是，您仍然可以使用该`--init-required`标志来请求通过应用程序的调用来初始化链码。如果使用`--init-required`标志，则需要在每次增加链码版本时将`--isInit`标志或参数传递给链码调用，以初始化链码。您可以使用链码中的任何函数来传递和初始化链码，一般是`InitLedger`。

批准链码定义的参数还包括**Package Identifier**，用以识别要批准的包。包ID不必对于所有组织都相同。组织可以批准链码定义，而无需安装链码包或在定义中包括标识符。



**批准链码定义的流程**：

1. 该批准需要由您的**组织管理员**提交给排序服务，然后再分发给所有peer。
2. 成功提交批准交易后，**批准的定义将存储在一个集合中**，该集合可供组织的所有对等方使用。

因此，即使您有多个对等方，您也**只需要为组织批准一次链码**。

![批准链码定义](https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/Lifecycle-approve.png)

*Org1和Org2的组织管理员为他们的组织批准MYCC的链码定义。链码定义包括链码名称，版本和认可策略以及其他字段。由于两个组织都将使用链码来认可交易，因此两个组织的批准定义都需要包括packageID。*



#### 第四步：提交链码定义给通道

- 一旦足够数量的成员批准了链码定义，则**一个组织**可以将定义提交给通道。
- 您可以使用 `checkcommitreadiness`命令检查哪个通道成员批准了链码定义。



**提交定义的步骤**

1. 首先将提交链码定义的交易提案发送给对等方；

2. 对等方查询链码定义，并在其组织批准的情况下背书该定义；
3. 然后，以**组织管理员**身份，将背书的交易提交给排序服务；
4. 排序服务将链码定义**提交给通道**。



1. 在将定义成功提交到渠道之前，需要批准组织的数量由 `Channel/Application/LifecycleEndorsement`策略控制。
   - 默认情况下，此策略要求渠道中的大多数组织都认可该交易，属于**隐元策略**。  

2. `LifecycleEndorsement`策略与链码认可策略`Endorsement`是不同的。
   - 例如，即使链码认可策略仅需要一个或两个组织的签名，但默认大多数渠道成员仍需要首先批准链码定义。
3. 还可以将`Channel/Application/LifecycleEndorsement`策略设置为**签名策略**，并在通道上显式指定可以批准链码定义的组织集。
   - 这使您可以创建一个通道，由一定数量的组织充当链码管理员，并管理该通道使用的业务逻辑。
   - 如果您的频道有大量的Idemix组织（身份混合，Identity Mix），它们不能批准链码定义或认可链码，设置签名策略可能阻止通道占多数（没看懂原文`which cannot approve chaincode definitions or endorse chaincode and may prevent the channel from reaching a majority as a result.`）。

![将链码定义提交给通道](https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/Lifecycle-commit.png)



**注意**

- 组织可以批准链码定义而不安装链码包。如果组织不需要使用链码，则他们可以批准没有包标识符的链码定义，以确保满足`Lifecycle Endorsement`的默认隐元策略。
- 在将链代码定义**提交后**，链码容器将在已安装链码的所有对等方上启动。启动chaincode容器可能需要几分钟。

![在频道上启动链码](https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/Lifecycle-start.png)





### 升级链码流程

升级链码的生命周期与安装和启动链码相同。你可以升级链码二进制文件，或仅更新链码策略。

1. **重新打包链码：**仅在升级链码二进制文件时才需要完成此步骤。

   ![重新包装chaincode包](https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/Lifecycle-upgrade-package.png)

   

2. **在对等方上安装新的chaincode软件包：**再次，如果要升级chaincode二进制文件，则仅需要完成此步骤。安装新的chaincode软件包将生成一个软件**包ID**，您需要将其传递给新的chaincode定义。您还需要**更改链码版本**，生命周期流程将使用它来跟踪链码二进制文件是否已升级。

   ![重新安装chaincode包](https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/Lifecycle-upgrade-install.png)

   *Org1和Org2在同级上安装新软件包。安装将创建一个新的packageID。*

3. **批准新的链码定义：**

   - 如果要升级链码二进制文件，则需要更新链码定义中的**链码版本**和**程序包ID**。
   - 若更新链码认可策略，则不必重新打包链码二进制文件。通道成员只需要批准新政策的定义。新定义需要将定义中的**序列**变量加1。

   ![批准新的链码定义](https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/Lifecycle-upgrade-approve.png)

   *Org1和Org2的组织管理员为各自的组织批准新的链码定义。新定义引用了新的packageID并更改了链码版本。由于这是链码的第一次更新，因此序列从一递增到二。*

4. **将定义提交给渠道：**当足够数量的渠道成员批准了新的链码定义时，一个组织可以提交新定义以将链码定义升级到渠道。作为生命周期过程的一部分，没有单独的升级命令。

   ![向频道提交新定义](https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/Lifecycle-upgrade-commit.png)

   *来自Org1或Org2的组织管理员将新的链码定义提交到通道。*

- 提交链码定义后，将使用升级的链码二进制文件中的代码启动新的链码容器。
- 如果在不更改链码版本的情况下更新了链码定义，则链码容器将保持不变，并且您无需调用`Init`函数。

![升级链码](https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/Lifecycle-upgrade-start.png)

*将新定义提交到通道后，每个对等方将自动启动新的chaincode容器。*



**注意**

- 链码生命周期使用链码定义中的**序列**来跟踪升级。所有通道成员都需要将序列号增加一个，并批准新的定义以升级链码。
- 而**版本参数**用于跟踪链码二进制文件，**仅在升级链码二进制文件时才需要更改**。



### 其他部署方案的流程

以下示例说明了如何使用Fabric链码生命周期来管理通道和链码。



#### 新组织加入频道

新的组织可以使用已定义的链码加入频道，并在**安装**链码包并**批准**已经提交（注意不用再次提交）给该频道的链码定义后开始使用链码。

![批准链码定义](https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/Lifecycle-join-approve.png)

*Org3加入频道并批准先前由Org1和Org2提交给频道的相同链码定义。*

批准链码定义后，新组织可以在将软件包安装到对等方后开始使用链码。该定义不需要再次提交。如果将背书策略设置为默认策略，需要大多数渠道成员的背书，则背书策略将自动更新以包括新组织。

![启动链码](https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/Lifecycle-join-start.png)

*链码容器将在Org3对等体上首次调用链码后启动。*



#### 更新背书政策

您可以使用链码定义来更新背书策略，而不必重新打包或重新安装链码。

通道成员可以**批准**带有新认可策略的链码定义，并将其**提交**给渠道。

![批准新的链码定义](https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/Lifecycle-endorsement-approve.png)

*Org1，Org2和Org3批准了一项新的认可政策，要求所有三个组织都认可一项交易。它们将定义序列从一增加到两，但是不需要更新链码版本。*

新的认可政策将在将新定义提交给渠道后生效。通道成员不必通过调用链码或执行`Init`功能来重启链码容器即可更新背书策略。

![提交新的链码定义](https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/Lifecycle-endorsement-commit.png)

*一个组织将新的链码定义提交给渠道以更新认可策略。*



#### 批准定义而不安装链码的情况

您可以批准链码定义而不安装链码包。

即使不想使用某链码，由于默认的`LifecycleEndorsement`隐元策略，大多数节点需要批准该链码。

您需要批准与通道的其他成员相同的参数，但是不需要将packageID包含在链码定义中。

![Org3不安装链码](https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/Lifecycle-no-package.png)

*Org3不会安装chaincode软件包。结果，他们不需要提供packageID作为链码定义的一部分。但是，Org3仍然可以认可已提交给该频道的MYCC的定义。*



#### 某组织不批准链码定义的情况

不批准已提交给渠道的链码定义的组织不能使用链码。未批准链码定义的组织将无法在其对等方上执行链码。

![Org3对Chaincode持不同意见](https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/Lifecycle-one-disagrees.png)

*Org3批准的链码定义具有与Org1和Org2不同的认可策略。结果，Org3无法在通道上使用MYCC链码。但是，Org1或Org2仍然可以获得足够的认可，以将定义提交到通道并使用链码。链码中的交易仍将添加到分类帐中并存储在Org3对等项中。但是，Org3将无法认可交易。*

组织可以批准具有任何序列号或版本的新链码定义。这使您可以批准已提交给通道的定义并开始使用链码。您也可以批准新的链码定义，以更正在批准或打包链码过程中犯的任何错误。



#### 链码定义未通过批准策略的情况

如果渠道上的组织不同意链码定义，则无法将该定义提交给渠道。任何频道成员都将无法使用链码。

![多数人不同意上链代码](https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/Lifecycle-majority-disagree.png)

*Org1，Org2和Org3都认可不同的链码定义。结果，该频道的任何成员都无法获得足够的认可以将链码定义提交给该频道。任何频道成员都无法使用链码。*



#### 组织安装不同的链码包ID的情况

每个组织在批准链码定义时都可以使用不同的packageID。

这允许通道成员安装不同链码二进制文件，但使用相同背书策略，并在同一链码命名空间中读写数据。

组织可以使用此功能来安装包含其组织的特定业务逻辑的智能合约。

![使用不同的chaincode二进制文件](https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/Lifecycle-binaries.png)

*Org1和Org2每个都安装MYCC链码的版本，其中包含特定于其组织的业务逻辑。*



#### 使用一个包创建多个链码的情况

您可以通过批准并提交多个链码定义来使用一个链码包在通道上创建多个链码实例。每个定义都需要指定一个不同的链码名称。这使您可以在一个通道上运行智能合约的多个实例，但是要让合约遵循不同的背书策略。

![启动多个链码](https://hyperledger-fabric.readthedocs.io/en/release-2.2/_images/Lifecycle-multiple.png)

*Org1和Org2使用MYCC_1链码包来批准和提交两个不同的链码定义。结果，两个对等方都在其对等方上运行了两个chaincode容器。MYCC1的背书政策为2分之一，而MYCC2的背书政策为2分之2。*





## 私有数据







## 通道功能 Capabilities

Capabilities 使运行在不同版本级别的节点能够在给定特定块高度的通道配置时，以一种兼容和一致的方式运行。



### 节点版本与功能版本

功能遵循与 Fabric 发行版和二进制程序相同的版本控制约定。有v1.1功能、v1.2功能和2.0功能，等等。但有必要注意几个区别。

- **每个发行版不一定都用新的功能级别。**  

  - 建立新功能的需求取决于具体情况，并且主要取决于新功能和较旧的二进制版本的向后兼容性。 

  - 例如，在v1.4.1中添加Raft订购服务不会改变处理交易或订购服务功能的方式，因此不需要建立任何新功能。  
  - 另一方面，v1.2之前的对等方无法处理私有数据，因此需要建立v1.2能力级别。  
  - 由于并非每个版本都包含改变交易处理方式的新功能（或错误修复），因此某些版本将不需要任何新功能（例如，v1.4），而其他版本仅具有特定级别的新功能（例如 作为v1.2和v1.3）。

 

- **节点必须至少处于通道中某些功能的级别**。  
  - 当对等方加入通道时，它将顺序读取账本中的所有模块，从通道的创始模块开始，一直到交易模块和所有后续配置模块。  
  - 如果某个节点（例如对等节点）尝试读取包含对其不了解的功能的更新的块（例如，v1.4.x对等节点试图读取包含v2.0应用程序功能的块）会崩溃。 这种崩溃行为是故意的，因为v1.4.x对等点不应尝试验证或提交任何超过此时间点的事务。  
  - 加入通道之前，请确保该节点至少是与该节点相关的通道配置中指定的功能的结构版本（二进制）级别。 稍后我们将讨论哪些功能与哪些节点相关。  但是，由于没有用户希望其节点崩溃，因此强烈建议在尝试更新功能之前将所有节点更新到所需级别（最好更新到最新版本）。  这符合默认的Fabric建议，始终保持最新的二进制和功能级别。
