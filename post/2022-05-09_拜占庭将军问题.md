可靠的计算机系统必须处理故障组件，这些组件会向系统的不同部分提供相互冲突的信息。这种组件故障的情形可以抽象地表达为一群拜占庭军队的将军和他们的部队在敌城周围扎营。将军们只能通过信使交流，必须就共同的作战计划达成一致。然而他们中的一个或多个可能是试图混淆信息的叛徒。本文的目的是要找到一种算法来确保忠诚的将军们达成一致。结果表明，若仅使用口头信息，当且仅当三分之二以上的将军忠诚时，这个问题才可以解决；所以一个叛徒可以混淆两个忠诚的将军。若使用不可伪造的证书，任何数量的将军和可能的叛徒构成的问题都可以被解决。最后本文讨论了解决方案在可靠计算机系统中的应用。

  

# 1   引言

一个可靠的计算机系统必须能够应对其一个或多个组件的故障。一个失败的组件可能会表现出一种常常被忽视的行为，即向系统的不同部分发送相互冲突的信息。应对这种类型的故障的问题被抽象地表达为拜占庭将军问题。我们将在本文的主要部分讨论这个抽象的问题，最后提出一个如何实现可靠计算机系统的解决方案。

我们设想，拜占庭军队的几个师在敌人的城市外扎营，每个师由自己的将军指挥。将军们只能通过信使相互沟通。在观察了敌人之后，他们必须决定一个共同的行动计划。然而，其中有些将军可能是叛徒，他们试图阻止忠诚的将军们达成协议。将军们必须有一个算法来保证：

A. 所有忠诚的将军们都将会采取同样的行动计划。

​	忠诚的将军们都会按照算法所说的去做，但叛徒们可以做任何他们想做的事。无论叛徒做什么，该算法必须保证条件A。

​	忠诚的将军们不仅应该达成协议，而且应该能够互相商定一个合理的计划。

B. 少量的叛徒不能使忠诚的将军们采取一个糟糕的计划。

​	条件B很难正规化，因为它需要准确地说出什么是坏计划。但我们并不试图这样做。相反，我们考虑的是将军们如何达成协定。每个将军都在观察敌人，并将他的观察结果传达给其他人。设v(i)为第i位将军所传达的信息。每个将军都使用某种方法将v(l)，......，v(n)的值合并为一个单一的行动计划，其中n是将军的数量。条件A的实现需要通过让所有将军使用相同的方法组合信息，条件B的实现需要通过使用鲁棒性的方法。例如，如果要做出的唯一决定是进攻还是撤退，那么v(i)可以是第i位将军认为哪种方案最好的意见，最终决定可以基于他们之间的多数票。只有忠诚的将军们在两种可能性之间几乎平分秋色的情况下，少量的叛徒才能影响决定，在这种情况下，两种决定都不能称为坏决定。

​	虽然这种方法可能不是满足条件A和B的唯一方法，但它是我们所知的唯一方法。它假设了一种方法，由第i位将军通过信使将v(i)发送给其他将军，让将军们彼此交流他们的值v(i)。然而，这并不可行，因为满足条件A要求每个忠诚的将军都获得相同的值v(l),....，v(n)， 而一个叛徒可能向不同的将军发送不同的数值。为了满足条件A，以下情况必须为真。

1）每个忠诚的将军必须获得相同的信息v(l), ..., v(n)。

​	条件1意味着将军不一定使用直接从第i位将军那里得到的v(i)的值，因为如果第i位将军是叛徒，那么他可能会向不同的将军发送不同的值。这意味着我们可能会引入这样一种可能性，即将军们使用的v(i)值与第i位将军发送的值不同——即使第i位将军是忠诚的。如果要满足条件B，我们决不能允许这种情况发生。例如，如果每个忠诚的将军都发送“进攻”的值，我们不能允许少数叛徒的存在导致忠诚的将军将他们的决定建立在“撤退”，......，“撤退”的v(i)值上。因此，我们对每个i有如下要求。

2）如果第i个将军是忠诚的，那么他发送的值必须被每个忠诚的将军接受为v(i) 的值。

​	我们可以将条件1改写为：

1’）对于每一个i（无论第i个将军是否忠诚），任何两个忠诚的将军都使用相同的v(i)值。

条件1’和2都是关于第1位将军发送的单一意见值的条件。因此，我们可以将我们的考虑限制在一个单一的将军如何将他的值发送给其他人的问题上。接下来，我们将用一个指挥官向他的中尉发送命令的方式来表述这个问题，得到以下问题。

***\*拜占庭将军问题\****。一位指挥官向他的n-1名中尉发出命令，保证使得：

IC1. 所有忠诚的中尉都服从同一个命令。

IC2. 如果指挥官是忠诚的，那么每个忠诚的中尉都会服从他发出的命令。

条件IC1和IC2被称为互动一致性条件。请注意，如果指挥官是忠诚的，那么IC1就来自于IC2。然而，指挥官不一定是忠诚的。

为了解决我们最初的问题，第i位将军通过使用拜占庭将军问题的解决方案来发送他的值v(i)，以便传达 “使用v(i)作为我的意见”的命令，其他将军充当中尉。

# 2   不可能的结果

拜占庭将军问题似乎很简单。它的难度体现在一个令人惊讶的事实上：如果将军们只能发送口头信息，那么除非有三分之二以上的将军是忠诚的，否则任何解决方案都不会成功。特别地，如果只有三个将军，在有一个叛徒的情况下，任何解决方案都无法奏效。口头信息是指其内容完全由发送者控制的信息，因此作为叛徒的发送者可以发送任何可能的信息。这样的信息对应于计算机通常相互发送的信息类型。在第4节中，我们考虑有签名的书面信息，对于这些信息类型来说，上述口头信息的结论是不正确的。

我们现在讨论，在口头信息的情况下，三个将军的解决方案都无法处理一个叛徒。为了简单起见，我们考虑唯一可能的决定是“进攻”或“撤退”。让我们先看看图1中的情景，在这种情况下，指挥官是忠诚的，并发出了“进攻”的命令，但中尉2是一个叛徒，他向中尉1报告说他收到了“撤退”的命令。为了达成IC2的条件，中尉1必须服从攻击的命令。

<div style="text-align:center">
<img alt="byzantine-lieutenant-traitor-2" src="/static/image/2022-05-09/byzantine-lieutenant-traitor-2.jpeg" />
<p>Fig. 1. Lieutenant 2 a traitor</p>
<p>图1 中尉2是叛徒</p>
</div>


现在考虑另一种情况，如图2所示，指挥官是个叛徒，他向中尉1发出了“攻击”命令，向中尉2发出了“撤退”命令。中尉1不知道谁是叛徒，他也无法知道指挥官究竟向中尉2发送了什么信息。因此，这两张图片中的情景在中尉1看来是完全一样的。如果叛徒一直在撒谎，那么中尉1就没有办法区分这两种情况，所以他必须服从这两种情况下的“攻击”命令。因此，只要中尉1收到指挥官的“攻击”命令，他就必须服从。

<div style="text-align:center">
<img alt="byzantine-commander-traitor" src="/static/image/2022-05-09/byzantine-commander-traitor.jpeg" />
<p>Fig. 2. The commander a traitor</p>
<p>图2 将军是叛徒</p>
</div>



​	然而，类似的论证表明，如果中尉2收到指挥官的“撤退”命令，那么他必须服从，即使中尉1告诉他指挥官说“进攻”。因此，在图2的情况下，中尉2必须服从“撤退”命令，而中尉1则服从“进攻”命令，从而违反了条件IC1。因此，在有一个叛徒的情况下，不存在对三个将军有效的解决方案。

​	这个论证可能看起来很有说服力，但我们强烈建议读者对这种非严谨的推理持怀疑态度。尽管这个结果确实是正确的，但我们早已看过一些类似同样可信的无效结果的“证明”。我们知道，在计算机科学或数学领域，没有哪个领域的非正式推理比研究这种类型的算法更容易导致错误。关于这种带单一叛徒的三将军问题不可解的严格证明，我们请读者参考[3]。

​	利用这个结果，我们可以证明，少于3m+1个将军的解决方案都无法应对m个叛徒。证明方法是通过反证法——我们假设存在上述问题的解，然后用它来构建带单一叛徒的三将军解，虽然我们知道这是不可能存在的。为了避免这两种解之间的混淆，我们把刚刚假设的解决方案中的将军称为阿尔巴尼亚（Albanian）将军，而把构建出的解中的将军称为拜占庭将军。于是，从一个允许3m个或更少的阿尔巴尼亚将军应付m个叛徒的算法开始，我们构建一个允许3个拜占庭将军处理一个叛徒的解决方案。

​	构造三将军的解决方案是这样的：通过让每个拜占庭将军模拟大约三分之一的阿尔巴尼亚将军，从而使每个拜占庭将军最多模拟m个阿尔巴尼亚将军。其中，拜占庭指挥官模拟阿尔巴尼亚指挥官和最多m-I名阿尔巴尼亚中尉，而剩下两名拜占庭中尉中的每一人最多模拟m名阿尔巴尼亚中尉。由于只有一个拜占庭将军可能是叛徒，而他最多模拟m个阿尔巴尼亚人，所以最多m个阿尔巴尼亚将军是叛徒。因此，假设的解决方案保证了IC1和IC2对阿尔巴尼亚将军来说是成立的。根据IC1，所有被忠诚的拜占庭中尉模拟的阿尔巴尼亚中尉都服从同一个命令，这是他要服从的命令。很容易检查出，阿尔巴尼亚将军解决方案的条件IC1和IC2意味着拜占庭将军的相应条件，所以我们已经构建了所需的不可能解。

​	人们可能认为，解决拜占庭将军问题的困难源于达成精确一致的要求。现在我们通过证明达成近似一致和达成精确一致一样难，来证明情况并非如此。让我们假设，将军们不是试图就精确的作战计划达成一致，而是必须只就攻击的大致时间达成一致。更确切地说，我们假设指挥官命令进攻的时间，并且我们要求以下两个条件成立。

​	IC1'. 所有忠诚的中尉在10分钟内进行攻击。

​	IC2'. 如果指挥官是忠诚的，那么每个忠诚的中尉都会在指挥官命令中给出的时间的10分钟内发动攻击。

​	(我们假设命令是在攻击前一天发出和处理的，收到命令的时间不重要，只有命令中的攻击时间才重要）。

​	与拜占庭将军问题一样，这个问题也是无法解决的，除非有三分之二以上的将军是忠诚的。我们通过以下方式证明这一点：如果存在近似一致的带一个叛徒的三将军问题的解，那么我们可以构建一个精确一致的带一个叛徒的三将军问题的解。假设指挥官希望发出"攻击"或"撤退"命令，使用假设的算法，通过发送1:00的攻击时间来命令进攻，通过发送2:00的攻击时间来命令撤退。每个中尉使用以下程序来获得他的命令。

\1) 从指挥官那里得到攻击时间后，中尉会做以下事情之一。

a) 如果时间是1:10或更早，那么就进攻。

b) 如果时间是1:50或更晚，那么就撤退。

c) 否则，继续进行步骤2)。

\2) 问另一位中尉，他在步骤1) 中达成了什么决定。

a) 如果其他中尉达成了决定，那么就做出和他一样的决定。

b) 否则，就撤退。

​	从IC2'可以看出，如果指挥官是忠诚的，那么忠诚的中尉将在步骤1中获得正确的命令，所以IC2得到满足。如果指挥官是忠诚的，那么IC1由IC2得出，所以我们只需要在指挥官是叛徒的假设下证明IC1。由于最多只有一个叛徒，这意味着两个中尉都是忠诚的。从IC1'可以看出，如果一个中尉在步骤1中决定进攻，那么另一个中尉就不能在步骤1中决定撤退。因此，要么他们都会在步骤1中做出相同的决定，要么至少有一个人将决定推迟到步骤2。在这种情况下，很容易看出他们都得出了相同的决定，所以满足IC1。因此，我们构建了一个处理一个叛徒的拜占庭将军问题的三将军解决方案，但这个解是不可能存在的。因此，我们不可能有一个在有叛徒的情况下保持IC1'和IC2'的三将军算法。

​	现在可以用让一个将军模拟其他m个将军的方法来证明，少于3m+I个将军的解决方案都无法应对m个叛徒。这个证明与最初的拜占庭将军问题的证明相似，留给读者自己去研究。

# 3   口头信息的解决方案

​	我们在上面讨论了，对于使用口头信息应对m个叛徒的拜占庭将军问题的解中必须至少有3m+1个将军。现在我们给出这个解决方案。首先，我们要明确说明我们所说的“口头信息”是什么意思。每个将军都应该执行一些涉及向其他将军发送信息的算法，我们假设一个忠诚的将军正确地执行他的算法。口头信息的定义体现在我们为将军消息系统所做的以下假设中：

​	A1. 每条被发出的信息都能被正确传达。

​	A2. 信息的接收者知道是谁发送了信息。

​	A3. 信息的缺失可以被检测到。

​	假设Al和假设A2防止叛徒干扰其他两个将军之间的交流。因为根据Al，他不能干扰他们已发送的信息。而根据A2，他不能通过伪装发送者引入虚假的信息来混淆他们的交流。假设A3将防止了叛徒试图通过简单地不发送信息来阻止决策的行为。这些假设的实际执行情况将在第6节讨论。

​	本节和下一节中的算法要求每个将军能够直接向其他将军发送消息。在第5节中，我们描述了没有这个要求的算法。

叛徒指挥官可以决定不发出任何命令。但由于中尉们必须服从一些命令，在这种情况下，他们需要一些默认命令来服从。我们让“撤退”作为这个默认命令。

​	我们归纳定义了口头信息的算法OM(m)，一个指挥官将通过该算法向n-1个副手发送命令，其中m是一个非负整数。我们将讨论OM(m)能解决3m+1或更多的将军在最多有m个叛徒的情况下的拜占庭将军问题。我们发现用中尉“获得一个值”而不是“服从一个命令”来描述这个算法更为方便。

​	该算法假设了一个函数majority，其属性是：如果大多数vi等于v，那么majority(v1,...,vn-1)等于v。 majority(v1,...,vn-1) 的值有两种中立的选择。

​	1. vi中的多数值，如果多数值存在的话，否则就是默认值。

​	2. vi中的中位数，假设它们来自一个有序的集合。

​	下面的算法只需要上述的majority属性。

​	算法OM(0)：

1） 指挥官将他的值发送给每一个中尉。

2） 每个中尉使用他从指挥官那里得到的值，如果他没有得到任何值，则使用默认值。

​	算法OM(m), m>0：

1）指挥官将他的值发送给每一个中尉。

2）对于每个i，让vi是中尉i从指挥官那里收到的值，否则如果他没有收到任何值，则为默认值。中尉i作为算法OM(m-1)中的指挥官，向其他n-2名中尉中的每个人发送值vi。

3）对于每一个i，并且每一个j!=i，让vi是中尉i在步骤2中从中尉i那里得到的值（使用算法OM(m-1)）。否则，如果他没有得到这样的值，则取默认值。中尉i使用majority(v1,...,vn-1)作为他的值。


<div style="text-align:center">
<img alt="byzantine-om1-lieutenant3-a-traitor" src="/static/image/2022-05-09/byzantine-om1-lieutenant3-a-traitor.jpeg" />
<p>Fig. 3. Algorithm OM(l); Lieutenant 3 a traitor</p>
<p>图3 算法OM(1)；中尉3是叛徒</p>
</div>


​	为了理解这个算法的工作原理，我们考虑m=1，n=4的情况。图3显示了当指挥官发送数值v，而中尉3是叛徒时，中尉2收到的信息。在OM(1)的第一步，指挥官向所有三名中尉发送了v。在第二步中，中尉1向中尉2发送数值v，使用了算法OM(0)。同样在第二步中，叛徒中尉3向中尉2发送了一些其他的值v。在第三步中，中尉2有v1=2=v和v3=x，所以他得到了正确的值v = majority(v,v,x)。

​	接下来，我们看看如果指挥官是叛徒会发生什么。图4显示了如果一个叛徒指挥官向三个中尉发送三个任意的数值x, y, z。每个中尉得到的v1=x, v2=y, v3=z，所以他们在步骤3中都得到了相同的majority(x, y, z)，不管这三个值x, y, z中是否有任何一个相等。

​	递归算法OM(m)调用算法OM(n-1)的n - 1次执行，其中每次又会调用OM(m-2)的n-2次执行，等等。这意味着，对于m>1，一个中尉向其他每个中尉发送了许多不相干的信息。必须有某种方法来区分这些不同的信息。读者可以验证，如果每个中尉i在他在步骤2中发送的值v前加上数字i，那么所有的模糊性都会被消除。随着递归的展开，算法OM(m-k)将被调用(n-1)...(n-k)次，以便发送一个以k个中尉的数字序列为前缀的值。


<div style="text-align:center">
<img alt="byzantine-om1-commander-a-traitor" src="/static/image/2022-05-09/byzantine-om1-commander-a-traitor.jpeg" />
<p>Fig. 4. Algorithm OM(l); the commander a traitor</p>
<p>图4 算法OM(1)；将军是叛徒</p>
</div>
 

​	为了证明任意m的算法OM(m)的正确性，我们首先证明以下的引理。

​	引理1. 对于任何m和k，如果有超过2k+m的将军和最多k的叛徒，算法OM(m)总满足IC2。

​	证明：证明是通过对m的归纳法进行的。IC2规定了指挥官是忠诚的。使用A1，很容易得知如果指挥官是忠诚的，算法OM(0)是有效的，所以当m=0时该定理是正确的。我们现在假设该引理对m-1且m>0是正确的，来尝试证明对m的正确性。

​	在步骤1中，忠诚的指挥官向所有n-1名中尉发送一个值v。在步骤2中，每个忠诚的中尉与n-1个将军应用OM(m-1)。由于假设n>2k+m，我们有n-1>2k+(m -1)，所以我们可以归纳假设得出结论：每个忠诚的中尉都能从每个忠诚的中尉j得到vj=v。由于最多有k个叛徒，并且n-1>2k+（m - 1）>=2k，n-1个中尉的大多数是忠诚的。因此，每个忠诚中尉的值vi都可以作为n-1个值的多数值，所以他在步骤3中得到了majority(vi,...,vn-1)=v。这证明了IC2。

以下定理断言，算法OM(m)解决了拜占庭将军问题。

定理1. 对任意的m，如果有超过3m个将军，其中最多存在m个叛徒，算法OM(m)满足条件IC1和IC2。

证明：证明是通过对m的归纳法进行的。当m为0时，则不存在叛徒，那么很容易看出OM(0)满足IC1和IC2。因此，我们假设该定理对OM(m - 1)是正确的，并对OM(m)且m > 0进行证明。

我们首先考虑指挥官是忠诚的情况。通过在引理1中取k等于m，我们看到OM(m)满足IC2。如果指挥官是忠诚的，则IC1由IC2得出，所以我们只需要在指挥官是叛徒的情况下验证IC1。

最多有m个叛徒，而指挥官是其中之一，所以最多有m-1个中尉是叛徒。因为有超过3m个将军，所以有超过3m - 1个中尉，而且3m- 1 > 3（m - 1）。因此，我们可以应用归纳假设得出结论：OM(m -1)满足条件IC1和IC2。因此，对于每一个j来说，任何两个忠诚的中尉在步骤3中都得到相同的值。(如果两个中尉中的一个是中尉j，这可以由IC2得出，否则由IC1得出）。因此，任何两个忠诚的中尉都会得到相同的值向量vi,......,Vn-1，因此，在步骤3中获得相同的majority(v1,...,vn-1)。这证明了IC1。

# 4   带签名信息的解决方案

​		正如我们从图1和图2的情景中看到的那样，正是叛徒撒谎的能力使拜占庭将军问题变得如此困难。如果我们能限制这种能力，问题就会变得更容易解决。做到这一点的一个方法是允许将军们发送不可伪造的签名信息。更确切地说，我们在Al-A3中加入以下假设。

​	A4	a)	忠诚的将军的签名是无法伪造的，对其签名信息内容的任何改动都可以被发现。

​			b) 	任何人都可以验证将军签名的真实性。

​	请注意，我们对叛国将军的签名不做任何假设。特别是，我们允许他的签名被另一个叛徒伪造，从而允许叛徒互相勾结。

​	既然我们已经引入了签名信息，我们之前讨论结果，即需要四个将军来应对一个叛徒，就不再成立了。事实上，一个三将军的解决方案确实存在。我们现在给出一个算法，可以让任何数量的将军能应对m个叛徒。（如果少于m+2个将军，这个问题是无意义的）。

​	在我们的算法中，指挥官向他的每个中尉发送一个签名的命令。然后每个中尉在该命令上加上自己的签名，并将其发送给其他中尉，其他中尉再加上自己的签名，并将其发送给其他人，以此类推。这意味着，一个中尉必须能够收到一份已签署的信息，再将其复制几份，并签署和发布这些副本。如何获得这些副本并不重要；一份消息可能是复印的，又或者一份消息可能由一组相同的待签署和发布的消息组成。

​	我们的算法假设了一个函数choice，它被应用于一组命令以便获得其中一个命令。我们对这个功能的唯一要求是：

1）如果集合V由单一元素v组成，那么choice(V)=v。

2）choice(0) = 默认值，其中0是空集。

​	请注意，choice的一个可能的定义是让choice(V)选择V的中位数——假设元素是可排序的。

​	在下面的算法中，我们让x:i表示由i将军签署的值x，因此，v:j:i表示由j签署的值v，然后由i签署的那个值v:j。我们让将军0作为指挥官。在这个算法中，每个中尉i保持一个集合Vi，包含他到目前为止所收到的正确签署的命令的集合。(如果指挥官是忠诚的，那么这个集合就不应该包含超过一个元素）。不要把收到的命令的集合Vi，与所收到的信息的集合相混淆。可能会有许多不同的消息与同一命令。

​	算法SM(m)。

​	最初Vi=0。

1）指挥官签署并将其价值发送给每个中尉。

2）对于每个i：

a) 如果中尉i从指挥官那里收到一个形式为v:0的信息，并且他还没有收到任何命令，那么

i. 他让Vi等于{v}。

ii. 他把信息v:0:i发送给其他每个中尉。

b) 如果中尉i收到一个形式为v:j1:...:jk，并且v不在集合中。那么，Vi

i. 他把v加到Vi。

ii. 如果k<m，那么他将信息v:j1:...:jk:i发送给除j1,...,jk以外的每个中尉。

​	3）对于每一个i：当中尉i将不再收到任何信息时，他将服从命令choice(Vi)。

​	注意，在步骤2中，中尉i会忽略任何包含已经在集合Vi中的命令v的消息。

​	我们还没有说明中尉在步骤3中如何确定他不会再收到信息。通过对k的归纳，我们很容易发现，对于每个中尉序列j1,...,jk，k<=m，一个中尉在步骤2中最多只能收到一条v:0:j1:...:jk的信息。如果我们要求中尉jk要么发送这样的信息，要么发送信息报告他不会发送这样的信息，那么就很容易判断何时能收到所有信息。(根据假设A3，一个中尉可以确定一个叛徒中尉jk是否都不发送这两条信息）。另外，可以用超时来确定何时不再有消息到达。第6节将讨论超时的使用。

​	请注意，在步骤2中，中尉i会忽略任何不具有正确签名形式的信息。如果使用相同消息的数据包来避免复制消息，则此方法会丢弃一个不包含足够数量的相同、正确签名的消息的数据包。(如果消息被k个中尉签署，应该有(n - k - 2)(n - k - 3) ... (n - m - 2)份副本)。


<div style="text-align:center">
<img alt="byzantine-sm1-commander-a-traitor" src="/static/image/2022-05-09/byzantine-sm1-commander-a-traitor.jpeg" />
<p>Fig. 5. Algorithm SM(l); the commander a traitor</p>
<p>图5 算法SM(1)；将军是叛徒</p>
</div>



​	图5说明了当指挥官是叛徒时三个将军的情况下的算法SM(l)。指挥官向一名中尉发出"攻击"命令，向另一名中尉发出"撤退"命令。两个中尉在步骤2中都收到了这两个命令，所以在步骤2之后，V1=V2={"进攻"，"撤退"}，他们都服从命令choice({"attack"，"retreat"})。请注意，这里与图2的情况不同，中尉们知道指挥官是个叛徒，因为他的签名出现在两个不同的命令上，A4规定只有指挥官才能产生这个签名。

​	在算法SM(m)中，一名中尉签署他的名字以确认他收到了一个命令。 如果他是第m个在命令上签名的中尉，那么这个签名就不会被其接收者转达给其他人，所以它是多余的。(更确切地说，假设A2使其成为不必要的。)特别是，中尉们不需要在SM(l)中签署他们的信息。

​	我们现在证明我们算法的正确性。

​	定理2.对于任何m，如果有最多m个叛徒，算法SM（m）就能解决拜占庭将军问题。

​	证明。我们首先证明IC2。如果指挥官是忠诚的，那么他在步骤1中向每个中尉发送了他签署的命令v:0。因此，每个忠诚的中尉都会在步骤2a中收到命令v。此外，由于没有一个叛徒中尉可以伪造任何其他形式的v':0的信息，忠诚的中尉在步骤2b中不能收到额外的命令。因此，对于每个忠诚的中尉i来说，在步骤2中得到的集合Vi包括单一的命令v，根据choice函数的属性1，该中尉将在步骤3中服从此命令。这证明了IC2。

​	由于如果指挥官是忠诚的，IC1由IC2得出。为了完整证明IC1，我们只需要考虑指挥官是叛徒的情况。如果两个忠诚的中尉i和j在步骤3中接受的命令集Vi和Vj是相同的，那么他们在步骤2中就会服从同一个命令。因此，要证明IC1，只需证明，如果i在步骤2中把一个命令v放入Vi，那么j在步骤2中必须把同样的命令v放入Vj。要做到这一点，我们必须证明j收到一个包含该命令的正确签名的消息。如果i在步骤2a中收到命令v，那么他在步骤2a.ii中把它发送给j；所以j收到了它（通过Al）。如果i在步骤2b中将该命令添加到Vi中，那么他必须首先收到形式为v:0:j1:...:jk的消息。如果j是其中一个jr，那么根据A4，他一定已经接受了命令v。如果没有，我们考虑下面两种情况：

1）k<m。在这种情况下，i向j发送了信息v:0:j1:...:jk:i，所以j一定会接收命令v。

2）由于指挥官是个叛徒，所以最多只有m-1个中尉是叛徒。因此，至少有一名中尉j1,...,jm是忠诚的。这个忠诚的中尉在第一次收到命令v时，一定向j发送过这个命令，因此j一定会收到这个值。

​	这就完成了证明。

# 5   缺少通信路径

到目前为止，我们假设一个将军可以直接向其他每个将军发送信息。现在我们假设物理线路对发送信息有一些限制。我们认为将军们构成了一个简单有限无向图G的节点，其中两个节点之间的弧表示这两个将军可以彼此直接发送消息。我们现在将原本只支持完全图G的算法OM(m)和SM(m)扩展到更一般的图。

​	为了扩展我们的口头信息算法OM(m)，我们需要以下定义。如果两个将军被弧线连接，说他们是邻居。

​	定义1.

a) 一组节点{i1,...,ip}被称为是一个节点的正则邻居集i，如果：

i. 每个i1都是i的邻居，并且

ii. 对于任何不同于i的k，存在从ij节点不经过i到达k的路径Yj,k，同时任何两个不同的路径Yj ,k除了k之外没有共同的节点。

b) 如果每个节点都有一个由p个不同的节点组成的正则邻居集，则称图G是p-正则的。


<div style="text-align:center">
<img alt="byzantine-a-3-regular-graph" src="/static/image/2022-05-09/byzantine-a-3-regular-graph.jpeg" />
<p>Fig. 6. A 3-regular graph</p>
<p>图6 一个3-正则图</p>
</div>

<div style="text-align:center">
<img alt="byzantine-a-graph-not-3-regular.jpeg" src="/static/image/2022-05-09/byzantine-a-graph-not-3-regular.jpeg.jpeg" />
<p>Fig. 7. A graph that is not 3-regular</p>
<p>图7 一个非3-正则图</p>
</div>



图6是一个简单的3-正则图的例子。图7显示了一个非3-正则图的例子，因为中心节点的正则邻居集并非包含三个节点。

​	我们将OM(m)扩展为一种算法，如果将军图G是3m-正则的，那么在有m 个叛徒的情况下可以解决拜占庭将军问题。(注意，一个3m-正则的图至少包含3m+1个节点。)对于所有正整数m和p，当将军图G是p-正则的时候，我们对算法OM(m,p)定义如下。（如果G不是p-正则的，那么OM(m, p)就没有定义。）该定义使用对m的归纳法。

​	算法OM(m,p)。

\1) 选择一个由p个中尉组成的指挥官的正则邻居集N。

\2) 指挥官将他的值发送给N集合中的每个中尉。

\3) 对于N中的每一个i，设vi是中尉i从指挥官那里得到的值，如果他没有得到任何值，则认为获得默认值。中尉i向其他每个中尉k发送vi，具体如下。

a) 如果m=1，那么通过沿路径yi,k发送数值。这个路径的存在性是由定义1的a.ii部分保证。

b) 如果m>1，那么通过在删除原指挥官的图中，充当指挥官执行算法OM(m-1,p-1)。

\4) 对于每一个k，以及N中的每一个不等于k的i，让vi是中尉k在步骤2中从中尉i那里得到的值

​	如果他没有得到任何值，则取默认值。中尉k使用值 majority(vi1, ... ,vip)，其中N = {i1,..., ip}。

​	请注意，从一个p-正则图中删除一个节点，会留下一个(p-1)-正则图。因此，我们可以在步骤2b中应用算法OM(m - 1, p - 1)。

我们现在证明OM(m,3m)解决了拜占庭将军问题，如果有最多m个叛徒的话。该证明与OM(m)算法的证明类似，下面只是略加说明。它从以下对引理1的扩展开始。

​	引理2. 对于任何m>0和任何p>=2k+m，如果有最多k个叛徒，算法OM（m，p）满足IC2。

​	证明：对于m=1，观察可知，一个中尉获得的值是 majority(v1,...,vp)，其中每个vi是由指挥官沿着与发送其他值的路径不相交的路径发送给他的值。由于最多有k个叛徒，p>=2k+1，这些路径中有一半以上完全由忠诚的中尉组成。因此，如果指挥官是忠诚的，那么大多数的的值vi将等于他发送的值，这意味着IC2被满足。

​	如果指挥官是忠诚的，那么N个中尉中的每一个都会得到正确的值。由于p>2k，他们中的大多数是忠诚的，根据归纳假设，他们中的每个人都向每个忠诚的中尉发送了正确的值。因此，每个忠诚的中尉都能得到大多数正确的值，从而获得步骤3中的正确值。

​	算法OM(m, 3m)的正确性是以下定理的直接结果。

​	定理3. 对于任何m>0和任何p>=3m，如果有最多m个叛徒，算法OM(m,p)就能解决拜占庭将军问题。

​	证明：根据定理2，让k=m，我们看到OM(m,p)满足IC2。如果指挥官是忠诚的，那么ICI由IC2得出，所以我们只需要在指挥官是叛徒的假设下证明IC1。为了做到这一点，我们证明每个忠诚的中尉都会在步骤3中得到相同的价值集合vi。如果m=I，那么这就意味着，所有的中尉，包括N中的中尉，都是忠诚的，而且路径yi,k不经过司令官。对于m>1，可以做一个简单的归纳论证，因为p>=3m意味着p-1>=3(m-1)。

我们对算法OM(m)的扩展要求图G是3m-正则的，这是一个相当强的连接性假设。事实上，如果只有3m+1个将军（所需的最小数量），那么3m-规则性就意味着完全连通性，所以算法OM(m,3m)就简化为算法OM(m)。相反，算法SM(m)可以很容易地扩展到允许最弱的连接性假设。让我们首先考虑拜占庭将军问题需要多少连接性才能被解决。IC2要求一个忠诚的中尉服从一个忠诚的指挥官。如果指挥官不能与中尉沟通，这显然是不可能的。 特别是，如果指挥官对中尉的每条命令必须由叛徒转达，那么就没有办法保证中尉得到指挥官的命令。同样，如果有两个中尉只能通过叛徒作为中间人相互沟通，那么IC1也无法保证。

​	拜占庭将军问题可解的最弱连接性假设是，由忠诚的将军形成的子图是联通的。我们表明，在这个假设下，SM(n-2)算法是一个解决方案，其中n是将军的数量——无论叛徒的数量如何。当然，我们必须修改算法，使将军们只把信息发送到可以发送的地方。更确切地说，在步骤1中，指挥官只把他签署的命令发给他邻近的中尉；而在步骤2b中，中尉i只把信息发给不在jr中的每个邻居中尉。

​	我们证明以下更一般的结果，其中图的直径是最小的数字d，使得任意两节点间的路径最多包含d个弧。

​	定理4. 对于任何m和d，如果最多存在m个叛徒，并且忠诚将军的子图的直径为d，那么算法SM(m+d-1)（经过上述修改）可以解决拜占庭将军问题。

​	证明：该证明与定理2非常相似，在此仅作简要说明。为了证明IC2，请注意，根据假设，有一条从忠诚的指挥官到中尉i的路径要经过d-1或更少的忠诚中尉。这些中尉会正确地转达命令，直到它到达i。如前所述，假设A4防止叛徒伪造不同的命令。

​	为了证明IC1，我们假设指挥官是个叛徒，并且必须证明忠诚的中尉i收到的任何命令v，也会被忠诚的中尉j收到。假设i受到一个未被j签署的命令v:0:j1:...:jk。如果k<m，那么i将把它发送给每一个尚未收到该命令的邻居，它将在d-1步内被转发给j。如果k>=m，那么前m个签名的中尉是忠诚的，而且一定把它发给了他的所有邻居，然后由忠诚的将军们转达，并在d-1步内到达j。

​	推论. 如果忠诚将军的图是联通的，那么SM(n -2)(如上文所修改)解决了n个将军的拜占庭将军问题。

​	证明：设d为忠诚将军图的直径。由于连通图的直径小于节点数，所以一定有多于d个忠诚的将军和少于n-d个叛徒。通过让m=n-d-1，我们可从定理4中得到结果。

​	定理4假设忠诚将军的子图是联通的。即使不是这样，这个证明也很容易被扩展。如果有最多m个叛徒，那么算法SM(m + d - 1)有以下两个属性：

1）任何两个忠诚的将军被一条最多通过忠诚将军的长度为d的路径所连接，他们都将服从同一命令。

2）如果指挥官是忠诚的，那么任何与他相连的忠诚的中尉都会服从他的命令，其路径的长度最多为m+d，并且只经过忠诚的将军。

# 6   可靠的系统

​	除了使用本质上可靠的电路元件外，我们知道实现可靠的计算机系统的唯一方法是使用几个不同的“处理器”来计算相同的结果，然后对它们的输出进行多数投票，以获得一个单一的值。(投票可以在系统内部进行，也可以由输出的用户在外部进行）。无论是使用冗余电路实现可靠的计算机以防止单个芯片的故障，还是使用冗余计算站点做弹道导弹防御系统以防止单个站点被核攻击摧毁，都是如此。唯一的区别在于冗余的“处理器”的大小。

​	使用多数人投票来实现可靠性是基于这样的假设：所有没有问题的处理器将产生相同的输出。只要它们都使用相同的输入，那么计算结果就是相同的。然而，任何单一的输入数据都来自单一的物理组件——例如，来自可靠计算机中的其他电路，或来自导弹防御系统中的一些雷达点——一个故障的组件可以给不同的处理器提供不同的值。此外，当一个没有故障的输入单元中的数值在变化中时，不同的处理器甚至可以从该输入单元得到不同的值。例如，如果两个处理器在时钟前进时读取时钟时间，那么其中一个处理器很可能会得到旧时间，而另一个得到更新的时间。这种问题只能通过使读取与时钟的前进同步来防止。

​	为了使多数投票产生一个可靠的系统，应该满足以下两个条件。

1）所有非故障处理器必须使用相同的输入值（因此它们产生相同的输出）。

2）如果输入单元无故障，那么所有无故障进程都使用它提供的值作为输入（所以它们产生正确的输出）。

​	这些只是我们的交互式一致性条件IC1和IC2，其中“指挥官”是产生输入的单位，“中尉”是某个进程，而“忠诚”意味着无故障。试图用“硬件”解决方案来规避这个问题是很诱人的。例如，我们可以通过让所有处理器从同一条线上读取输入值，来确保所有处理器获得相同的输入值。然而，一个有问题的输入设备可能会沿着电线发送一个边缘信号——这个信号可以被一些处理器解释为0，而被其他处理器解释为1。除了让处理器之间进行通信以解决拜占庭将军问题外，没有办法保证不同的处理器会从一个可能有问题的输入设备获得相同的值。

​	当然，一个有问题的输入设备可能提供无意义的输入值。拜占庭将军方案所能做的就是保证所有处理器使用相同的输入值。如果输入是一个重要的输入，那么应该有几个独立的输入设备提供冗余的值。例如，在一个导弹防御系统中应该有冗余的雷达以及冗余的处理点。然而，冗余输入不能实现可靠性；仍有必要确保无故障处理器使用冗余数据来产生相同的输出。如果输入设备是无故障的，但由于在其数值变化时被读取而给出了不同的数值，我们仍然希望无故障处理器获得一个合理的输入值。可以证明，如果把函数majority和choice看作是中位数函数，那么我们的算法具有这样的特性：无故障处理器获得的值位于输入设备提供的值的范围内。因此，只要输入单元产生一个合理的数值范围，无故障处理器就会获得一个合理的数值。我们已经给出了几个解决方案，但它们是以拜占庭将军的方式而不是以计算系统的方式陈述的。我们现在研究一下这些解决方案如何能够应用于可靠的计算系统。当然，用一个处理器实现“将军”的算法是没有问题的。问题在于实现一个符合Al-A3假设的消息传递系统（算法SM(m)的假设为Al-A4）。我们现在考虑这些假设的顺序。

​	A1. 假设Al指出，由非故障处理器发送的每条消息都能正确传递。在实际系统中，通信线路可能会出现故障。对于口头信息算法OM(m)和OM(m,p)来说，连接两个处理器的通信线路的故障与其中一个处理器的故障是无法区分的。因此，我们只能保证这些算法在存在最多m个故障时能够工作，无论是处理器还是通信线路故障。(当然，连接到同一处理器的几条通信线路的故障等同于单个处理器的故障）。如果我们假设一条失败的通信线路不会导致签名信息被伪造——我们将在下面看到这个假设是非常合理的，那么我们的签名信息算法SM(m)对通信线路故障是不敏感的。更确切地说，定理4即使在通信线路故障的情况下仍然有效。一个失败的通信线路与简单地删除通信线路的效果相同——它只是降低了处理器图的联通性。

​	A2. 假设A2指出，一个处理器可以确定它收到的任何消息的发起人。这个约束实际上是指，一个有故障的处理器不能冒充一个无故障的处理器。在实践中，这意味着进程间的通信是通过直连的固定线路而不是通过一些消息交换网络。(如果使用交换网络，那么必须考虑有问题的网络节点，拜占庭将军问题再次出现）。请注意，如果假设A4成立，并且所有消息都是签名的，就不需要假设A2，因为冒充另一个处理器就是在伪造其消息。

​	A3. 假设A3要求可以检测到信息的缺失。信息的缺失只能通过其未能在某个固定的时间长度内到达来检测，换句话说，通过使用某种超时机制。使用超时来满足A3需要两个假设：

1）一个信息的生成和传输有一个固定的最大时间阈值。

2）发送方和接收方需要将时钟同步到某个固定的最大误差之内。

​	第一个假设的必要性是相当明显的，因为接收者必须知道他需要等待多长时间才能收到消息。(生成时间是指处理器在收到生成信息所需的所有输入后，需要多长时间来发送信息)。第二个假设的必要性不太明显。然而，可以证明，这个假设或一个等效的假设对于解决拜占庭将军问题是必要的。更确切地说，假设我们允许算法中的将军只在以下情况下采取行动。

1）在某个固定的初始时间（对所有将军都一样）。

2）收到信息后。

3）当一个随机选择的时间长度过去后。(也就是说，一个将军可以将一个计时器设置为一个随机值，并在计时器到期时采取行动)。

​	(这产生了我们所能设想的不允许构建同步时钟的最一般的一类算法)。可以证明，如果信息可以被任意快速地传送，即使信息传送延迟有一个上限，也没有这样的算法可以解决拜占庭将军问题。此外，即使我们限制叛徒，使他们唯一被允许的不正确行为是不发送消息，也不可能有解决方案。这个结果的证明已经超出了本文的范围。请注意，对传输延迟设置一个下限和上限允许处理器通过来回发送消息来实现时钟。

​	上述两个假设使得检测未发送的信息变得容易。设μ为的最大信息生成和传输延迟，并假设无故障处理器的时钟在任何时候都相互之间最多相差τ。假设输入设备在时刻T开始生成消息，那么任何无故障进程应该在接收方时钟的T+μ+τ时间前接受到该消息。因此，如果接收方到那个时间还没有收到消息，那么它可以假设消息没有被发送。(如果它晚点到达，那么发送者一定有问题，所以我们的算法的正确性并不取决于信息的发送）。通过固定输入处理器发送其值的时间，可以计算出某个处理器必须等待该信息到达时自己的时钟上的时间。例如，在算法SM(m)中，对于任何具有k个签名的信息，一个处理器必须等待到时刻T0+k(µ+τ)，其中T0是指挥官开始执行算法的时刻。

​	没有两个时钟以精确的速率运行，因此无论处理器的时钟最初是如何精确地同步，它们最终都会任意地漂移开来，除非它们定期重新同步。因此，我们有一个问题，即即使一些处理器有问题，也要将所有处理器的时钟同步到某个固定的数量之内。这个问题和拜占庭将军问题本身一样困难。存在着与我们的拜占庭将军问题解决方案密切相关的时钟同步问题的解决方案。它们将在未来的文章中描述。

​	A4. 假设A4要求无故障处理器能够不被伪造签名的方式签署消息。签名是由进程i从数据项M产生的冗余信息Si(M)。所以由i签署的消息则是由一对(M, Si(M))组成。为了满足A4的a和b条件，函数Si必须具有以下两个特性：

1）如果处理器i是无故障的，那么没有已故障处理器可以生成Si(M)。

2）给定M和X，任何进程都可以确定X是否等于Si(M)。

​	属性1永远无法保证，因为Si（M）只是一个数据项，而一个有问题的处理器可以产生任何数据项。然而，我们可以使其违反的概率尽可能小，从而使系统如我们所愿地可靠。如何做到这一点，取决于我们期望遇到的故障类型。有两种情况值得关注：

1）随机故障。通过使Si成为一个适当的"随机化"函数，我们可以使处理器中的随机故障产生一个正确签名的概率基本上等于它通过随机选择程序这样做的概率——即可能签名数量的倒数。以下是这样做的一种方法。假设信息被编码为小于P的正整数，其中P是2的幂。让Si(M)等于M*Ki mod P，其中Ki是一个随机选择的小于P的奇数。让Ki-1是小于P的唯一数字，使Ki*Ki-1=1 mod P，一个进程可以通过测试M = X* Ki-1 mod P来检查X = Si (M)。 如果另一个处理器在其内存中没有Ki，那么它产生正确签名M*Ki的概率对于单一（非零）信息M应该是1/P：其通过随机选择的概率。(注意，如果处理器可以通过一些简单的程序获得Ki，那么有问题的处理器j在试图计算Sj(M)时，可能会有更大的概率通过替换Ki来伪造i的签名)。

2）恶意智能。如果有问题的处理器是被恶意的智能引导——例如，如果它是一个无故障处理器但被一个试图破坏系统的人操作——那么构建签名函数Si就成为一个密码学问题。我们请读者参考[1]和[4]中关于如何解决这个问题的讨论。

​	请注意，如果进程已经看到了签名Si(M)，则很容易再产生该签名。因此，重要的是，同一消息永远不必被签署两次。这意味着，当重复使用SM(m)来分发一个序列的值时，序列号应该附加到这些值上以保证唯一性。

# 7   结论

​	我们已经在各种假设下提出了拜占庭将军问题的几种解决方案，并展示了它们如何被用于实现可靠的计算机系统。这些解决方案都很耗费时间并需要大量信息。算法OM(m)和SM(m)都需要长度不超过m+1的消息路径。换句话说，每个中尉可能有来等待来自指挥官的信息，然后通过其他m个中尉转达。Fischer和Lynch已经证明，对于任何能够应对m个叛徒的解决方案来说，这是必须的。所以我们的解决方案在这方面是最优的。我们对一个不完全联通的图的算法而言，要求信息路径长度不超过m+d，其中d是忠诚将军的子图的直径。我们怀疑这也是最优的。

​	算法OM(m)和SM(m)涉及发送多达(n - l)(n - 2) ...(n-m-1)条消息。所需的独立信息的数量当然可以通过合并信息来减少。也有可能减少传输的信息量，但这还没有被详细研究过。但我们估计仍需要大量的信息。

​	面对任意的故障，实现可靠性是一个困难的问题，其解决方案似乎本身就很昂贵。降低成本的唯一方法是对可能发生的故障类型做出假设。例如，人们通常假设计算机可能无法响应，但永远不会错误地响应。然而，当需要极高的可靠性时，这样的假设是不可能的，就需要付出拜占庭将军解决方案带来的全部成本。

 

# References

[1]   DIFFIE, W., ANDHELLMAN, M.E. New directions in cryptography. IEEE Trans. Inf Theory IT-22 (Nov. 1976), 644-654..

[2]   DoLEV, D. The Byzantine generals strike again. J. Algorithms 3, 1 (Jan. 1982).

[3]   PEASE, M., SHOSTAK, R., ANDLAMPORT, L. Reaching agreement in the presence of faults. J. ACM 27, 2 (Apr. 1980), 228-234.

[4]   RIVEST, R.L., SHAMIR, A., ANDADLEMAN,L. A method for obtaining digital signatures and publickey cryptosystems. Commun. ACM 21, 2 (Feb. 1978), 120-126.

 