
<!-- vim-markdown-toc GitLab -->

* [计算机网络](#计算机网络)
    * [基础](#基础)
        * [Q：五层协议的体系结构分别是什么？每一层都有哪些协议？](#q五层协议的体系结构分别是什么每一层都有哪些协议)
        * [Q：为何有MAC地址还要IP地址？](#q为何有mac地址还要ip地址)
    * [TCP](#tcp)
        * [Q：TCP和UDP的区别？](#qtcp和udp的区别)
        * [Q：超时重传 & 快速重传](#q超时重传-快速重传)
        * [Q：X 拥塞控制和流量控制都是什么，两者的区别？](#qx-拥塞控制和流量控制都是什么两者的区别)
        * [Q：谈谈TCP为什么要三次握手？为什么要四次挥手？](#q谈谈tcp为什么要三次握手为什么要四次挥手)
        * [Q：播放视频用TCP还是UDP？为什么？](#q播放视频用tcp还是udp为什么)
    * [HTTP](#http)
        * [Q：HTTP报文格式？](#qhttp报文格式)
        * [Q：了解哪些响应状态码？](#q了解哪些响应状态码)
        * [Q：GET和POST的区别？](#qget和post的区别)
        * [Q：X HTTP1.0、1.1、2.0的区别？](#qx-http101120的区别)
        * [Q：HTTP和HTTPS的区别?](#qhttp和https的区别)
        * [Q：在地址栏打入http://www.baidu.com会发生什么？](#q在地址栏打入httpwwwbaiducom会发生什么)
        * [Q：1.0短链接、1.1长连接、2.0多路复用？](#q10短链接11长连接20多路复用)
        * [Q：X HTTPS原理及认证过程](#qx-https原理及认证过程)
        * [Q：QUIC是什么](#qquic是什么)
        * [Q：为什么 HTTPS 需要 7 次握手以及 9 倍时延](#q为什么-https-需要-7-次握手以及-9-倍时延)
        * [Q：50x错误各代表什么意义](#q50x错误各代表什么意义)
        * [Q：Cookie / Session / Token](#qcookie-session-token)
* [操作系统](#操作系统)
    * [基础](#基础-1)
        * [Q：操作系统中进程和线程的区别？](#q操作系统中进程和线程的区别)
        * [Q：死锁的产生和避免?](#q死锁的产生和避免)
        * [Q：虚拟内存、分页、页表的组织形式](#q虚拟内存分页页表的组织形式)
        * [Q：Linux IO模式](#qlinux-io模式)
        * [Q：select / poll / epoll](#qselect-poll-epoll)
* [数据库](#数据库)
    * [基础](#基础-2)
        * [Q：数据库中的事务了解吗？事务的四大特性？](#q数据库中的事务了解吗事务的四大特性)
        * [Q：如何理解数据库的范式？](#q如何理解数据库的范式)
        * [Q：索引、B+索引和Hash索引的优缺点](#q索引b索引和hash索引的优缺点)
        * [Q：事务](#q事务)
        * [Q：表级锁和行级锁](#q表级锁和行级锁)
        * [Q：SQL优化](#qsql优化)
        * [Q：区间查找](#q区间查找)
* [数据结构与算法](#数据结构与算法)
    * [基础](#基础-3)
        * [Q：迭代和递归的特点，并比较优缺点](#q迭代和递归的特点并比较优缺点)
        * [Q：了解哪些查找算法，时间复杂度都是多少？](#q了解哪些查找算法时间复杂度都是多少)
        * [Q：了解哪些排序算法，并比较一下，以及适用场景](#q了解哪些排序算法并比较一下以及适用场景)
        * [Q：快排的基本思路是什么？最差的时间复杂度是多少？如何优化？](#q快排的基本思路是什么最差的时间复杂度是多少如何优化)
        * [Q：冒泡排序如何优化？](#q冒泡排序如何优化)
        * [Q：AVL树插入或删除一个节点的过程是怎样的？](#qavl树插入或删除一个节点的过程是怎样的)
        * [Q：什么是红黑树？](#q什么是红黑树)
* [语言方面](#语言方面)
    * [Rust](#rust)
        * [Q：宏与过程宏](#q宏与过程宏)
        * [Q：Box](#qbox)
        * [Q：Trait Object](#qtrait-object)
        * [Q：动态分发和静态分发](#q动态分发和静态分发)
        * [Q：Drop & Deref](#qdrop-deref)

<!-- vim-markdown-toc -->

  
# 计算机网络



  
## 基础



  
### Q：五层协议的体系结构分别是什么？每一层都有哪些协议？

> https://blog.csdn.net/cainv89/article/details/46885197

应用层，应用层确定进程之间通信的性质以满足用户的需要。应用层不仅要提供应用进程所需要的信息交换和远地操作，还要作为互相作用的应用进程的用户代理（user agent)；

运输层任务是负责主机中两个进程间的通信；

网络层网络层负责的是分组选择合适的路由；

数据链路层数据链路层的任务：将在网络层交下来的数据报组装成帧（frame)，两个相邻结点间的链路实现帧的传输；

物理层物理层的任务：透明地传输比特流。 




  
### Q：为何有MAC地址还要IP地址？

> http://blog.sciencenet.cn/blog-411071-1037673.html

基本上一个观点就是一个是物理地址，一个是逻辑地址。

假设两点在一个网络内。在这种情况下，只需要MAC地址就可以了。例如通过交换机将多台电脑组成一个网络。

然而，如果两点不在一个网络内。这时就需要IP地址了。因为IP地址含有两个部分，一个是网络地址，一个是主机地址。因此，通过对方的IP地址，是可以判断出对方是否和本机在一个网络内。如果在一个网络内，如上所述，只需要知道对方的MAC地址即可通信。

如果不在一个网络内，本机的网络层就认为数据应该发送给网关。道理是显然的，如果不在一个网络内，首先得把数据发送出网络才可以。如何发出网络，当然是发给网关，因为网关就相当于网络的门卫。要想把数据发给网关，同样需要知道网关的MAC地址，如何知道网关的MAC地址呢？这就涉及到ARP协议。

电脑缓存里有一张ARP表，该表主要有两列：一列是IP地址，另外一列是MAC地址。这张表不是天生就有的，是随着网卡收到网络中的各种通信数据，不断学习增加的。

话说回来，如果ARP表中有网关IP地址对应的MAC地址，则问题就转化为网内数据发送，上面已经讲的很清楚了。如果ARP表中没有网关IP地址对应的MAC地址，则启动ARP协议，即向网内广播，询问该IP地址的MAC地址。广播询问的结果是网关收到广播后，发现是问自己的MAC地址，所以就回复询问方自己的MAC地址。然后数据发给网关的问题，也转化为网内数据发送。



  
## TCP




  
### Q：TCP和UDP的区别？

> https://blog.csdn.net/xiaobangkuaipao/article/details/76793702

> https://www.cnblogs.com/jingliming/p/4477264.html

1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接

2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付

Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。

3、UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。

4.每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信

5、TCP对系统资源要求较多，UDP对系统资源要求较少。



  
### Q：超时重传 & 快速重传



  
### Q：X 拥塞控制和流量控制都是什么，两者的区别？

> https://blog.csdn.net/ailunlee/article/details/53716367

流量控制是端到端的控制，例如A通过网络给B发数据，A发送的太快导致B没法接收(B缓冲窗口过小或者处理过慢)，这时候的控制就是流量控制，原理是通过滑动窗口的大小改变来实现。 
拥塞控制是A与B之间的网络发生堵塞导致传输过慢或者丢包，来不及传输。防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不至于过载。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络性能有关的所有因素。




  
### Q：谈谈TCP为什么要三次握手？为什么要四次挥手？

> https://blog.csdn.net/zhaobudaofangxia/article/details/55260259

> https://zhuanlan.zhihu.com/p/53374516

> https://draveness.me/whys-the-design-tcp-three-way-handshake/

三次握手：(验证双方的收发能力正常)

    第一次。A跟B说，我要建立连接了			SYN 		(new SEQ)
    第二次。B跟A说，OK那我也建立连接			SYN + ACK 	(new SEQ)
    第三次。A跟B说，嗯，我知道了。			ACK

**第三次握手解决历史链接问题**：

为了阻止历史的重复连接初始化造成的混乱问题，防止使用 TCP 协议通信的双方建立了错误的连接；

接收方只能选择接受或者拒绝发送方发起的请求，它并不清楚这一次请求是不是由于网络拥堵而早早过期的连接。

使用三次握手和 `RST` 控制消息将是否建立连接的最终控制权交给了发送方。



四次挥手：（二四验证收到断开链接请求）

    第一次。A跟B说，我要断开连接了						FIN
    第二次。B跟A说，好的我不再接收你的信息了				ACK
    第三次。B跟A说，我传给你的信息传完了,你可以关闭连接了	FIN
    第四次。A跟B说，好的我关闭连接了						ACK

 


  
### Q：播放视频用TCP还是UDP？为什么？

TCP 和 UDP 是质量和实时性的权衡。
拿视频网站来说，你完全可以缓冲 20s 再播放，不会带来什么影响，但如果画面有马赛克之类的东西出现肯定是不好的，所以用 TCP。
而对于视频聊天，如果缓冲 5s，相信整个聊天已经没法愉快的进行了，而这时出现一些画面质量的损失也可以被接受，所以用 UDP。



  
## HTTP



  
### Q：HTTP报文格式？

> https://blog.csdn.net/holmofy/article/details/68492045

Requst: Method + URL + Version

Response: Version + Status + Description



  
### Q：了解哪些响应状态码？

> https://blog.csdn.net/oops_qu/article/details/75675702

> 1xx（临时响应）：表示临时响应并需要请求者继续执行操作的状态代码。

> 2xx （成功）：表示成功处理了请求的状态代码。

> 3xx （重定向）：表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。

> 4xx（请求错误）：这些状态代码表示请求可能出错，妨碍了服务器的处理。

> 5xx（服务器错误）：这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。



301: 永久移动

302: 临时移动

401: 身份验证未授权

403: 禁止

405: 方法禁用



  
### Q：GET和POST的区别？

> https://www.cnblogs.com/huaxingtianxia/p/5895236.html

GET在浏览器回退时是无害的，而POST会再次提交请求。
GET请求会被浏览器主动cache，而POST不会，除非手动设置。
GET请求只能进行url编码，而POST支持多种编码方式。
GET请求在URL中传送的参数是有长度限制的，而POST么有。
GET参数通过URL传递，POST放在body中。



GET产生一个TCP数据包, POST产生两个TCP数据包。

POST情况下，浏览器先发送header，服务器响应100 CONTINUE；浏览器再发送data，服务器响应200。

但并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。



  
### Q：X HTTP1.0、1.1、2.0的区别？

> https://blog.csdn.net/linsongbin1/article/details/54980801/



  
### Q：HTTP和HTTPS的区别?

多一层TLS，以防中间人，保证安全。



  
### Q：在地址栏打入http://www.baidu.com会发生什么？

> https://github.com/skyline75489/what-happens-when-zh_CN

检查 HSTS 列表
DNS 查询
ARP 过程
TCP 握手
TLS 握手
HTTP 协议




  
### Q：1.0短链接、1.1长连接、2.0多路复用？

> https://www.cnblogs.com/gotodsp/p/6366163.html

> https://www.cnblogs.com/Paul-watermelon/p/10467662.html

HTTP/1.0使用短连接。客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。客户端浏览器每遇到一个Web资源，浏览器就会重新建立一个HTTP会话(TCP连接)。



HTTP/1.1默认使用长连接。`Connection:keep-alive`。当一个网页打开完成后，TCP连接不会关闭，客户端会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件中设定这个时间。

HTTP/1.1 Pipeline解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；



HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行



  
### Q：X HTTPS原理及认证过程



  
### Q：QUIC是什么

> https://zhuanlan.zhihu.com/p/32553477

Quic即“快速 UDP 互联网连接”，是由 google 提出的使用 udp 进行多路并发传输的协议。

Quic 相比现在广泛应用的 http2+tcp+tls 协议有如下优势：

- **连接建立延时低** : 0RTT建立链接(曾有过链接) vs 3RTT链接 

- **改进的拥塞控制**：基于TCP 协议

- **没有队头阻塞的多路复用**：在一条 QUIC 连接上可以并发发送多个 HTTP 请求 (stream)，互相之间没有依赖 vs HTTP2

- **加密认证的报文**



  
### Q：为什么 HTTPS 需要 7 次握手以及 9 倍时延

> https://draveness.me/whys-the-design-https-latency/

(HTTPS 使用安全套接字层SSL保证数据传输的安全，随着传输层安全协议TLS的发展，目前我们已经使用 TLS 取代了废弃的 SSL 协议)

- TCP 协议 — 通信双方通过三次握手建立 TCP 连接；1.5 RTT；
- TLS 协议 — 通信双方通过四次握手建立 TLS 连接；2 RTT；
- HTTP 协议 — 客户端向服务端发送请求，服务端发回响应；1 RTT；

**TLS**

TLS 的作用是构建安全的传输通道（本身不提供可靠性保障）。在通信双方建立可靠的 TCP 连接之后，我们就需要通过 TLS 握手交换双方的密钥了。

TLS 握手的关键在于利用通信**双方生成的随机字符串**和**服务端的公钥**生成一个双方经过协商后的密钥，通信的双方可以使用这个**对称的密钥加密**消息防止**中间人**的监听和攻击，保证通信的安全。



  
### Q：50x错误各代表什么意义

500: 程序内部错误

501: 服务器不具备完成请求的功能

502: 错误网关 (web容器收到了无法理解的响应)

503: 服务不可用 (停机维护)

504: 网关超时 (超过了web容器的超时时间，不等待程序的返回结果)

505: HTTP版本不支持



  
### Q：Cookie / Session / Token 

> https://zhuanlan.zhihu.com/p/129227994

HTTP 协议是一种`无状态协议`，即每次服务端接收到客户端的请求时，都是一个全新的请求，服务器并不知道客户端的历史请求记录；Session 和 Cookie 的主要目的就是为了弥补 HTTP 的无状态特性。



**Cookie**

- 服务器发送到浏览器的 Cookie，浏览器会进行存储，并与下一个请求一起发送到服务器。
- 响应头`Set-Cookie`，请求头`Cookie`工作原理。
- 过期时间，域，HttpOnly



**Session**

- 客户端请求服务端，服务端会为这次请求开辟一块`内存空间`，存储客户端在同一个会话期间的一些记录。
- 服务器第一次返回响应时，带有`Set-Cookie：SESSIONID=XXXXXXX`；<br>客户端在本机客户端设置此Cookie，该 Cookie 的过期时间为浏览器会话结束；<br>客户端每次向同一个网站发送请求时，请求头都会带上该 Cookie信息；<br>服务器每次读取请求头中的 Cookie 信息，获取SessionId，获得状态。
- 负载均衡后，需要Session数据库提供一致性能力。



**Token**

- 服务器生成加密令牌，客户端请求带上Token，服务器校验。一般放在cookie里。
- **无状态**：减轻服务器的压力，减少频繁的查询数据库
- JWT格式: header.payload.sign





  
# 操作系统



  
## 基础



  
### Q：操作系统中进程和线程的区别？

进程是资源分配的最小单位，线程是CPU调度的最小单位。



  
### Q：死锁的产生和避免?

> https://www.cnblogs.com/fangrong/p/5271724.html

死锁的四个必要条件：
(1)互斥条件(Mutual exclusion)：资源不能被共享，只能由一个进程使用。
(2)请求与保持条件(Hold and wait)：已经得到资源的进程可以再次申请新的资源。
(3)非剥夺条件(No pre-emption)：已经分配的资源不能从相应的进程中被强制地剥夺。
(4)循环等待条件(Circular wait)：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。

死锁避免（deadlock avoidence）是在系统运行过程中注意避免死锁的发生。这就要求每当申请一个资源时，系统都应根据一定的算法判断是否认可这次申请，使得在今后一段时间内系统不会出现死锁。这面方最著名的算法首推Dijkstra[1965]提出的银行家（banker）算法。



  
### Q：虚拟内存、分页、页表的组织形式

**基本分页**

- 固定分区会产生内碎片，动态分区会产生外碎片；为了尽量避免内存碎片，提出基本分页存储。<br>它将主存空间分为固定相等的小块，作为主存的单元。进程在申请内存时，以页为单位进行请求。<br>（进程中为页，内存中为页框，外存中为块。无外碎片，平均半个页的内碎片。）
- **页面大小取舍**
  - 太小：页表过大（浪费内存），地址转换频繁（浪费时间）
  - 太大：内碎片过大（浪费内存）
- **页表**：
  - 便于寻找页面对应的物理块，系统在内存中为每个进程维护一张页表。
  - 实际上是物理块号的数组，其索引为页号。
- **基本地址变换机构**：
  - 逻辑地址结构： `| 页号 | 页内偏移量 |`
  - 页表寄存器：`| 页表起始地址 | 页表长度 |`
  - 检查逻辑地址页号长度小于页表长度，计算页表中对应页号地址，取出块号拼接偏移量。
- **快表**
  - 具有并行查找能力的高速缓冲器，用于提升地址变换速度（减少一次查页表的访存）。
  - 实际上为`| 页号 | 块号 |`的数组
  - 在原有变换流程基础上，首先查找快表，取出块号拼接偏移量。
- **两级页表**
  - 为了压缩页表大小，不去存储无用的页表项，系统在内存中为每个进程维护一张二级页表。
  - 逻辑地址结构： `| 一级页号 | 二级页号 | 页内偏移量 |`



**请求分页** 

- 虚拟内存的一种实现方式。虚存基于时空局部性，当内存暂时不使用时换出至外存。系统为用户提供了一个比物理空间大得多的虚拟空间，故称虚存。
- 只需一部分页面装入内存，程序即可运行。当需要访问不在内存中的页面时，通过**请求调页**功能调入，同时置换不用的页面至外存。
- **页表**：为了发现和处理请求页面时，页面是否存在和调出等问题，加入另外一些字段。（如访问位，修改位等）
- **地址变换机构**：首先查找快表，（若不存在）再查找页表；查看页表是否已调入，（若缺页）产生缺页中断，请求调页。
- **缺页中断机构**：CPU遇到缺页中断后，阻塞缺页进程；若内存中无空闲页框，则按**页面置换算法**淘汰某页，再调入目标页面。
- **页面置换算法**：LRU实现使用哈希表+双向链表，读写移动至表头，替换时删除表尾。




  
### Q：Linux IO模式
> https://segmentfault.com/a/1190000003063859

对于一次IO访问：
1. 数据会先被拷贝到**操作系统内核的缓冲区**中
2. 从操作系统内核的缓冲区拷贝到**应用程序的地址空间**。

所以说，当一个read操作发生时，它会经历两个阶段：
1. 等待数据准备
2. 将数据从内核拷贝到进程中

正式因为这两个阶段，linux系统产生了下面五种网络模式的方案。
- 阻塞 IO
- 非阻塞 IO
- IO 多路复用
- 信号驱动 IO
- 异步 IO

**阻塞 IO**
- 当用户进程调用 recvfrom 系统调用后  
	kernel准备数据&拷贝至用户空间；  
	用户两个过程阻塞。
- 在linux中，默认socket都是blocking.

**非阻塞 IO**
- 当用户进程调用 recvfrom 系统调用后  
	kernel准备数据&拷贝至用户空间；  
	用户第一个过程可不断调用IO，kernel不断返回error，直至第一个过程结束。  
	用户第二个过程调用IO后阻塞。
- 在linux中，socket可以设置为non-blocking.


**IO 多路复用**
- IO 多路复用就是我们说的select，poll，epoll，（也称事件驱动 IO）。
- 原理是select，poll，epoll函数不断轮询所有文件描述符，当某个文件有数据到达，就通知用户进程。
- 当用户进程调用 select / poll 系统调用后，对每个文件描述符：  
	kernel准备数据&拷贝至用户空间；  
	用户第一个过程阻塞，直至kernel结束第一过程，并返回。  
	用户第二个过程调用IO后阻塞。
- 优点在于单进程可以同时处理多个网络连接IO。
- 所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好。


**异步 IO**
- 当用户进程调用 aio_read 系统调用后：  
	kernel立即返回，并准备数据&拷贝至用户空间，完毕后向用户进程发送信号；  
	用户两个过程皆不阻塞。


  
### Q：select / poll / epoll
> https://zhuanlan.zhihu.com/p/93609693

1. select / poll: 监听文件描述符list，进行一个线性的查找 O(n)
2. poll: 取消 select 的最大链接数量限制
2. epoll: 使用了内核文件级别的回调机制O(1)

epoll相比于select并不是在所有情况下都要高效，例如在如果有少于1024个文件描述符监听，且大多数socket都是出于活跃繁忙的状态，这种情况下，select要比epoll更为高效，因为epoll会有更多次的系统调用，用户态和内核态会有更加频繁的切换。


  
# 数据库



  
## 基础



  
### Q：数据库中的事务了解吗？事务的四大特性？

**原子性**
    数据修改操作要么全部执行，要么完全不执行

**一致性**
    数据库的状态满足所有的完整性约束

**分离性**
    并发事务相互隔离，互不相影响

**持久性**
    已提交事务的更新不能丢失。即一旦一个事务提交，数据库中数据的改变应该是永久性的



  
### Q：如何理解数据库的范式？

> https://blog.csdn.net/zymx14/article/details/69789326

第一范式：确保每一列的原子性

第二范式：非键字段必须依赖于键字段
    如果一个关系满足1NF，并且除了主键以外的其它列，都依赖与该主键，则满足二范式(2NF)，第二范式要求每个表只描述一件事。

第三范式：在1NF基础上，除了主键以外的其它列都不传递依赖于主键列，或者说： 任何非主属性不依赖于其它非主属性

（在2NF基础上消除传递依赖）




  
### Q：索引、B+索引和Hash索引的优缺点

  
### Q：事务

  
### Q：表级锁和行级锁

  
### Q：SQL优化

  
### Q：区间查找



  
# 数据结构与算法



  
## 基础



  
### Q：迭代和递归的特点，并比较优缺点

> https://blog.csdn.net/laoyang360/article/details/7855860

|      | 定义                                                       | 优点                                                                                                                   | 缺点                                                                     |
|------|------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|
| 递归 | 程序调用自身的编程技巧称为递归                             | 1）大问题化为小问题,可以极大的减少代码量；<br> 2）用有限的语句来定义对象的无限集合；<br> 3）代码更简洁清晰，可读性更好 | 1）递归调用函数,浪费空间；<br> 2）递归太深容易造成堆栈的溢出；           |
| 迭代 | 利用变量的原值推算出变量的一个新值，迭代就是A不停的调用B\. | 1）迭代效率高，运行时间只因循环次数增加而增加；<br> 2）没什么额外开销，空间上也没有什么增加，                          | 1） 不容易理解；<br> 2） 代码不如递归简洁；<br> 3） 编写复杂问题时困难。 |

1） 递归中一定有迭代,但是迭代中不一定有递归,大部分可以相互转换。
2） 能用迭代的不用递归,递归调用函数,浪费空间,并且递归太深容易造成堆栈的溢出.



  
### Q：了解哪些查找算法，时间复杂度都是多少？

> https://blog.csdn.net/qq_23217629/article/details/52517741

| 查找                 | 平均时间复杂度 | 查找条件               | 算法描述                                                                                                                                                                                                                                     |
|----------------------|----------------|------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 顺序查找             | O(n)           | 无序或有序队列         | 按顺序比较每个元素，直到找到关键字为止                                                                                                                                                                                                       |
| 二分查找（折半查找） | O(logn)        | 有序数组               | 查找过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。　如果在某一步骤数组为空，则代表找不到。     |
| 二叉排序树查找       | O(logn)        | 二叉排序树             | 在二叉查找树b中查找x的过程为：<br> 1\. 若b是空树，则搜索失败<br> 2\. 若x等于b的根节点的数据域之值，则查找成功；<br> 3\. 若x小于b的根节点的数据域之值，则搜索左子树 <br>4\. 查找右子树。                                                      |
| 哈希表法（散列表）   | O(1)           | 先创建哈希表（散列表） | 根据键值方式进行查找，通过散列函数，定位数据元素。                                                                                                                                                                                           |
| 分块查找             | O(logn)        | 无序或有序队列         | 将n个数据元素"按块有序"划分为m块（m ≤ n）。 每一块中的结点不必有序，但块与块之间必须"按块有序"；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，……。然后使用二分查找及顺序查找。 |



  
### Q：了解哪些排序算法，并比较一下，以及适用场景

> https://blog.csdn.net/mountain_hua/article/details/81107024

| 排序法     | 最差时间分析 | 平均时间复杂度 | 稳定度 | 空间复杂度      |
|------------|--------------|----------------|--------|-----------------|
| 冒泡排序   | O(n2)        | O(n2)          | 稳定   | O(1)            |
| 插入排序   | O(n2)        | O(n2)          | 稳定   | O(1)            |
| 选择排序   | O(n2)        | O(n2)          | 稳定   | O(1)            |
| 二叉树排序 | O(n2)        | O(n*log2n)     | 不一顶 | O(n)            |
| 快速排序   | O(n2)        | O(n*log2n)     | 不稳定 | O(log2n) ~ O(n) |
| 堆排序     | O(n*log2n)   | O(n*log2n)     | 不稳定 | O(1)            |
| 希尔排序   | O            | O              | 不稳定 | O(1)            |

 


  
### Q：快排的基本思路是什么？最差的时间复杂度是多少？如何优化？

（升序）以某个记录的关键字为划分元，将整个数据分为两组，左边的数据小于等于划分元，右边的数据大于等于划分元。对左右两组数据，再各自选择一个划分元，将两组数据划分为更小的序列，这样一直进行下去，直到整个序列有序。

```java
public static void quickSort(int[] array, int left, int right) {
    if (left < right) {
        int pivot = array[left];
        int low = left;
        int high = right;
        while (low < high) {
            while (low < high && array[high] >= pivot) {
                high--;
            }
            array[low] = array[high];
            while (low < high && array[low] <= pivot) {
                low++;
            }
            array[high] = array[low];
        }
        array[low] = pivot;
        quickSort(array, left, low - 1);
        quickSort(array, low + 1, right);
    }
}
```

最差时间复杂度即是但数据有序的时候，这时候退化为冒泡排序，时间复杂度为O（n2）

优化：https://blog.csdn.net/sinat_28676875/article/details/69053449

 

  
### Q：冒泡排序如何优化？

```java
public static void bubbleSort(int[] array) {
    int len = array.length;
    boolean flag = true;
    while (flag) {
        flag = false;
        for (int i = 0; i < len - 1; i++) {
            if (array[i] > array[i + 1]) {
                int temp = array[i + 1];
                array[i + 1] = array[j];
                array[i] = temp;
                flag = true;
            }
        }
        len--;
    }
}
```

存在这样一一种情况，冒泡过程中，后面的若干记录没有发生交换，这时候再继续进行冒泡就显得多此一举了，那么我们只需要记录没有发生交换的位置，对这个位置之后的数据不进行冒泡处理，只对这个位置之前的数据进行冒泡处理，提升算法的效率。

优化后的冒泡排序：

```java
void Bubble_Modified_Sort(int R[],int n){
    int i=n;
    int j;
    int LastExchangeIndex;
    while(i>1){
        LastExchangeIndex=1;
        for(j=0,j<i,j++){
            if(R[j]>R[j+1]){
                int temp=R[j+1];
                R[j+1]=R[j];
                R[j]=temp;
                LastExchangeIndex=j;
            }    //end if
        }    //end for
        i=LastExchangeIndex;
    }    //end while
}
```



  
### Q：AVL树插入或删除一个节点的过程是怎样的？

> https://blog.csdn.net/Ivan_zgj/article/details/51495926

> https://blog.csdn.net/friendbkf/article/details/50160141



  
### Q：什么是红黑树？

红黑树（Red Black Tree） 是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。

它是在1972年由Rudolf Bayer发明的，当时被称为平衡二叉B树（symmetric binary B-trees）。后来，在1978年被 Leo J. Guibas 和 Robert Sedgewick 修改为如今的“红黑树”。

红黑树和AVL树类似，都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。

它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的： 它可以在O(log n)时间内做查找，插入和删除，这里的n 是树中元素的数目。


  
# 语言方面

  
## Rust


  
### Q：宏与过程宏
  
### Q：Box
  
### Q：Trait Object
  
### Q：动态分发和静态分发
  
### Q：Drop & Deref
