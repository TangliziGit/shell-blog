<!-- vim-markdown-toc GitLab -->

* [计算机网络](#计算机网络)
    * [基础](#基础)
        * [Q：五层协议的体系结构分别是什么？每一层都有哪些协议？](#q五层协议的体系结构分别是什么每一层都有哪些协议)
        * [Q：为何有MAC地址还要IP地址？](#q为何有mac地址还要ip地址)
    * [TCP](#tcp)
        * [Q：TCP特性](#qtcp特性)
        * [Q：TCP和UDP的区别？](#qtcp和udp的区别)
        * [Q：拥塞控制和流量控制都是什么，两者的区别？](#q拥塞控制和流量控制都是什么两者的区别)
        * [Q：谈谈TCP为什么要三次握手？为什么要四次挥手？](#q谈谈tcp为什么要三次握手为什么要四次挥手)
        * [Q：播放视频用TCP还是UDP？为什么？](#q播放视频用tcp还是udp为什么)
        * [Q：TCP KeepAlive](#qtcp-keepalive)
    * [HTTP](#http)
        * [Q：HTTP报文格式？](#qhttp报文格式)
        * [Q：了解哪些响应状态码？](#q了解哪些响应状态码)
        * [Q：GET和POST的区别？](#qget和post的区别)
        * [Q：HTTP1.0和1.1的区别？](#qhttp10和11的区别)
        * [Q：HTTP1.1和2.0的区别？](#qhttp11和20的区别)
        * [Q：HTTP和HTTPS的区别?](#qhttp和https的区别)
        * [Q：在地址栏打入http://www.baidu.com会发生什么？](#q在地址栏打入httpwwwbaiducom会发生什么)
        * [Q：1.0短链接、1.1长连接、2.0多路复用？](#q10短链接11长连接20多路复用)
        * [Q：HTTPS原理及认证过程](#qhttps原理及认证过程)
        * [Q：QUIC是什么](#qquic是什么)
        * [Q：为什么 HTTPS 需要 7 次握手以及 9 倍时延](#q为什么-https-需要-7-次握手以及-9-倍时延)
        * [Q：50x错误各代表什么意义](#q50x错误各代表什么意义)
        * [Q：Cookie / Session / Token](#qcookie-session-token)
* [操作系统](#操作系统)
    * [基础](#基础-1)
        * [Q：操作系统中进程和线程的区别？](#q操作系统中进程和线程的区别)
        * [Q：死锁的产生和避免?](#q死锁的产生和避免)
        * [Q：虚拟内存、分页、页表的组织形式](#q虚拟内存分页页表的组织形式)
        * [Q：Linux IO模式](#qlinux-io模式)
        * [Q：select / poll / epoll](#qselect-poll-epoll)
* [数据库](#数据库)
    * [基础](#基础-2)
        * [Q：数据库中的事务了解吗？事务的四大特性？](#q数据库中的事务了解吗事务的四大特性)
        * [Q：如何理解数据库的范式？](#q如何理解数据库的范式)
        * [Q：索引](#q索引)
        * [Q：MySQL 多版本并发控制](#qmysql-多版本并发控制)
        * [Q：事务并发一致性异常 & 四大隔离级别](#q事务并发一致性异常-四大隔离级别)
        * [Q：表级锁和行级锁](#q表级锁和行级锁)
        * [Q：SQL优化](#qsql优化)
        * [Q：区间查找](#q区间查找)
* [数据结构与算法](#数据结构与算法)
    * [基础](#基础-3)
        * [Q：了解哪些排序算法，并比较一下，以及适用场景](#q了解哪些排序算法并比较一下以及适用场景)
        * [Q：快排的基本思路是什么？最差的时间复杂度是多少？如何优化？](#q快排的基本思路是什么最差的时间复杂度是多少如何优化)
        * [Q：AVL树插入或删除一个节点的过程是怎样的？](#qavl树插入或删除一个节点的过程是怎样的)
* [语言方面](#语言方面)
    * [Rust](#rust)
        * [Q：宏与过程宏](#q宏与过程宏)
        * [Q：Box](#qbox)
        * [Q：Trait Object](#qtrait-object)
        * [Q：动态分发和静态分发](#q动态分发和静态分发)
        * [Q：Drop & Deref](#qdrop-deref)

<!-- vim-markdown-toc -->


# 计算机网络




## 基础




### Q：五层协议的体系结构分别是什么？每一层都有哪些协议？

> https://blog.csdn.net/cainv89/article/details/46885197

应用层，应用层确定进程之间通信的性质以满足用户的需要。应用层不仅要提供应用进程所需要的信息交换和远地操作，还要作为互相作用的应用进程的用户代理（user agent)；

运输层任务是负责主机中两个进程间的通信；

网络层网络层负责的是分组选择合适的路由；

数据链路层数据链路层的任务：将在网络层交下来的数据报组装成帧（frame)，两个相邻结点间的链路实现帧的传输；

物理层物理层的任务：透明地传输比特流。 





### Q：为何有MAC地址还要IP地址？

> http://blog.sciencenet.cn/blog-411071-1037673.html

基本上一个观点就是一个是物理地址，一个是逻辑地址。

假设两点在一个网络内。在这种情况下，只需要MAC地址就可以了。例如通过交换机将多台电脑组成一个网络。

然而，如果两点不在一个网络内。这时就需要IP地址了。因为IP地址含有两个部分，一个是网络地址，一个是主机地址。因此，通过对方的IP地址，是可以判断出对方是否和本机在一个网络内。如果在一个网络内，如上所述，只需要知道对方的MAC地址即可通信。

如果不在一个网络内，本机的网络层就认为数据应该发送给网关。道理是显然的，如果不在一个网络内，首先得把数据发送出网络才可以。如何发出网络，当然是发给网关，因为网关就相当于网络的门卫。要想把数据发给网关，同样需要知道网关的MAC地址，如何知道网关的MAC地址呢？这就涉及到ARP协议。

电脑缓存里有一张ARP表，该表主要有两列：一列是IP地址，另外一列是MAC地址。这张表不是天生就有的，是随着网卡收到网络中的各种通信数据，不断学习增加的。

话说回来，如果ARP表中有网关IP地址对应的MAC地址，则问题就转化为网内数据发送，上面已经讲的很清楚了。如果ARP表中没有网关IP地址对应的MAC地址，则启动ARP协议，即向网内广播，询问该IP地址的MAC地址。广播询问的结果是网关收到广播后，发现是问自己的MAC地址，所以就回复询问方自己的MAC地址。然后数据发给网关的问题，也转化为网内数据发送。




## TCP



### Q：TCP特性

- TCP 提供一种**面向连接的、可靠的**字节流服务
- TCP 使用校验和，ACK确认和重传机制来保证可靠传输
- TCP 使用累积确认保证数据的顺序不变和非重复
- TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制



### Q：TCP和UDP的区别？

> https://blog.csdn.net/xiaobangkuaipao/article/details/76793702

> https://www.cnblogs.com/jingliming/p/4477264.html

1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接

2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付

Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。

3、UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。

4.每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信

5、TCP对系统资源要求较多，UDP对系统资源要求较少。




### Q：拥塞控制和流量控制都是什么，两者的区别？

> https://blog.csdn.net/ailunlee/article/details/53716367

流量控制是端到端的控制，例如A通过网络给B发数据，A发送的太快导致B没法接收(B缓冲窗口过小或者处理过慢)，这时候的控制就是流量控制，原理是通过滑动窗口的大小改变来实现。 
拥塞控制是A与B之间的网络发生堵塞导致传输过慢或者丢包，来不及传输。防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不至于过载。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络性能有关的所有因素。





### Q：谈谈TCP为什么要三次握手？为什么要四次挥手？

> https://blog.csdn.net/zhaobudaofangxia/article/details/55260259

> https://zhuanlan.zhihu.com/p/53374516

> https://draveness.me/whys-the-design-tcp-three-way-handshake/

三次握手：(验证双方的收发能力正常)

    第一次。A跟B说，我要建立连接了			SYN 		(new SEQ)
    第二次。B跟A说，OK那我也建立连接			SYN + ACK 	(new SEQ)
    第三次。A跟B说，嗯，我知道了。			ACK

**第三次握手解决历史链接问题**：

为了阻止历史的重复连接初始化造成的混乱问题，防止使用 TCP 协议通信的双方建立了错误的连接；

接收方只能选择接受或者拒绝发送方发起的请求，它并不清楚这一次请求是不是由于网络拥堵而早早过期的连接。

使用三次握手和 `RST` 控制消息将是否建立连接的最终控制权交给了发送方。



四次挥手：（二四验证收到断开链接请求）

    第一次。A跟B说，我要断开连接了						FIN
    第二次。B跟A说，好的我不再接收你的信息了				ACK
    第三次。B跟A说，我传给你的信息传完了,你可以关闭连接了	FIN
    第四次。A跟B说，好的我关闭连接了						ACK

 














### Q：播放视频用TCP还是UDP？为什么？

TCP 和 UDP 是质量和实时性的权衡。
拿视频网站来说，你完全可以缓冲 20s 再播放，不会带来什么影响，但如果画面有马赛克之类的东西出现肯定是不好的，所以用 TCP。
而对于视频聊天，如果缓冲 5s，相信整个聊天已经没法愉快的进行了，而这时出现一些画面质量的损失也可以被接受，所以用 UDP。





### Q：TCP KeepAlive

TCP KeepAlive 的基本原理是，隔一段时间**给连接对端**发送一个**探测包**，如果收到对方回应的 **ACK**，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。

局限：

1. TCP KeepAlive 监测的方式是发送一个 probe 包，会给网络带来额外的流量
2. 只能在内核层级监测连接的存活与否，而连接的存活不一定代表服务的可用。






## HTTP




### Q：HTTP报文格式？

> https://blog.csdn.net/holmofy/article/details/68492045

Requst: Method + URL + Version

Response: Version + Status + Description




### Q：了解哪些响应状态码？

> https://blog.csdn.net/oops_qu/article/details/75675702

> 1xx（临时响应）：表示临时响应并需要请求者继续执行操作的状态代码。

> 2xx （成功）：表示成功处理了请求的状态代码。

> 3xx （重定向）：表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。

> 4xx（请求错误）：这些状态代码表示请求可能出错，妨碍了服务器的处理。

> 5xx（服务器错误）：这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。



301: 永久移动

302: 临时移动

401: 身份验证未授权

403: 禁止

405: 方法禁用




### Q：GET和POST的区别？

> https://www.cnblogs.com/huaxingtianxia/p/5895236.html

GET在浏览器回退时是无害的，而POST会再次提交请求。
GET请求会被浏览器主动cache，而POST不会，除非手动设置。
GET请求只能进行url编码，而POST支持多种编码方式。
GET请求在URL中传送的参数是有长度限制的，而POST么有。
GET参数通过URL传递，POST放在body中。



GET产生一个TCP数据包, POST产生两个TCP数据包。

POST情况下，浏览器先发送header，服务器响应100 CONTINUE；浏览器再发送data，服务器响应200。

但并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。



### Q：HTTP1.0和1.1的区别？

> https://blog.csdn.net/linsongbin1/article/details/54980801/

> https://www.jianshu.com/p/7bfec28236c3

**长连接**

- HTTP1.1 支持长连接和流水线处理。但长连接中每个请求都是**串行**的，会产生队头阻塞问题。



**节约带宽**

- `range`头信息，可以向服务器请求数据的一部分。
- `content-encoding`提供双方的编码方式，以便压缩信息。
- `100 Continue`状态码：客户端在每个请求时首先发送header，服务器检查有效性，返回`100`或`40x`状态码。



HOST域

- IP地址绑定一个HOST域名，每个IP可能绑定不同域名。



缓存策略

- 除了HTTP1.0 提供的`If-Modified-Since`，HTTP2.0 提供了更多的缓存头进行更好的缓存策略。



错误通知

- 更多的错误码





### Q：HTTP1.1和2.0的区别？

> https://blog.csdn.net/linsongbin1/article/details/54980801/

> https://www.jianshu.com/p/7bfec28236c3



**多路复用**

- 相比较与HTTP1.1的piplining，多路复用对请求提供了**并发**的能力，消除了队头阻塞问题。



**头部数据压缩**

- HTTP1.1对消息体进行gzip压缩，或本身就是压缩过的内容；对请求头和请求行明文传输。
- HTTP2.0在基础上使用HPACK算法对头进行压缩。



**服务器推送**

- HTTP1.1对每个资源都做请求；HTTP2.0 引入服务器推送，允许服务器推送请求之外的内容。






### Q：HTTP和HTTPS的区别?

多一层TLS，以防中间人，保证安全。




### Q：在地址栏打入http://www.baidu.com会发生什么？

> https://github.com/skyline75489/what-happens-when-zh_CN

检查 HSTS 列表
DNS 查询
ARP 过程
TCP 握手
TLS 握手
HTTP 协议





### Q：1.0短链接、1.1长连接、2.0多路复用？

> https://www.cnblogs.com/gotodsp/p/6366163.html

> https://www.cnblogs.com/Paul-watermelon/p/10467662.html

HTTP/1.0使用短连接。客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。客户端浏览器每遇到一个Web资源，浏览器就会重新建立一个HTTP会话(TCP连接)。



HTTP/1.1默认使用长连接。`Connection:keep-alive`。当一个网页打开完成后，TCP连接不会关闭，客户端会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件中设定这个时间。

HTTP/1.1 Pipeline解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；



HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行




### Q：HTTPS原理及认证过程

**对称加密**

- 双方使用同一个密钥去加密和解密数据。
- 特点是速度快，适合于对大数据量进行加密。<br>缺点是密钥安全管理困难
- 常见的对称加密算法有DES、3DES、TDEA、Blowfish、RC5和IDEA。
- **明文 + 加密算法 + 私钥 => 密文**<br>**密文 + 解密算法 + 私钥 => 明文**



**非对称加密**

- 用公钥或私钥中的任何一个进行加密，用另一个进行解密。
- 私钥被自己保存，不能对外泄露。公钥指的是公共的密钥，任何人都可以获得该密钥。
- 花费时间长、速度慢。
- 在非对称加密中使用的主要算法有：RSA、Elgamal、Rabin、D-H、ECC等。
- **明文 + 加密算法 + 公钥 => 密文， 密文 + 解密算法 + 私钥 => 明文**<br>**明文 + 加密算法 + 私钥 => 密文， 密文 + 解密算法 + 公钥 => 明文**



**HTTP + TLS1.2 通信过程**

1. 客户端发送HTTP请求
2. 服务器返回证书公钥
3. 客户端进行证书验证，若验证失败则放弃后续访问。<br>验证成功则生成随机字符串作为后续对称加密的密钥。<br>密钥经过非对称加密的公钥后，发送给服务器，通知服务器之后的消息用对称密钥加密。
4. 服务器接受数据用非对称加密的密钥进行解密。<br>拿到密钥后，通知客户端之后的消息用对称密钥加密，完成TLS1.2握手。



**CA认证**

> CA机构（Certificate Authority）即颁发数字证书的机构。是电子交易、网络数据交流中权威的受信任的第三方机构，承担公钥体系中公钥的合法性检验的责任。

- 服务器的证书首先在CA机构中通过申请；客户端验证证书方法是向权威CA机构校验
- 证书验证的过程依赖于证书信任链，即一个证书要依靠上一级证书来证明自己是可信的，最顶层的证书被称为根证书，拥有根证书的机构被称为根 CA。根证书一般是操作系统自带的




### Q：QUIC是什么

> https://zhuanlan.zhihu.com/p/32553477

Quic即“快速 UDP 互联网连接”，是由 google 提出的使用 udp 进行多路并发传输的协议。

Quic 相比现在广泛应用的 http2+tcp+tls 协议有如下优势：

- **连接建立延时低** : 0RTT建立链接(曾有过链接) vs 3RTT链接 

- **改进的拥塞控制**：基于TCP 协议

- **没有队头阻塞的多路复用**：在一条 QUIC 连接上可以并发发送多个 HTTP 请求 (stream)，互相之间没有依赖 vs HTTP2

- **加密认证的报文**




### Q：为什么 HTTPS 需要 7 次握手以及 9 倍时延

> https://draveness.me/whys-the-design-https-latency/

(HTTPS 使用安全套接字层SSL保证数据传输的安全，随着传输层安全协议TLS的发展，目前我们已经使用 TLS 取代了废弃的 SSL 协议)

- TCP 协议 — 通信双方通过三次握手建立 TCP 连接；1.5 RTT；
- TLS 协议 — 通信双方通过四次握手建立 TLS 连接；2 RTT；
- HTTP 协议 — 客户端向服务端发送请求，服务端发回响应；1 RTT；

**TLS**

TLS 的作用是构建安全的传输通道（本身不提供可靠性保障）。在通信双方建立可靠的 TCP 连接之后，我们就需要通过 TLS 握手交换双方的密钥了。

TLS 握手的关键在于利用通信**双方生成的随机字符串**和**服务端的公钥**生成一个双方经过协商后的密钥，通信的双方可以使用这个**对称的密钥加密**消息防止**中间人**的监听和攻击，保证通信的安全。




### Q：50x错误各代表什么意义

500: 程序内部错误

501: 服务器不具备完成请求的功能

502: 错误网关 (web容器收到了无法理解的响应)

503: 服务不可用 (停机维护)

504: 网关超时 (超过了web容器的超时时间，不等待程序的返回结果)

505: HTTP版本不支持




### Q：Cookie / Session / Token 

> https://zhuanlan.zhihu.com/p/129227994

HTTP 协议是一种`无状态协议`，即每次服务端接收到客户端的请求时，都是一个全新的请求，服务器并不知道客户端的历史请求记录；Session 和 Cookie 的主要目的就是为了弥补 HTTP 的无状态特性。



**Cookie**

- 服务器发送到浏览器的 Cookie，浏览器会进行存储，并与下一个请求一起发送到服务器。
- 响应头`Set-Cookie`，请求头`Cookie`工作原理。
- 过期时间，域，HttpOnly



**Session**

- 客户端请求服务端，服务端会为这次请求开辟一块`内存空间`，存储客户端在同一个会话期间的一些记录。
- 服务器第一次返回响应时，带有`Set-Cookie：SESSIONID=XXXXXXX`；<br>客户端在本机客户端设置此Cookie，该 Cookie 的过期时间为浏览器会话结束；<br>客户端每次向同一个网站发送请求时，请求头都会带上该 Cookie信息；<br>服务器每次读取请求头中的 Cookie 信息，获取SessionId，获得状态。
- 负载均衡后，需要Session数据库提供一致性能力。



**Token**

- 服务器生成加密令牌，客户端请求带上Token，服务器校验。一般放在cookie里。
- **无状态**：减轻服务器的压力，减少频繁的查询数据库
- JWT格式: header.payload.sign






# 操作系统




## 基础




### Q：操作系统中进程和线程的区别？

进程是资源分配的最小单位，线程是CPU调度的最小单位。




### Q：死锁的产生和避免?

> https://www.cnblogs.com/fangrong/p/5271724.html

死锁的四个必要条件：
(1)互斥条件(Mutual exclusion)：资源不能被共享，只能由一个进程使用。
(2)请求与保持条件(Hold and wait)：已经得到资源的进程可以再次申请新的资源。
(3)非剥夺条件(No pre-emption)：已经分配的资源不能从相应的进程中被强制地剥夺。
(4)循环等待条件(Circular wait)：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。

死锁避免（deadlock avoidence）是在系统运行过程中注意避免死锁的发生。这就要求每当申请一个资源时，系统都应根据一定的算法判断是否认可这次申请，使得在今后一段时间内系统不会出现死锁。这面方最著名的算法首推Dijkstra[1965]提出的银行家（banker）算法。




### Q：虚拟内存、分页、页表的组织形式

**基本分页**

- 固定分区会产生内碎片，动态分区会产生外碎片；为了尽量避免内存碎片，提出基本分页存储。<br>它将主存空间分为固定相等的小块，作为主存的单元。进程在申请内存时，以页为单位进行请求。<br>（进程中为页，内存中为页框，外存中为块。无外碎片，平均半个页的内碎片。）
- **页面大小取舍**
  - 太小：页表过大（浪费内存），地址转换频繁（浪费时间）
  - 太大：内碎片过大（浪费内存）
- **页表**：
  - 便于寻找页面对应的物理块，系统在内存中为每个进程维护一张页表。
  - 实际上是物理块号的数组，其索引为页号。
- **基本地址变换机构**：
  - 逻辑地址结构： `| 页号 | 页内偏移量 |`
  - 页表寄存器：`| 页表起始地址 | 页表长度 |`
  - 检查逻辑地址页号长度小于页表长度，计算页表中对应页号地址，取出块号拼接偏移量。
- **快表**
  - 具有并行查找能力的高速缓冲器，用于提升地址变换速度（减少一次查页表的访存）。
  - 实际上为`| 页号 | 块号 |`的数组
  - 在原有变换流程基础上，首先查找快表，取出块号拼接偏移量。
- **两级页表**
  - 为了压缩页表大小，不去存储无用的页表项，系统在内存中为每个进程维护一张二级页表。
  - 逻辑地址结构： `| 一级页号 | 二级页号 | 页内偏移量 |`



**请求分页** 

- 虚拟内存的一种实现方式。虚存基于时空局部性，当内存暂时不使用时换出至外存。系统为用户提供了一个比物理空间大得多的虚拟空间，故称虚存。
- 只需一部分页面装入内存，程序即可运行。当需要访问不在内存中的页面时，通过**请求调页**功能调入，同时置换不用的页面至外存。
- **页表**：为了发现和处理请求页面时，页面是否存在和调出等问题，加入另外一些字段。（如访问位，修改位等）
- **地址变换机构**：首先查找快表，（若不存在）再查找页表；查看页表是否已调入，（若缺页）产生缺页中断，请求调页。
- **缺页中断机构**：CPU遇到缺页中断后，阻塞缺页进程；若内存中无空闲页框，则按**页面置换算法**淘汰某页，再调入目标页面。
- **页面置换算法**：LRU实现使用哈希表+双向链表，读写移动至表头，替换时删除表尾。





### Q：Linux IO模式
> https://segmentfault.com/a/1190000003063859

对于一次IO访问：
1. 数据会先被拷贝到**操作系统内核的缓冲区**中
2. 从操作系统内核的缓冲区拷贝到**应用程序的地址空间**。

所以说，当一个read操作发生时，它会经历两个阶段：
1. 等待数据准备
2. 将数据从内核拷贝到进程中

正式因为这两个阶段，linux系统产生了下面五种网络模式的方案。
- 阻塞 IO
- 非阻塞 IO
- IO 多路复用
- 信号驱动 IO
- 异步 IO

**阻塞 IO**
- 当用户进程调用 recvfrom 系统调用后  
	kernel准备数据&拷贝至用户空间；  
	用户两个过程阻塞。
- 在linux中，默认socket都是blocking.

**非阻塞 IO**
- 当用户进程调用 recvfrom 系统调用后  
	kernel准备数据&拷贝至用户空间；  
	用户第一个过程可不断调用IO，kernel不断返回error，直至第一个过程结束。  
	用户第二个过程调用IO后阻塞。
- 在linux中，socket可以设置为non-blocking.


**IO 多路复用**
- IO 多路复用就是我们说的select，poll，epoll，（也称事件驱动 IO）。
- 原理是select，poll，epoll函数不断轮询所有文件描述符，当某个文件有数据到达，就通知用户进程。
- 当用户进程调用 select / poll 系统调用后，对每个文件描述符：  
	kernel准备数据&拷贝至用户空间；  
	用户第一个过程阻塞，直至kernel结束第一过程，并返回。  
	用户第二个过程调用IO后阻塞。
- 优点在于单进程可以同时处理多个网络连接IO。
- 所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好。


**异步 IO**
- 当用户进程调用 aio_read 系统调用后：  
	kernel立即返回，并准备数据&拷贝至用户空间，完毕后向用户进程发送信号；  
	用户两个过程皆不阻塞。



### Q：select / poll / epoll
> https://zhuanlan.zhihu.com/p/93609693

1. select / poll: 监听文件描述符list，进行一个线性的查找 O(n)
2. poll: 取消 select 的最大链接数量限制
2. epoll: 使用了内核文件级别的回调机制O(1)

epoll相比于select并不是在所有情况下都要高效，例如在如果有少于1024个文件描述符监听，且大多数socket都是出于活跃繁忙的状态，这种情况下，select要比epoll更为高效，因为epoll会有更多次的系统调用，用户态和内核态会有更加频繁的切换。



# 数据库




## 基础




### Q：数据库中的事务了解吗？事务的四大特性？

**原子性**
    数据修改操作要么全部执行，要么完全不执行

**一致性**
    数据库的状态满足所有的完整性约束

**分离性**
    并发事务相互隔离，互不相影响

**持久性**
    已提交事务的更新不能丢失。即一旦一个事务提交，数据库中数据的改变应该是永久性的




### Q：如何理解数据库的范式？

> https://blog.csdn.net/zymx14/article/details/69789326

第一范式：确保每一列的原子性

第二范式：非键字段必须依赖于键字段
    如果一个关系满足1NF，并且除了主键以外的其它列，都依赖与该主键，则满足二范式(2NF)，第二范式要求每个表只描述一件事。

第三范式：在1NF基础上，除了主键以外的其它列都不传递依赖于主键列，或者说： 任何非主属性不依赖于其它非主属性

（在2NF基础上消除传递依赖）

BCNF：主键不**部分**依赖与码



### Q：索引

> [数据库两个神器索引和锁(修订版) ](https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484721&idx=1&sn=410dea1863ba823bec802769e1e6fe8a&chksm=ebd74430dca0cd265a9a91dcb2059e368f43a25f3de578c9dbb105e1fba0947e1fd0b9c2f4ef&token=1676899695&lang=zh_CN#rd)



√ 使用索引为什么可以加快数据库的检索速度？

√ 为什么说索引会降低插入、删除、修改等维护任务的速度。

√ Hash索引和B+树索引有什么区别？主流的使用哪一个比较多？InnoDB存储都支持吗？

​	支持并使用**B+树索引比较多**，InnoDB不支持Hash但提供**自适应哈希索引**

聚集索引和非聚集索引有什么区别？

索引的最左匹配原则指的是什么？



  

**存储结构基础知识**

- Mysql的基本存储结构是**页**；数据页之间组成一个**双向链表**；而**每个数据页中的记录**又可以组成一个**单向**链表
- 每个数据页都生成一个**页目录**：在通过**主键**搜索时，在页目录中**二分**到对应目录；在**非主键**搜索时，只能从最小记录开始**遍历单链表**。

  

**B+树索引**

- InnoDB 存储引擎在绝大多数情况下使用 B+ 树建立索引，**一个节点就是一个页**
-  B+ 树索引只能找到数据行对应的页，然后数据库把整个页读入到内存中，并在内存中查找具体的数据行。
- B+ 树是平衡树，它查找任意节点所耗费的时间都是完全相同的，比较的次数就是 B+ 树的高度
- **要维持平衡树，就必须做额外的工作**。正因为这些额外的工作**开销**，导致索引会降低增删改的速度

  



**哈希索引**

- 哈希索引没法利用索引完成**排序**
- 不支持**最左匹配原则**
- 在有大量重复键值情况下，哈希索引的效率也是极低的：**哈希碰撞**问题。
- **不支持范围查询**

  

### Q：MySQL 多版本并发控制

通过一定机制生成一个数据请求**时间点的一致性数据快照（Snapshot)**，并用这个快照来提供一定级别（**语句级或事务级**）的**一致性读取**。**MVCC读写是不阻塞**。



**Undo记录 版本链**  
MySQL InnoDB实现了多版本并发控制（MVCC），在多版本存储上，MySQL采用从新到旧（Newest To Oldest）的版本链。  
B+Tree叶结点上，始终存储的是**最新的数据（可能是还未提交的数据）**。  
而旧版本数据，通过UNDO记录（做DELTA）存储在回滚段（Rollback Segment）里。  
**每一条记录都会维护一个ROW HEADER元信息，存储有创建这条记录的`事务ID`，一个指向UNDO记录的`指针`。**  
通过最新记录和UNDO信息，可以还原出旧版本的记录。  



**ReadView 快照**      

ReadView描述某一个时间点，是事务执行状态的一个快照，可以用来判断事务的可见性。ReadView的基本结构如下：

```text
ReadView {
    creator_trx_id	// 创建这个ReadView的事务ID
    low_limit_id	// (未创建) 所有事务ID大于或等于low_limit_id对当前事务都不可见
    up_limit_id		// (已提交) 所有事务ID严格小于up_limit_id的事务对当前事务可见
    ids				// (执行中) 未提交的事务ID列表
    ...
}
```



**可见性的判断**

事务通过用当前事务（或语句，取决于隔离级别）的 ReadView 来判断一个事务id的操作是否对当前事务可见。判断可见性的伪代码如下：

```python
IsVisible(trx_id)
    if (trx_id == creator_trx_id)     	// 当前事务
        return true;
    else if (trx_id < up_limit_id)    	// ReadView创建时, 事务已提交
        return true;
    else if (trx_id >= low_limit_id)  	// ReadView创建时，事务还未被创建
        return false;
    else if (trx_id is in m_ids)  		// ReadView创建时，事务正在执行，但未提交
        return false
    else                          		// ReadView创建时, 事务已提交
        return true;
```





### Q：事务并发一致性异常 & 四大隔离级别
> [MySQL 是如何实现四大隔离级别的？](https://www.zhihu.com/question/263820564/answer/289269082)

> [再谈数据库事务隔离性](https://www.cnblogs.com/ivan-uno/p/8274355.html)

> [MVCC事务机制：Snapshot Isolation](http://www.nosqlnotes.com/technotes/mvcc-snapshot-isolation/)


|          | 脏读 | 不可重复读 | 幻读 | Read Skew | Write Skew          |
|----------|------|------------|------|-----------|---------------------|
| 读未提交 | √    | √          | √    | √         | √                   |
| 读已提交 |      | √          | √    | √         | √                   |
| 可重复读 |      |            | √    |           | √(仅对快照隔离等级) |
| 可串行化 |      |            |      |           |                     |



**丢失更新问题**：

1. 读未提交：事务未提交时可触发
2. 读已提交：事务已提交时可触发
3. 可重复读：**不可触发？？？**
4. 读未提交：不可触发



**并发一致性异常**：

1. 脏读：可以读到未提交的事务的记录数据
2. 不可重复读：两次读取的记录不同（已提交的事务）
3. 幻读：读取到的记录数量不同
4. Read Skew：两个变量有关联性，事务A读取到事务B对其中一个变量的修改，破坏了一致性。
5. Write Skew：两个变量有关联性，事务AB分别对不同变量进行写，破坏了一致性。



**隔离级别实现方法**：

**读未提交**：不加锁，没有进行隔离

**读已提交**：（MVCC 多版本并发控制，实为语句级别快照隔离）**每次读**时生成快照ReadView

**可重复读**：（MVCC 多版本并发控制，实为事务级别快照隔离）**首次读**时生成快照ReadView

**读未提交**：共享读 & 排他写 & `S2PL`两段锁协议



**其他隔离方法**：

快照隔离（SI,Snapshot Isolation）
串行化快照隔离（SSI, Serializable Snapshot Isolation)
随着技术的发展，SI/SSI已经成为主流数据库的隔离技术，尤其是后者的出现，无需开发人员在代码通过显式锁来避免异常，从而降低了人为错误的概率。






### Q：表级锁和行级锁



### Q：SQL优化



### Q：区间查找




# 数据结构与算法




## 基础



### Q：了解哪些排序算法，并比较一下，以及适用场景

> https://blog.csdn.net/mountain_hua/article/details/81107024

| 排序法     | 最差时间分析 | 平均时间复杂度 | 稳定度 | 空间复杂度      |
|------------|--------------|----------------|--------|-----------------|
| 冒泡排序   | O(n2)        | O(n2)          | 稳定   | O(1)            |
| 插入排序   | O(n2)        | O(n2)          | 稳定   | O(1)            |
| 选择排序   | O(n2)        | O(n2)          | 稳定   | O(1)            |
| 二叉树排序 | O(n2)        | O(n*log2n)     | 不一顶 | O(n)            |
| 快速排序   | O(n2)        | O(n*log2n)     | 不稳定 | O(log2n) ~ O(n) |
| 堆排序     | O(n*log2n)   | O(n*log2n)     | 不稳定 | O(1)            |
| 希尔排序   | O            | O              | 不稳定 | O(1)            |




### Q：快排的基本思路是什么？最差的时间复杂度是多少？如何优化？

> 优化：https://blog.csdn.net/sinat_28676875/article/details/69053449

```c++
int sort(vector<int>& nums, int l, int r) {
    if (l >= r) return;
    int ra = rand() % (r - l + 1) + l;
    swap(nums[ra], nums[l]);

    int i = l, j = r, x = nums[l];
    while (i < j) {
        while (i < j && nums[j] >= x) j--;
        if (i < j) nums[i++] = nums[j];

        while (i < j && nums[i] <= x) i++;
        if (i < j) nums[j--] = nums[i];
    }

    nums[i] = x;
    sort(nums, l, i, k);
    sort(nums, i+1, r, k);
}

```

优化方法：

1. 随机选择比较值
2. 元素少时用插入排序
3. 三向切分：大小关系分开后，将相等项排除递归





### Q：AVL树插入或删除一个节点的过程是怎样的？

> https://blog.csdn.net/Ivan_zgj/article/details/51495926

> https://blog.csdn.net/friendbkf/article/details/50160141




# 语言方面


## Rust



### Q：宏与过程宏

### Q：Box

### Q：Trait Object

### Q：动态分发和静态分发

### Q：Drop & Deref
