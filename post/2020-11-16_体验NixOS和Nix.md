# NixOS & Nix

11月15号这天，完成了Fabric的文档学习。
闲来无事，于是尝试向往已久的NixOS，尝试一下声明式的系统配置管理。
这次算是一次调研，一直想清理下乱乱的软件配置。
如果NixOS不能统一管理大多数配置文件的话，我再继续清理使用archlinux。



## 特性



### NixOS

NixOS是GNU/Linux发行版，旨在改善系统配置管理的最新水平。

在现有发行版中，升级之类的操作很危险：

- 升级软件包可能会导致其他软件包损坏
- 升级整个系统的可靠性要比从头开始重新安装低得多
- 无法安全地测试配置更改的结果

由此，NixOS提供了一些创新的功能。



#### 声明式系统配置模型

在NixOS中，**整个操作系统**(内核、应用程序、系统包、配置文件等等)都是**由Nix包管理器**根据纯函数式构建语言的描述构建的。

它是纯函数式的，这一事实本质上意味着构建**新配置不会覆盖旧配置**。其他大多数特性都是基于此。



**可重现的系统配置**

- 通过NixOS的声明性配置模型，可以轻松地在另一台机器上重现系统配置（例如，在生产服务器上进行测试之前先测试测试环境中的更改）。  
- 您只需将`configuration.nix`文件复制到目标NixOS计算机并运行`nixos-rebuild switch`。 除了“可变状态”（例如/  var中的内容）之外，这将为您提供相同的配置（内核，应用程序，系统服务等）。



#### 可靠的升级

纯函数式包管理的另一个优点是，无论您的系统上已经有什么包或配置文件，系统构建总是会产生相同的结果。

因此，升级系统和从头重新安装系统一样可靠。



**原子式升级**

- NixOS具有配置管理的事务性方法，即**配置更改是原子性的**。

- 这意味着，如果升级到新配置的过程中断了，比如电源中断了一半，**系统仍将处于一致状态**：它要么启动旧配置，要么启动新配置。在大多数其他系统中，您将最终处于不一致的状态，您的机器甚至可能不再启动。



**回退**

- 由于新配置的文件不会覆盖旧的文件，因此您可以回滚到以前的配置。 
- 实际上，所有旧系统配置都会自动显示在Grub引导菜单中。 因此，如果新配置崩溃或无法正常引导，则可以通过在Grub引导菜单中选择较旧的配置来进行回滚。 
- **回滚速度非常快**：它不涉及必须从副本中还原许多文件。



**安全地测试更改**

- 可以通过`nixos-rebuild test`来构建并激活新的配置，但不会使其成为引导默认设置。因此，重新启动系统将带您回到以前的、已知的良好配置。
- 更好的方法是构建并启动一个虚拟机。VM不与主机共享任何数据，因此您可以在VM内进行安全实验。



#### 包管理特性



**带有二进制文件的基于源码模型**

- NixOS使用的Nix构建语言指定了如何从源代码构建软件包。

- 这样可以轻松调整系统，只需在`/etc/nixos`中为NixOS或Nixpkgs编辑任何Nix表达式，然后运行nixos-rebuild。

- 但是，从源码构建也很慢。因此，如果可用，Nix会自动从nixos.org下载**预编译的二进制文件**。 这为二进制模型的效率提供了基于源的包管理模型的灵活性。



**依赖一致性**

- Nix软件包管理器可确保正在运行的系统与系统的逻辑规范“一致”，这意味着它将重建所有需要重建的软件包。

- 例如，如果您更改内核，Nix将确保还重建外部内核模块（例如NVIDIA驱动程序），因此您永远不会遇到X服务器在内核安全性升级后神秘地无法启动（笑）。 并且，如果您更新OpenSSL库，Nix会确保系统中的所有软件包都使用新版本，甚至包括静态链接到OpenSSL的软件包。



**多用户包管理**

- 在NixOS上，不需要root用户即可安装软件。除了系统范围的配置文件外，所有用户都有自己的配置文件，可以在其中安装软件包。

- Nix允许软件包的**多个版本共存**，因此不同的用户可以在各自的配置文件中安装同一软件包的不同版本。

- 如果两个用户安装了相同版本的软件包，则只会生成或下载一个副本，并且Nix的安全模型可确保此安全性。 用户无法安装setuid二进制文件。



#### 总结

总结一下，在NixOS这个部分，我认为最棒的亮点是**声明式配置管理**、**原子式升级**、**依赖一致性**。

考虑结合`yadm`来管理所有自定义的分散的软件依赖。



### Nix

- Nix是一个纯函数式的包管理器。其软件包是由没有副作用的函数构建的。

- 每个包都有自己唯一的子目录，目录的散列值说明了其所有依赖项的包的唯一标识符
- **其散列值是包构建依赖图的哈希值**。这是很多功能的核心。



#### 多版本

- 可以同时安装一个软件包的多个版本或变体。 
- 这可以防止动态链接库地狱，如升级或卸载之类的操作不会破坏其他应用程序的依赖。



#### 完整的依赖

- 某些包管理器不会保证依赖是否完整，如果你忘了构建包的时候依赖是什么样的，那么在其他机器上不一定能正常运行。
- 在Nix管理下，软件包的接口（我的意思是`/usr/include/xxx`）不是存储在同一目录下的，所以如果能够运行第三方的软件，就说明你的依赖指定是成功的。



#### 多用户支持

- 非特权用户也可以安全的安装软件，每个用户都在`Path`上记录自己的`store`目录。
- 同时如果每个用户都安装了同一个包，那么将不会二次构建它。



#### 管理构建环境

- Nix会自动为软件包设置构建环境。 

- 给定一个描述软件包依赖关系的Nix表达式，`nix-shell`将构建或下载那些依赖，然后启动一个Bash shell，其中包含所有必需的环境变量。



#### 其他

- **原子升级**：因为升级也不是覆盖原有软件，所以原子式的回退也是轻松的。
- **垃圾回收**
- **函数式软件包语言**
- **大量的软件包**：目前[6万多](https://nixos.org/)，对比archlinux[官方](https://www.archlinux.org/packages/)和[AUR](https://aur.archlinux.org/)则拥有7万5



#### 总结

在Nix包管理方面，依赖图的散列值很有意思，吸引我的是**多版本**、**多用户支持**和**大量软件包**



## 调研

> [One Week of NixOS](https://news.ycombinator.com/item?id=25024639)

> [My NixOS Desktop Flow](https://news.ycombinator.com/item?id=22984639)

这里列出一系列NixOS的缺点，它们有一部分甚至是致命的。

- Nix软件包维护者必须对所有软件进行大量修补，同时这些补丁的质量可能并不乐观

- Nix打破了其他语言的生态系统的集成

  - 例如，Erlang和Elixir程序包经过加密签名。 大多数erlang库都带有一个rebar.lock文件，其中包含依赖项的哈希值，因此已经确保了可复制的构建。 不幸的是，程序包散列与Nix派生SHA不兼容。

- `/nix`目录对所有用户都是可读的，因此您不能使用Nix来管理私有的信息。（？待验证）

  



### vs Archlinux

> [Why do I have to switch from Arch to NixOS?](https://discourse.nixos.org/t/why-do-i-have-to-switch-from-arch-to-nixos/5873)

> [Switching to Nixos from Arch Linux](https://ramsdenj.com/2017/06/19/switching-to-nixos-from-arch-linux.html)

NixOS和Arch是我最喜欢的发行版。 两者都位于设计空间的两个局部最大值处。 具有声明性功能和命令性，只需最少的工具层。



**缺点**

- 陡峭的学习曲线
- 可能会为不太常见的东西编写自己的包
- 对于程序中硬编码的路径可能会出现问题
- 包管理器更慢



### vs Guix

> [GuixSD vs NixOS](https://www.reddit.com/r/GUIX/comments/9zo42l/guixsd_vs_nixos/)

> [Guix vs. Nix](https://www.reddit.com/r/GUIX/comments/hxcq7d/guix_vs_nix/)

> <https://news.ycombinator.com/item?id=22877798>

> https://zhuanlan.zhihu.com/p/158217835

**优点**

- 包管理更快

**缺点**

- Nix**语言学习曲线陡峭**
- Guix更加FOSS
- **缺少更好的文档**