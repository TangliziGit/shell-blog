# 设计KV数据库的一些考虑

正在用Rust编写一个KV数据库，这个过程中考虑了不少问题。这些问题大部分都是共通的，其他的程序也会涉及到。



## 如何构建更好的 Rust CLI 应用

好的CLI应用应该包括：

1. 命令行参数获取: `clap`

2. 配置文件维护: `dotenv`

3. 环境变量获取: 

   可以使用`env::vars()` 

   **注意**：使用环境变量是应用间调用时常见的手段。如通过`cargo build`构建项目时，会通过环境变量向`rustc`发送一些作者信息、项目简介等信息。这些信息不便于放入编译器的参数中，同时使用环境变量也更容易维护，但需要文档来维系契约。

   

4. 错误处理: 

   见下文，主函数应只处理参数、内部模块的`Result`和功能无关的环境问题。使用`process::exit(1)`处理环境问题导致的失败。

   **注意**：区分失败、错误和异常。

   - 失败：契约未满足
   - 错误：可预知的问题，如文件权限不足等
   - 异常：不可预知的问题，如缺页异常

   

5. 杂项：错误输出`eprintln`，退出码`process::exit`



另外每个实际项目都应该编写rust文档，<https://rust-lang.github.io/api-guidelines/documentation.html>这里提供了编写更好文档的一些要求。



## 如何设计更好的应用层协议

好的引用层协议应该：
1. 快速解析
2. 肉眼可读
3. 空间消耗小

实际上我认为前两个中第二个最重要的，因为可以节省大量的协议层面的调试时间。
又或者可以原型设计时肉眼可读，而发布时使用等价的协议。

下面用`Redis`的应用层协议举例。



### Redis 应用层协议



#### 应答模型

Redis 的 Client - Server 应答模型有三种：
1. 最常见的one by one模式：客户端一句命令，服务器处理后回复一句
2. 流水线方式：客户端n句命令，服务器全部处理后回复一句（事务）
3. 发布订阅：客户端建立链接，不再主动请求；服务器不断push



#### Redis 序列化协议 - RESP

首先，此协议中包括一些类型：String, Error, Integer, Bulk String, Array.  
每一种类型都有对应的种类字符，以便区分和解析。  

除 Bulk String 和 Array 序列化比较特殊外，其余都按如下方式序列化：  
` <type char> {content} \r\n `  

而特殊的两种则包含了长度信息，以达到`二进制安全`：  
- Bulk String: ` <type char> <length> \r\n {content} \r\n`  
- Array: ` <type char> <length> \r\n {content}`  

同时注意 Array 可以包含不同类型，这可以用来描述调用函数的请求。

例：
```
+OK\r\n 
-Error message\r\n 
:1000\r\n 
$6\r\nfoobar\r\n 
*2\r\n$3\r\nfoo\r\n$3\r\nbar\r\n
```

具体的场景下，是这样使用的:
```
C: *2\r\n
C: $4\r\n
C: LLEN\r\n
C: $6\r\n
C: mylist\r\n

S: :48293\r\n
```

显然，解析速度、可读性和空间消耗都达到了不错的程度。  



#### 流水线方式

Redis 支持`telnet`，在这种会话的形式下，流水线方式（或叫内联）被启用。
其实就是空格隔开参数的直接形式，较 RESP 而言，少了结构化的类型信息。

例：
```
C: PING
S: +PONG
C: EXISTS somekey
S: :0
```

在人类手动编写命令时，做类型解析是必要的了。



## 关于错误处理的设计

- 如果你在写短小的演示代码（比如算法题目）：  
使用`unwrap`和`except`处理错误

- 如果你在写一个简单的程序（且不怕别人接手的时候感到难受）：  
使用`Box<dyn Error>`或`Box<dyn Error + Send + Sync>`。  
另一个省事的选择是使用`anyhow::Error`，他会自动打印backtrace。  

- 如果你在写一个正式的项目：  
  定义自己的`Error`，并实现`Error` trait 和 `From` trait。  
  同时在`Option`和`Result`上使用组合子和`?`操作符。  
  常用的组合子包括：`map`, `and_then`, `unwrap_or`, `unwrap_or_else`, `ok_or`用于`Option`转`Result`.

  

### 如何自定义`Error`

1. 使用`enum`  
    可以存各种其他库的错误类型
2. 实现`Error: Debug + Display` trait 中的`description`和`cause ` 
    前者便于展示错误原因，后者用于检查错误链  
    （同时`Error`可以被装入`Box<dyn Error>`中，不过在自己的库中，`Result<_, MyError>`更为常见  
3. 实现`From<OtherError>` trait   
    便于错误向上转换到我们的错误类型  
    注意`try!`中的模式匹配，显式的使用`From::from`来转换`Error`  



### 如何使用`failure`第三方库

化简一下第三方库文档，便于记忆使用
1. 原型或不需要错误链的情况  
    使用`Rusult<(), failure::Error>`和`format_err!()`
    前者可以转换`impl Fail`对象，后者直接返回字符串错误
2. 大型项目或需要错误链情况  
    自定义`Error`和`ErrorKind`
    例：
    ```rust
    #[derive(Debug)]
    struct MyError {
        inner: Context<MyErrorKind>,
    }

    #[derive(Copy, Clone, Eq, PartialEq, Debug, Fail)]
    enum MyErrorKind {
        #[fail(display = "A contextual error message.")]
        OneVariant,
    }

    // 样板代码
    impl Fail for MyError {
        fn cause(&self) -> Option<&Fail> {
            self.inner.cause()
        }

        fn backtrace(&self) -> Option<&Backtrace> {
            self.inner.backtrace()
        }
    }

    impl Display for MyError {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            Display::fmt(&self.inner, f)
        }
    }

    // 样板代码
    impl MyError {
        pub fn kind(&self) -> MyErrorKind {
            *self.inner.get_context()
        }
    }

    impl From<MyErrorKind> for MyError {
        fn from(kind: MyErrorKind) -> MyError {
            MyError { inner: Context::new(kind) }
        }
    }

    impl From<Context<MyErrorKind>> for MyError {
        fn from(inner: Context<MyErrorKind>) -> MyError {
            MyError { inner: inner }
        }
    }
    ```



## 常用框架

- `clap`：CLI参数读取
- `serde`：序列化 & 反序列化
- `slog`: 结构化日志
- ~~`Rayon`：简单易用的并行计算库~~
- ~~`Crossbeam`：扩展标准库功能的并发库~~
- ~~`Tokio`：Actor模型库~~



# 参考资料

- [Write a Good CLI Program](https://qiita.com/tigercosmos/items/678f39b1209e60843cc3)
- [Rust API Guidelines](https://rust-lang.github.io/api-guidelines/)
- [rust-lang-nursery](https://github.com/rust-lang-nursery)
- [Error Handling in Rust](https://blog.burntsushi.net/rust-error-handling/)
- [Redis Protocol specification](https://redis.io/topics/protocol): the redis client-server communication protocol
