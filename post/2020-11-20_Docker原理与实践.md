
<!-- vim-markdown-toc Marked -->

* [Docker原理](#docker原理)
    * [引擎](#引擎)
        * [架构与组件](#架构与组件)
        * [容器创建过程](#容器创建过程)
    * [镜像](#镜像)
    * [容器](#容器)
    * [网络](#网络)
        * [CNM](#cnm)
        * [Libnetwork](#libnetwork)
        * [网络驱动](#网络驱动)
    * [卷](#卷)
        * [驱动插件](#驱动插件)
    * [安全 / 隔离](#安全-/-隔离)
        * [Namespace](#namespace)
        * [Control Group](#control-group)
        * [Capability](#capability)
        * [MAC 强制访问控制](#mac-强制访问控制)
        * [Seccomp 安全计算](#seccomp-安全计算)
* [Docker 实践](#docker-实践)
    * [构建镜像](#构建镜像)
        * [最佳实践](#最佳实践)
        * [使用`BuildKit`](#使用`buildkit`)
    * [标签与日志](#标签与日志)
            * [修剪无用对象](#修剪无用对象)
            * [格式化日志](#格式化日志)
    * [容器](#容器)
        * [重启策略](#重启策略)
        * [容器保活](#容器保活)
        * [运行多个进程](#运行多个进程)
        * [状态信息](#状态信息)
        * [日志](#日志)
        * [安全](#安全)
        * [扩展](#扩展)
    * [网络](#网络)
        * [网络驱动](#网络驱动)
        * [其他](#其他)
    * [持久化数据](#持久化数据)
    * [其他](#其他)
            * [监控Docker实例](#监控docker实例)
            * [守护程序](#守护程序)

<!-- vim-markdown-toc -->

# Docker原理

> 部分引用自Docker Deep Dive，Docker 版本 18.01



## 引擎

- 将原有Docker daemon解耦并组件化，使客户端、后端（API和容器管理）和容器松耦合，可独立运行。



### 架构与组件

![Docker引擎的架构](https://imgconvert.csdnimg.cn/aHR0cDovL2MuYmlhbmNoZW5nLm5ldC91cGxvYWRzL2FsbGltZy8xOTA0MTYvNC0xWjQxNjE0MTAyTTYzLmdpZg)



### 容器创建过程

- containerd将Docker镜像转换为OCI bundle
- runc仅创建容器，创建完成后即终结
- 容器的进程作为子进程，一旦容器进程的父进程 runc 退出，相关联的 containerd-shim 进程就会成为容器的父进程。
  - 其职责是开启STDIO，并反馈退出状态给daemon。

![启动新容器的过程](https://imgconvert.csdnimg.cn/aHR0cDovL2MuYmlhbmNoZW5nLm5ldC91cGxvYWRzL2FsbGltZy8xOTA0MTYvNC0xWjQxNjE0MTMxMTJPLmdpZg)



## 镜像

- latest不保证一直最新，选用请谨慎
- 镜像由多层组成（镜像=未运行的容器）
  - 每个镜像层是只读的，容器的最后一层是可读写的。
  - 可以用快照来组合所有镜像层
  - 镜像层是可共享的，这提供了很好的复用性
  - 写时复制
- 存储引擎的工作：镜像分层、镜像层共享、写时复制
- 多架构镜像：
  - Docker 可以提供各种平台的镜像的能力
  - 维护一个`manifest`列表相当于一个`map[(arch, os)] -> manifast`
  - 由开发者对每个平台进行开发



## 容器

- 容器vs虚拟机
  - 虚拟机的额外开销：OS Tax，而容器仅有一个内核消耗各种硬件资源，只需要一个宿主机内核需要升级打补丁
  - 容器启动时间很快，它只是一个隔离宿主机的并维护一系列资源的进程
- 优雅停机
  - `docker stop`：发送`SIGTERM`信号并等待10s
  - `docker rm -f`：发送`SIGKILL`直接终止
- 重启策略



## 网络

![顶层设计](https://imgconvert.csdnimg.cn/aHR0cDovL2MuYmlhbmNoZW5nLm5ldC91cGxvYWRzL2FsbGltZy8xOTA0MTgvNC0xWjQxUTU1NjMzYzguZ2lm)

### CNM

Docker网络遵循CNM设计标准，它定义了 3 个基本要素：

- **沙盒**是一个独立的网络栈。其中包括以太网接口、端口、路由表以及 DNS 配置。
- **Endpoint 终端**就是虚拟网络接口。就像普通网络接口一样，终端主要职责是负责创建连接。在CNM中终端负责将沙盒连接到网络。
- **网络**是 802.1d 网桥（类似的交换机）的软件实现。因此网络就是需要交互的终端的集合，并且终端之间相互独立。

![CNM组件与容器进行关联](https://imgconvert.csdnimg.cn/aHR0cDovL2MuYmlhbmNoZW5nLm5ldC91cGxvYWRzL2FsbGltZy8xOTA0MTgvNC0xWjQxUTYwMDUxMzkzLmdpZg)



### Libnetwork

- Libnetwork 是 CNM 的具体实现，被 Docker 采用，它通过 Go 语言编写实现了 CNM 中定义的全部 3 个组件。
- 此外它还实现了本地服务发现、基于 Ingress 的容器负载均衡，以及网络控制层和管理层功能。



### 网络驱动

> 注意：截止19.03版本，自带的网络驱动增加了一个host驱动

![控制层、管理层与数据层的关系](https://imgconvert.csdnimg.cn/aHR0cDovL2MuYmlhbmNoZW5nLm5ldC91cGxvYWRzL2FsbGltZy8xOTA0MTgvNC0xWjQxUTYwMjMxTDcuZ2lm)



### 主要的三种网络模式



#### Host模式

`--net=host`

与宿主机在同一个网络中，但没有独立IP地址。

直接与宿主机共用一个网络命名空间，使用宿主的网卡、路由、iptable和ip等。



#### Container模式

`--net=container:NAME`

与某个容器共用一个网络命名空间。



#### Bridge模式

> https://wiki.archlinux.org/index.php/Iptables

>https://www.ipspace.net/kb/DockerSvc/30-nat-iptables.html

> https://www.frozentux.net/iptables-tutorial/iptables-tutorial.html

利用了宿主机的Linux Bridge，即内核的网桥功能创建网桥，容器链接这个网桥可访问外网。

默认的网络模式是`bridge`模式，同时默认链接到`docker0`网桥上。

自定义网络则会创建新的Bridge。



创建方式如下：

1. 在主机上创建一对虚拟网卡veth pair设备。veth设备总是成对出现的，它们组成了一个数据的通道，数据从一个设备进入，就会从另一个设备出来。因此，veth设备常用来连接两个网络设备。

2. Docker将veth pair设备的一端放在新创建的容器中，并命名为eth0。另一端放在主机中，以veth65f9这样类似的名字命名，并将这个网络设备加入到docker0网桥中，可以通过brctl show命令查看。

3. 从docker0子网中分配一个IP给容器使用，并设置docker0的IP地址为容器的默认网关。



同时，如果你查询`iptables`，会发现这些规则：

```shell
$ iptables-save 
# Generated by iptables-save v1.8.6 on Sat Dec  5 20:25:20 2020
*filter
:INPUT ACCEPT [410:38742]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [425:33954]
:DOCKER - [0:0]
:DOCKER-ISOLATION-STAGE-1 - [0:0]
:DOCKER-ISOLATION-STAGE-2 - [0:0]
:DOCKER-USER - [0:0]
COMMIT

# Completed on Sat Dec  5 20:25:20 2020
# Generated by iptables-save v1.8.6 on Sat Dec  5 20:25:20 2020
*nat
:PREROUTING ACCEPT [81703:33955372]
:INPUT ACCEPT [843:190047]
:OUTPUT ACCEPT [36856:2238898]
:POSTROUTING ACCEPT [36854:2238778]
:DOCKER - [0:0]
# 注意这两条，docker的实现
# 1. 直接从外网的访问本机的数据，转向DOCKER链
# 2. 剩下的本地进程发出的数据，转向DOCKER链
-A PREROUTING -m addrtype --dst-type LOCAL -j DOCKER
-A OUTPUT ! -d 127.0.0.0/8 -m addrtype --dst-type LOCAL -j DOCKER

# 配置网桥 - 将IP在网桥的网段上，同时不是从网桥网卡上发出的数据，IP字段改为宿主机IP
# 数据流动： data(container) -> eth0 -> docker0 ---(route)---> enp3s0 ---(iptabls[local process])---> (outside)
-A POSTROUTING -s 172.19.0.0/16 ! -o br-37fdd421936d -j MASQUERADE
-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE
-A POSTROUTING -s 172.27.0.0/16 ! -o br-83f2bde6ea91 -j MASQUERADE
-A POSTROUTING -s 192.168.192.0/20 ! -o br-05b6d5954698 -j MASQUERADE
-A POSTROUTING -s 172.17.0.2/32 -d 172.17.0.2/32 -p tcp -m tcp --dport 80 -j MASQUERADE

# 配置网桥 - 发出的数据通过默认网桥和自定义网桥，提早返回以免NAT
-A DOCKER -i docker0 -j RETURN
-A DOCKER -i br-37fdd421936d -j RETURN
-A DOCKER -i br-83f2bde6ea91 -j RETURN
-A DOCKER -i br-05b6d5954698 -j RETURN
# 配置网桥 - 接受的数据是目标地址，则进行NAT，目标地址将被重写为容器地址
-A DOCKER ! -i docker0 -p tcp -m tcp --dport 80 -j DNAT --to-destination 172.17.0.2:80
COMMIT
# Completed on Sat Dec  5 20:25:20 2020
```

需要注意的是：

```shell
$ route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         _gateway        0.0.0.0         UG    100    0        0 enp4s0
172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0
172.19.0.0      0.0.0.0         255.255.0.0     U     0      0        0 br-37fdd421936d
172.27.0.0      0.0.0.0         255.255.0.0     U     0      0        0 br-83f2bde6ea91
192.168.1.0     0.0.0.0         255.255.255.0   U     100    0        0 enp4s0
192.168.192.0   0.0.0.0         255.255.240.0   U     0      0        0 br-05b6d5954698
```





## 卷

数据主要分为两类，持久化的与非持久化的。

- 持久化数据是需要保存的数据。例如客户信息、财务、预定、审计日志以及某些应用日志数据。
  -  Docker 容器的非持久化存储自动创建，从属于容器，生命周期与容器相同。
- 非持久化数据是不需要保存的那些数据。
  - 这意味着删除容器也会删除全部非持久化数据。如果希望自己的容器数据保留下来(持久化)，则需要将数据存储在卷上。卷与容器是解耦的，从而可以独立地创建并管理卷



### 驱动插件

第三方驱动可以通过插件方式接入。这些驱动提供了高级存储特性，并为 Docker 集成了外部存储系统。截止到目前为止，已经存在 25 种卷插件，涵盖了块存储、文件存储、对象存储等。

- 块存储：相对性能更高，适用于对小块数据的随机访问负载。目前支持 Docker 卷插件的块存储例子包括 HPE 3PAR、Amazon EBS 以及 OpenStack 块存储服务（Cinder）。
- 文件存储：包括 NFS 和 SMB 协议的系统，同样在高性能场景下表现优异。支持 Docker 卷插件的文件存储系统包括 NetApp FAS、Azure 文件存储以及 Amazon EFS。
- 对象存储：适用于较大且长期存储的、很少变更的二进制数据存储。通常对象存储是根据内容寻址，并且性能较低。支持 Docker 卷驱动的例子包括 Amazon S3、Ceph 以及 Minio。



## 安全 / 隔离

![Docker安全技术](https://imgconvert.csdnimg.cn/aHR0cDovL2MuYmlhbmNoZW5nLm5ldC91cGxvYWRzL2FsbGltZy8xOTA0MjIvNC0xWjQyMjEyNDQwNjQwNy5naWY)



### Namespace

该技术能够将操作系统进行拆分，使一个操作系统看起来像多个互相独立的操作系统一样。

Docker  每个容器都由自己的 PID、NET、MNT、IPC、UTS 构成，还可能包括 USER 命名空间：

- 进程 ID 命名空间
  - 每个容器都拥有自己的**进程树**，意味着每个容器都有自己的 PID 为 1 的进程。PID  命名空间也意味着容器不能看到其他容器的进程树，或者其所在主机的进程树。 
- 网络命名空间
  - Docker 使用 NET  命名空间为每个容器提供互相隔离的**网络栈**。网络栈中包括接口、ID 地址、端口地址以及路由表。
- 挂载点命名空间
  - 每个容器都有互相**隔离的根目录** /。这意味着每个容器都有自己的  /etc、/var、/dev 等目录。容器内的进程不能访问 Linux  主机上的目录，或者其他容器的目录，只能访问自己容器的独立挂载命名空间。  
- 进程内通信命名空间
  - Docker使用IPC命名空间在容器内提供**共享内存**。IPC提供的共享内存在不同容器间也是互相独立的。
- 用户命名空间
  - Docker 允许用户使用 USER 命名空间**将容器内用户映射到主机不同的用户上**。常见的如将容器内的root用户映射到非 root 用户上。
- UTS 命名空间
  - Docker  使用 UTS 命名空间为每个容器提供自己的**主机名**。



### Control Group

- 控制组用于限额硬件资源。
- 容器之间是互相隔离的，但却**共享 OS 资源**，比如 CPU、RAM 以及硬盘 I/O。CGroup  允许用户设置限制，这样单个容器就不能占用主机全部的 CPU、RAM 或者存储 I/O 资源了。 



### Capability

类似于RBAC角色控制，这里控制了一些可用的权限。比如在底层，Linux root  用户是由许多能力组成的。其中一部分包括以下几点。

- `CAP_CHOWN`：允许用户修改文件所有权。
- `CAP_NET_BIND_SERVICE`：允许用户将socket绑定到系统端口号
- `CAP_SETUID`：允许用户提升进程优先级。
- `CAP_SYS_BOOT`：允许用户重启系统。

在插件开发时，可以在`config.json`中设定你需要的权限。



### MAC 强制访问控制

Docker 采用主流 Linux MAC 技术，如  AppArmor 以及 SELinux，指一种由操作系统约束的访问控制，目标是限制主体或发起者访问或对对象或目标执行某种操作的能力。

基于用户的 Linux 发行版本，Docker 对新容器**增加了默认的 AppArmor 配置文件**。根据  Docker 文档的描述，默认配置文件提供了“适度的保护，同时还能兼容大部分应用”。Docker  允许用户在启动容器的时候不设置相应策略，还允许用户根据需求自己配置合适的策略。



### Seccomp 安全计算

**seccomp** 是 secure computing 的缩写，其是 Linux kernel  从2.6.23版本引入的一种简洁的 sandboxing 机制。在 Linux 系统里，大量的系统调用（system  call）直接暴露给用户态程序。但是，并不是所有的系统调用都被需要，而且不安全的代码滥用系统调用会对系统造成安全威胁。seccomp安全机制能使一个进程进入到一种“安全”运行模式，该模式下的进程只能调用4种系统调用（system call），即 read(), write(), exit() 和 sigreturn()，否则进程便会被终止。

Docker 使用过滤模式下的 Seccomp 来限制容器对宿主机内核发起的系统调用。按照 Docker 的安全理念，每个新容器都会设置默认的  Seccomp 配置，文件中设置了合理的默认值。这样做是为了在不影响应用兼容性的前提下，提供适度的安全保障。用户同样可以自定义 Seccomp  配置，同时也可以通过向 Docker 传递指定参数，使 Docker 启动时不设置任何 Seccomp 配置。



# Docker 实践

> https://docs.docker.com/develop/



## 构建镜像



### 最佳实践

小镜像会拉取更快并且加载至内存更快。

- 选取小的基镜像
- 多阶段构建
  - 合并`RUN`指令
  - 在生产镜像之上，构建以提供测试和除错的阶段（可设定目标阶段）
  - 可使用外部镜像作为阶段
- 添加`tag`，如`prod`和`test`，不要依赖`lastest`
- 使用CI/CD进行测试和部署
- 持久化数据需要使用卷
  - 在开发时可以只使用绑定，使容器可以访问源代码
  - 但在生产时需要使用卷
- 在生产阶段的注意点
  - 使用卷来支持持久化存储
  - 使用用户命名空间提供更好的隔离性
  - 必须使用同一的NTP客户端



**细节**

- 你可以使用Here Documents来构建镜像

  - 注意`COPY`和`ADD`是可用的，仅当使用`-f-`指定当前位置

  ```shell
  docker build -t xxx -f- . <<EOF
  FROM busybox
  COPY somefile.txt .
  RUN cat /somefile.txt
  EOF
  ```

- 使用`.dockerignore`忽略一些文件




### 使用`BuildKit`

> https://docs.docker.com/develop/develop-images/build_enhancements/

针对18.09版本的docker build引入了对构建架构的全面大改。

使用 BuildKit 会看到性能，存储管理，功能和安全性方面的改进。

- 新的CLI输出
- `secret`信息
- 使用`ssh`接入私有数据



## 标签与日志

1. 标签是一种键值对，对 Docker 对象的管理起作用。
2. 除了Swarm的对象是可以动态更新标签的，其他的对象都是只能新建。
3. 标签的键主要是由反向DNS组成的，而值是无结构的字符串（可以填入json等结构）



下面是对象标签的创建方式：

- 镜像 / 容器
  - 在`Dockerfile`中创建`LABEL`
  - 创建容器时创建`docker run --label xxx=yyy`或`--label-file`
  - 镜像列表`dockr images -f "key=value"`
  - 容器列表`docker ps -f "key=value"`
- 卷 / 网络
  - 创建带有标签`create --label`
  - 查看使用`inspect`
  - 过滤使用`ls -f`
- 本地docker daemon
  - 启动时给定label
  - 查看`docker info`



#### 修剪无用对象

用`docker xxx prune`即可，可以使用`--filter`

- 镜像：删除悬垂镜像（无名镜像），用`-a`删除所有无用的
- 容器：删除停止的容器
- 网络和卷：删除没有被使用的
- `system`：删除上面所有的，和所有缓存



#### 格式化日志

在任何输出中（如`inspect`,`ls`）使用 golang 的模板，其内置一些[函数](https://docs.docker.com/config/formatting/)



## 容器



### 重启策略

docker run时可以指定容器重启策略：

1. `no`（默认）：不重启
2. `on-failure`：退出时返回非零值，重启
3. `always`：总是重启，在手动停止时当daemon重启后也会重启

注意：

1. 重新启动策略仅在容器成功启动后才生效,意味着该容器已启动至少10秒钟，并且Docker已开始对其进行监视，防止重启循环
2. 手动停止是无视重启策略的
3. 容器生命周期可以结合其他的**进程管理器**，如`systemd`



### 容器保活

这里值得是默认情况下，docker daemon挂掉了会同时停止容器。可以配置以保活容器，可以从配置文件下手，也可以从`dockerd`命令行下手。



### 运行多个进程

如果你的容器需要运行多个进程，务必确保它们是一个有机的整体。否则没有必要。

有三种方式可以做到：

1. 写一个脚本，用linux自带的后端运行即可
2. 写一个脚本，同时不退出此脚本用于检测所有进程是否正常运行
3. 用其他进程管理器控制，这时最重量级的方案



### 状态信息

除了从`docker stats`中获得状态信息外，还可直接从宿主机的`cgroup`文件中获得数据。

- 内存：`/sys/fs/cgroup/memory/docker/{CONTAINER ID}/memory.stat`
- CPU：`/sys/fs/cgroup/cpu/docker/{CONTAINER ID}/cpuacct.stat`
- 块IO：`/sys/fs/cgroup/blkio/docker/{CONTAINER ID}`

- 网络：并未提供，并没有一个简单的方法来收集这些网络指标。但需要注意docker会更改iptables



### 日志

- 除了默认的`docker logs`，可以自定义输出格式。
- 你还可以配置内置和第三方的**日志驱动**。



### 安全

> https://docs.docker.com/engine/security/



### 扩展

> https://docs.docker.com/engine/extend/

- 这部分介绍了插件的使用、开发和测试
- 插件只包括卷驱动插件、网络驱动插件、权限控制插件



## 网络



### 网络驱动

> https://docs.docker.com/network/network-tutorial-standalone/

> https://docs.docker.com/network/network-tutorial-standalone/

Docker的网络子系统可使用驱动程序插入。 默认情况下，有几个驱动，它们提供核心联网功能：

- bridge
  - 默认网络驱动程序，单机桥接网络
  - 桥接网络利用了 linux 的 bridge 网络接口，可以通过`brtcl`查看
  - 可链接公网，不可链接至宿主机本地回环，不可链接其他容器（除非同一网络）
  - DNS解析过程：
    1. Docker DNS `127.0.0.11`
    2. `--dns`参数指定
    3. `daemon`的默认DNS（默认`8.8.8.8`）
    4. 宿主机DNS配置

- host
  - 直接共享宿主机网络接口

- overlay
  - 覆盖网络将多个Docker守护进程连接在一起，并使群集服务能够相互通信。  
  - 在swarm中常用

- macvlan
  - Macvlan网络允许您为容器分配MAC地址，使其在网络上显示为物理设备。   Docker守护程序通过其MAC地址将流量路由到容器。
  - 需要网络接口开启混杂模式

- none
  - 对于此容器，禁用所有联网。 通常与自定义网络驱动程序一起使用。

- 网络插件
  - 您可以在Docker中安装和使用第三方网络插件。 这些插件可从Docker Hub或第三方供应商处获得。 有关安装和使用给定网络插件的信息，请参阅供应商的文档。



### 其他

- 可在配置文件中开启IPv6
- iptabls的设置，见[Docker and iptables](https://docs.docker.com/network/iptables/)
- 支持HTTP/HTTPS/FTP代理



## 持久化数据





## 其他



#### 监控Docker实例

- 用Prometheus，它是一个开源的系统监视和警报工具包



#### 守护程序

- 配置文件在`/etc/docker/daemon.json`中
- 持久化数据在`/var/lib/docker`中
