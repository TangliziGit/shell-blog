# [MIT6.824] Lecture12 - Pessimistic Distributed Transaction

## Lecture 12 - Pessimistic Distributed Transaction

事务的特性被总结为ACID，而这里要谈到的分布式事务会谈到其中两部分：第一个是并发控制（隔离性）第二个是原子提交。

### 悲观并发控制：两段锁

首先先提一下可串行化：并行的执行一些事物得到的结果，与按照某种串行的顺序来执行这些事务，可以得到相同的结果。实际的执行过程或许会有大量的并行处理，但是这里**要求得到的结果与按照一次一个事务的串行执行结果是一样的**。比如对两个并发事务AB而言，可串行化的调度可以保证所有情况下，都有与下面两种情况完全相同的结果：

```
S1: {A1, A2, A3, B1, B2, B3}
S2: {B1, B2, B3, A1, A2, A3}
```

并发控制主要有两种策略：悲观并发控制和乐观并发控制。

- **悲观并发控制**：**在事务使用任何数据之前，它需要获得数据的锁**。如果一些其他的事务已经在使用这里的数据，锁会被它们持有，当前事务必须等待这些事务结束，之后当前事务才能获取到锁。在悲观系统中，**如果有锁冲突，就会造成延时等待**。所以这里需要为正确性而牺牲性能。
- **乐观并发控制**：不用担心其他的事务是否正在读写你要使用的数据，你直接继续执行你的读写操作，通常来说这些执行会在一些临时区域，**只有在事务最后的时候，再检查冲突**是不是有一些其他的事务干扰了你。如果有一些其他的事务在同一时间修改了你关心的数据，并造成了冲突，**那么你必须要 Abort 当前事务，并重试**。

所以悲观并发控制会专注于锁机制。两阶段锁是最常见的锁机制，它是指某个事务中对锁的操作分为连续的获取和释放：

- 在使用任何数据之前，在执行任何数据的读写之前，先获取锁。
- 事务必须持有任何已经获得的锁，直到事务提交或者 Abort，你不允许在事务的中间过程释放锁。

注意：

- 为什么需要在事务结束前一直持有锁？
  - 因为不这样做的话，会让事务之间互相影响，导致调度结果是非可串行化的。
- 两阶段锁会非常容易造成死锁，如 `T1{get(x), get(y)} T2{get(y), get(x)}`
  - 事务有各种各样的策略，包括了判断循环，超时来判断它们是不是陷入到死锁中。如果是的话，数据库会 Abort 其中一个事务，撤回它所有的操作，并表现的像这个事务从来没有发生一样。

### 原子提交：两阶段提交

在一个分布式环境中，数据被分割在多台机器上，如何构建数据库或存储系统以支持事务？具体来说，如何应付错误，甚至是由多台机器中的一台引起的部分错误。这种部分错误在分布式系统中很常见。所以，在分布式事务之外，我们也**要确保出现错误时，数据库仍然具有可序列化和原子性**。

原子提交协议有很多，其中一种是两阶段提交（Two-Phase Commit）。它是指需要执行的任务会以某种方式分包在多个服务器上，每个服务器需要完成任务的不同部分。所以不仅在分布式数据库中会出现它，其他领域的分布式系统也会有类似的机制。

两阶段提交中存在一种角色，事务协调者。他们接受客户端的事务，并将具体命令发送给各个事务参与者，最后由协调者来判断事务提交或回退。最终的结果是，要么每个参与者都提交了变动，要么都没有提交。所以2PC能够保证原子性操作的主要原因是，作为单独节点TC不会发出不一致的Commit/Abort消息。如果每个参与者自己决定事务提交，那么会有很多难以处理的不一致问题。

类似于两段锁，事务参与者会维护一个锁的表单，用来记录锁被哪个事务所持有。两阶段提交的完整过程如下：

1. 客户端发送一个事务给事务协调者TC。

2. 事务协调者生成TID，并将每条命令依次发送给参与者执行。

   1. 参与者根据TID和具体命令在某个粒度上上锁
   2. 参与者会在这里实际执行命令，并结果返回给事务协调者。

   - （如果命令间没有依赖关系，似乎可以通过并发来提升性能）

3. 当所有命令都被执行后，TC将发送Prepare消息给所有参与者，询问能否准备提交。

   1. 参与者在这里可以返回No来一票否决。于是TC将触发事务回退abort。
      - 否决的原因，比如它们因为这个事务会引起死锁，或许它们在故障重启后并完全忘记了这个事务。
   2. 持久化事务的修改、该TID的所有的锁、和事务的prepare状态。这会在故障恢复时起作用。
   3. 响应Yes给TC。**这说明无论是否存在任何外部意外事件，参与者保证可以提交该事务。**

4. 当所有参与者返回Yes后，那么TC先持久化事务信息，再发送Commit消息给所有参与者（**这说明无论是否存在任何外部意外事件，协调者保证可以提交该事务**）；或者事务被一票否决后，TC发送Abort给所有参与者来回退事务

   1. 参与者在这里持久化所有变更；或者根据Log回退事务
   2. 并在这里释放所有TID对应的锁
   3. 最后返回ACK作为响应
   4. 参与者在这里可以将TID对应的持久化日志删除

5. 当所有ACK被返回后（或者在abort事务后），TC将事务结果返回给客户端

   1. 这里TC可以在ACK之后，将TID对应的持久化信息删除。



**故障恢复**

对于参与者：

- 它可能在回复 Prepare 消息之前就崩溃了。
  - 那么它可以单方面的回复No来撤销事务

- 它可能在回复Prepare Yes消息之后崩溃。这说明无论是否存在任何外部意外事件，参与者保证都可以提交该事务。
  - 在回复 Prepare 之前，它必须确保记住当前事务的中间状态，记住所有要做的修改，记住事务持有的所有的锁，这些信息必须在磁盘上持久化存储。
  - 当它重启恢复时，通过查看自己的 Log，它可以发现自己正在一个事务的中间，并且对一个事务的 Prepare 消息回复了 Yes。
  - 当参与者最终收到了 Commit 而不是 Abort，那么通过读取 Log，参与者就知道如何完成它在事务中的那部分工作。
- 它可能在收到 Commit 之后崩溃了。
  - 参与者有可能在处理完 Commit 之后就崩溃了。但是这样的话，它就完成了修改，并将数据持久化存储在磁盘上了。这样的话，故障重启就不需要做任何事情，因为事务已经完成了。
  - 但因为TC没有收到 ACK，那么TC会再次发送 Commit 消息。当参与者重启之后，收到了 Commit 消息时，它可能已经将 Log 中的修改写入到自己的持久化存储中、释放了锁、并删除了有关事务的 Log。这里参与者可以记住事务的信息，但是这会消耗内存，所以实际上它会完全忘记已经在磁盘上持久化存储的事务的信息。那么**对于一个它不知道事务的 Commit 消息，参与者会简单的 ACK 这条消息。**

对于协调者：

- 如果事务协调者在发送 Commit 消息之前就崩溃。
  - 在重启后不需要任何操作，TC默认这个事务被撤回了。因为没有一个参与者会 Commit 事务。
  - 但参与者可以在自己的 Log 中看到事务，又从来没有收到 Commit 消息。那么事务的参与者会向事务协调者查询事务，**事务协调者会发现自己不认识这个事务，它必然是之前崩溃的时候 Abort 的事务，响应abort**即可。
- 协调者在发送完一个或者多个 Commit 消息之后崩溃。这里不允许TC忘记相关的事务，因为这里需要最终决定是否应该提交或回退事务。
  - 在发送任何 Commit 消息之前，它必须先将事务的信息持久化。
  - 当事务协调者故障重启时，对于执行了一半的事务，事务协调者会向所有的参与者重发 Commit 消息或者 Abort 消息，以防在崩溃前没有向参与者发送这些消息。这就是为什么参与者需要准备好接收重复的 Commit 消息的一个原因。

考虑网络问题：

- 事务协调者发送了 Prepare 消息，但是并没有收到所有的 Yes/No 消息
  - **重新发送一轮 Prepare 消息**。这表明自己没有收到全部的 Yes/No 回复。事务协调者可以持续不断的重发 Prepare 消息。但是如果其中一个参与者要关机很长时间，我们将会在持有锁的状态下一直等待。
  - **撤销事务**。如果一个崩溃了的参与者重启了，向事务协调者发消息说，我并没有收到来自你的有关事务 95 的消息，事务协调者会发现自己并不知道到事务 95 的存在，因为它在之前就 Abort 了这个事务并删除了有关这个事务的记录。这时，事务协调者会告诉参与者说，你也应该 Abort 这个事务。
- 如果参与者等待 Prepare 消息超时
  - **撤销事务**。如果事务协调者上线了，再次发送 **Prepare 消息，B 会说我不知道有关事务的任何事情并回复 No**。
- 如果参与者等待 Commit / Abort 消息超时
  - 或许TC在很久一段事件中断电，但其他事务在等待锁的释放。所以我们应该尽早的 Abort 事务，并释放锁。但参与者不允许 Abort 事务，它必须无限的等待 Commit 消息，这里通常称为 Block。
  - **Block行为是两阶段提交里非常重要的一个特性**。在特定的故障中，你会很容易的陷入到一个需要等待很长时间的场景中，因为参与者会一直持有锁，并阻塞其他的事务。所以各种2PC的变种会尽量让这部分尽可能轻量化，甚至对于一些变种的协议，对于一些特定的场景都不用等待。（这里可以让TC作为副本系统，降低宕机可能性）
- 如果TC没有受到所有的ACK
  - 它会假设丢包了并**重发 Commit 消息**。如果一个参与者收到了一个 Commit 消息，但是它并不知道对应的事务，因为它在之前回复 ACK 之后就忘记了这个事务，那么参与者会再次回复一个 ACK。（因为它之前已经完成对这个事务的 Commit 或者 Abort，然后选择忘记这个事务了）
  - （或许这里不需要接受ACK？必须接受，因为这能确保参与者接受到Commit信息）

### 总结

两阶段提交在大量的将数据分割在多个服务器上的分片数据库或者存储系统中都有使用。

两阶段提交有着极差的名声：因为**有多轮消息的存在，它非常的慢**；同时它**有大量的写磁盘**操作。

因此，你只会在一个小的环境中看到两阶段提交。你或许可以在银行内部的系统中看见两阶段提交，但是你不会在不同的银行之间转账看到它。**两阶段提交永远不会在物理分隔的不同组织之间被使用，因为它可能会陷入到 Block中**。你不会想将你的数据库的命运寄托在其他的数据库不在错误的时间崩溃，从而使得你的数据库被迫在很长一段时间持有锁。不过有很多2PC变种，试图解决性能问题。

**2PC与Raft**

你可以发现Raft与2PC很相似：有一个 Leader（事务协调者），将消息发送给 Follower（事务参与者），Leader 只能在收到了足够多 Follower 的回复之后才能继续执行。但注意2PC与Raft是本质上不同的协议：

- Raft 的意义在于，将数据复制到多个参与者得到高可用，即使部分参与的服务器故障了或者不可达，系统仍然能工作。Raft 能做到这一点是因为**所有的服务器都在做相同的事情**。
- 两阶段提交中，每个参与者都在做事务中的不同部分，**参与者完全没有在做相同的事情**。所有的参与者都必须完成自己那部分工作，这样事务才能结束，**所以这里需要等待所有的参与者。**

然而，是有可能结合这两种协议的。因为两阶段提交对于故障来说是非常脆弱的，在故障时它可以有正确的结果，但是不具备可用性。结合Raft提供的容错性，我们可以这样设计系统：

- 事务协调器会是一个复制的服务，包含了三个服务器，我们在这 3 个服务器上运行 Raft，其中一个服务器会被选为 Leader，它们会有复制的状态，它们有 Log 来帮助它们复制，我们只需要等待过半服务器响应就可以执行事务协调器的指令。事务协调器还是会执行两阶段提交里面的各个步骤，并将这些步骤记录在自己的 Raft 集群的 Log 中。
- 每个事务参与者也同样是一个 Raft 集群。最终，消息会在这些集群之间传递。

这说明我们可以结合两种思想来同时获得高可用和原子提交。
