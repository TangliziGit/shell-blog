
<!-- vim-markdown-toc Marked -->

* [Linux 计算机启动与运行原理](#linux-计算机启动与运行原理)
    * [从开机加电到执行main函数之前的过程](#从开机加电到执行main函数之前的过程)
        * [启动BIOS进入实模式](#启动bios进入实模式)
        * [加载操作系统内核程序](#加载操作系统内核程序)
        * [过渡到保护模式](#过渡到保护模式)

<!-- vim-markdown-toc -->

# Linux 计算机启动与运行原理

> 大部分引用自《Linux内核设计的艺术》第二版 与 《深入理解LINUX内核》第三版



## 从开机加电到执行main函数之前的过程



### 启动BIOS进入实模式

> https://wiki.archlinux.org/index.php/GRUB#Installation_2

> <https://z.itpub.net/article/detail/1DF87A7A5B7FBDF9E7DA28E3A12A9075>

启动BIOS，准备实模式下的中断向量表和中断服务程序。

1. CPU加电进入16位实模式
   - x86 CPU可在16位实模式和32未保护模式下运行
   - 实模式是从80286开始的80x86兼容CPU的操作模式，它可以<u>直接访问BIOS</u>及周边硬件，最大寻址1MB。

2. 加电瞬间置CS:IP为0xFFFF0
   - **CS代码段寄存器**，指向CPU中在内存的<u>代码起始位置</u>
   - **IP指令指针寄存器**，指向实模式下的指令在代码短中的<u>偏移地址</u>

3. **BIOS启动**：检测硬件，在内存中建立<u>中断向量表</u>和<u>中断服务程序</u>，之后还会触发中断加载引导
   - **中断向量表**：包括很多**中断向量**，它们都<u>指向具体的中断服务程序</u>
   - **中断服务程序**：用于将内核从外存加载至内存



注意：

1. UEFI
   - 在 2005 年年中时候，包括 BIOS 供应商、OS 供应商、系统制造商以及芯片生产公司在内的行业参与者统一建立了统一的 EFI  联盟并在 2006 年一月发行了 UEFI 规范  2.0。
   - 你可以愉快的在 PC 启动初期使用鼠标，甚至像苹果一样加载网络，实现联网下载并安装操作系统。
2. 与BIOS的区别
   - BIOS是16位汇编语言程序，只能运行在16位实模式，可访问的内存只有1MB，而UEFI是32位或64位高级语言程序（C语言程序）
   - 启动流程和 BIOS 的启动流程不同
     - `/EFI/Boot/bootx64.efi`：默认引导文件只有当所有的启动入口都不可用，才会尝试使用该文件去启动。
     - `/EFI/XXX/grubx64.efi`：GRUB控制的引导文件，你可以通过`grub-install --target=x86_64-efi --efi-directory=esp --bootloader-id=XXX`来安装
     - `/EFI/Microsoft/Boot/bootmgfw.efi`：Windows默认引导文件



### 加载操作系统内核程序

> <https://z.itpub.net/article/detail/1DF87A7A5B7FBDF9E7DA28E3A12A9075>

为保护模式做准备。

第一扇区：加载bootsect引导程序

- 由于我们**选择软盘启动设备**，所以BIOS选择**触发一个int 0x19中断**
- CPU接受中断，在中断向量表中查找中断向量，它指向中断服务程序的入口地址
- <u>该服务程序</u>加载外存第一扇区（Boot Sector, 512KB）的程序至内存中。**这是引导程序的位置**，linux0.11为bootsect。
  - **MBR主引导记录**共446B，包括`BootLoader`代码（如GRUB），提供选单、读取内核文件并转交给其他启动器
  - **DPT磁盘分区表**，主分区表共64B
  - **结束标志字**，0x55aa
  - 注意：
    1. 至此的操作与具体操作系统并无关联
    2. 关于GPT的情况，它是 UEFI 规范的一部分，GPT 分区结构如下：
       - Protective MBR：GPT 分区表的最前面部分也保存了和 MBR 相同的格式和内容称为 Protective MBR，这极大的提高了 GPT 分区表的兼容性。
       - 主 GPT Header：这里记录了分区表项目数和每项目大小。
       - 主 GPT 分区表：包含分区的类型 GUID，名称，起始终止位置，该分区的 GUID 以及分区属性
       - 实际分区：几乎包括所有硬盘空间
       - 备份 GPT 分区表: 用于提高安全性，防止主 GPT 分区表损坏
       - 备份 GPT Header: 用于提高安全性，防止主 GPT Header 损坏



**bootsect引导程序的行为：**

1. 规划实模式下的内存区域
2. 复制bootsect程序自身至规划区域
3. 加载setup内核引导程序和system内核模块（包括head和main），并拼接放置在规划区域（利用int0x13中断）
4. 跳转至setup的入口，运行setup



**setup引导程序的行为**：

1. 提取内核运行所需的机器系统数据



### 过渡到保护模式



**setup引导程序的行为**：

2. 关中断，直到系统提供中断服务程序后开中断
3. 将 system 内核模块移动到内存地址起始位置，覆盖不需要的 BIOS 中断向量表和 BIOS 数据区
4. 设置**中断描述符表**和**全局描述符表**
   - IDT中断描述符表：与实模式下的中断向量表作用相同，IDT是保护模式下存放中断服务例程的入口地址。位置不固定，由IDTR基址寄存器确定。
   - GDT全局描述符表：全局唯一的存放段描述符的数组，在保护模式下进行段寻址，存放每个任务的局部描述符表LDT和任务状态段地址。并在进程切换中完成寻址、现场保护和现场恢复。位置不固定，由GDTR基址寄存器确定。
5. 打开A20实现32位寻址
   - 实模式下只有20位的寻址空间，意味着使用20跟地址线。开启21根（A20）到32根地址线意味着切换到32位寻址。
6. 对中断芯片（8059A）重新映射中断号
   - Intel的CPU芯片将int 0x00到int 0x1F作为内部中断，所以需要重新映射中断芯片的中断号，将它们向后推0x20。否则当你激活中断芯片的某个端口后发送的中断号可能会是Intel内部的中断号，这就会产生混乱。
7. 开启保护模式（PE置1）
8. CS跳到head程序（就是刚才system模块的第一个部分，初始地址为0）
   - 注意这里的跳转`jmpi`指令已经使用了GDT（实际上`jmpi`的参数是段选择符），也就是**分段**。
   - 关于CS寄存器存储的代码段首址，实模式下仅用了16位仅用来指示段的首地址，而保护模式下使用了64位保存段描述符（其中包括段基址等，描述段的信息）。



**head程序的行为**：为main适应保护模式做准备

system包含了head和main，这两者是紧邻的。在head做准备的同时，它也消耗自己的内存空间来**构建页表**。

1. 将寄存器从实模式转换到保护模式
2. 重建IDT和GDT
3. 压栈main函数地址，即目前esp指向main函数地址、ebp指向栈底
4. 创建页目录表和4个页表，并设置分页相关的寄存器
   - 每个页表都填充了内核所有内存空间对应的页框，作为内核的页表
   - 将来每个用户都有自己的页表
5. 执行`ret`命令，esp退栈，弹出main函数地址作为eip，作为“返回地址”使用（注意不是主调函数控制链），以此来达到进入main函数的目的。
   - 如果直接使用`call`命令调用main函数，那么最后main执行完成后，则需要回复现场，而这又是没必要且逻辑上不成立的。

 
