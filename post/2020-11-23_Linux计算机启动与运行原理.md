
<!-- vim-markdown-toc Marked -->

* [Linux 计算机启动与运行原理](#linux-计算机启动与运行原理)
    * [从开机加电到保护模式](#从开机加电到保护模式)
        * [启动BIOS进入实模式](#启动bios进入实模式)
        * [加载操作系统内核程序](#加载操作系统内核程序)
        * [过渡到保护模式](#过渡到保护模式)
    * [设备初始化 & 激活进程#0](#设备初始化-&-激活进程#0)
    * [进程#1的创建和运行](#进程#1的创建和运行)
    * [进程#2的创建和运行](#进程#2的创建和运行)

<!-- vim-markdown-toc -->

# Linux 计算机启动与运行原理

> 大部分引用自《Linux内核设计的艺术》第二版
>
> 同时对照 《深入理解LINUX内核》第三版

因为时间不够用，所以这本书看得很粗略。但是它们仍然很有帮助，能够加深对CPU、外设和内核的理解。





## 从开机加电到保护模式



### 启动BIOS进入实模式

> https://wiki.archlinux.org/index.php/GRUB#Installation_2

> <https://z.itpub.net/article/detail/1DF87A7A5B7FBDF9E7DA28E3A12A9075>

启动BIOS，准备实模式下的中断向量表和中断服务程序。

1. CPU加电进入16位实模式
   - x86 CPU可在16位实模式和32未保护模式下运行
   - 实模式是从80286开始的80x86兼容CPU的操作模式，它可以<u>直接访问BIOS</u>及周边硬件，最大寻址1MB。

2. 加电瞬间置CS:IP为0xFFFF0
   - **CS代码段寄存器**，指向CPU中在内存的<u>代码起始位置</u>
   - **IP指令指针寄存器**，指向实模式下的指令在代码短中的<u>偏移地址</u>

3. **BIOS启动**：检测硬件，在内存中建立<u>中断向量表</u>和<u>中断服务程序</u>，之后还会触发中断加载引导
   - **中断向量表**：包括很多**中断向量**，它们都<u>指向具体的中断服务程序</u>
   - **中断服务程序**：用于将内核从外存加载至内存



注意：

1. UEFI
   - 在 2005 年年中时候，包括 BIOS 供应商、OS 供应商、系统制造商以及芯片生产公司在内的行业参与者统一建立了统一的 EFI  联盟并在 2006 年一月发行了 UEFI 规范  2.0。
   - 你可以愉快的在 PC 启动初期使用鼠标，甚至像苹果一样加载网络，实现联网下载并安装操作系统。
2. 与BIOS的区别
   - BIOS是16位汇编语言程序，只能运行在16位实模式，可访问的内存只有1MB，而UEFI是32位或64位高级语言程序（C语言程序）
   - 启动流程和 BIOS 的启动流程不同
     - `/EFI/Boot/bootx64.efi`：默认引导文件只有当所有的启动入口都不可用，才会尝试使用该文件去启动。请注意某些机器只会扫描到各个分区，判断分区是否为fat32+esp，并且查找是否存在此默认文件才会建立启动项。所以当你正确安装引导后，启动项却不存在时，尝试复制efi文件到此处。同时注意`efibootmgr`的输出。
     - `/EFI/XXX/grubx64.efi`：GRUB控制的引导文件，你可以通过`grub-install --target=x86_64-efi --efi-directory=esp --bootloader-id=XXX`来安装
     - `/EFI/Microsoft/Boot/bootmgfw.efi`：Windows默认引导文件



### 加载操作系统内核程序

> <https://z.itpub.net/article/detail/1DF87A7A5B7FBDF9E7DA28E3A12A9075>

为保护模式做准备。

第一扇区：加载bootsect引导程序

- 由于我们**选择软盘启动设备**，所以BIOS选择**触发一个int 0x19中断**
- CPU接受中断，在中断向量表中查找中断向量，它指向中断服务程序的入口地址
- <u>该服务程序</u>加载外存第一扇区（Boot Sector, 512KB）的程序至内存中。**这是引导程序的位置**，linux0.11为bootsect。
  - **MBR主引导记录**共446B，包括`BootLoader`代码（如GRUB），提供选单、读取内核文件并转交给其他启动器
  - **DPT磁盘分区表**，主分区表共64B
  - **结束标志字**，0x55aa
  - 注意：
    1. 至此的操作与具体操作系统并无关联
    2. 关于GPT的情况，它是 UEFI 规范的一部分，GPT 分区结构如下：
       - Protective MBR：GPT 分区表的最前面部分也保存了和 MBR 相同的格式和内容称为 Protective MBR，这极大的提高了 GPT 分区表的兼容性。
       - 主 GPT Header：这里记录了分区表项目数和每项目大小。
       - 主 GPT 分区表：包含分区的类型 GUID，名称，起始终止位置，该分区的 GUID 以及分区属性
       - 实际分区：几乎包括所有硬盘空间
       - 备份 GPT 分区表: 用于提高安全性，防止主 GPT 分区表损坏
       - 备份 GPT Header: 用于提高安全性，防止主 GPT Header 损坏



**bootsect引导程序的行为：**

1. 规划实模式下的内存区域
2. 复制bootsect程序自身至规划区域
3. 加载setup内核引导程序和system内核模块（包括head和main），并拼接放置在规划区域（利用int0x13中断）
4. 跳转至setup的入口，运行setup



**setup引导程序的行为**：

1. 提取内核运行所需的机器系统数据



### 过渡到保护模式



**setup引导程序的行为**：

2. 关中断，直到系统提供中断服务程序后开中断
3. 将 system 内核模块移动到内存地址起始位置，覆盖不需要的 BIOS 中断向量表和 BIOS 数据区
4. 设置**中断描述符表**和**全局描述符表**
   - IDT中断描述符表：与实模式下的中断向量表作用相同，IDT是保护模式下存放中断服务例程的入口地址。位置不固定，由IDTR基址寄存器确定。
   - GDT全局描述符表：全局唯一的存放段描述符的数组，在保护模式下进行段寻址，存放每个任务的局部描述符表LDT和任务状态段地址。并在进程切换中完成寻址、现场保护和现场恢复。位置不固定，由GDTR基址寄存器确定。
5. 打开A20实现32位寻址
   - 实模式下只有20位的寻址空间，意味着使用20跟地址线。开启21根（A20）到32根地址线意味着切换到32位寻址。
6. 对中断芯片（8059A）重新映射中断号
   - Intel的CPU芯片将int 0x00到int 0x1F作为内部中断，所以需要重新映射中断芯片的中断号，将它们向后推0x20。否则当你激活中断芯片的某个端口后发送的中断号可能会是Intel内部的中断号，这就会产生混乱。
7. 开启保护模式（PE置1）
8. CS跳到head程序（就是刚才system模块的第一个部分，初始地址为0）
   - 注意这里的跳转`jmpi`指令已经使用了GDT（实际上`jmpi`的参数是段选择符），也就是**分段**。
   - 关于CS寄存器存储的代码段首址，实模式下仅用了16位仅用来指示段的首地址，而保护模式下使用了64位保存段描述符（其中包括段基址等，描述段的信息）。



**head程序的行为**：为main适应保护模式做准备

system包含了head和main，这两者是紧邻的。在head做准备的同时，它也消耗自己的内存空间来**构建页表**。

1. 将寄存器从实模式转换到保护模式
2. 重建IDT和GDT
3. 压栈main函数地址，即目前esp指向main函数地址、ebp指向栈底
4. 创建<u>内核专属</u>的页目录表和4个页表，并设置分页相关的寄存器
   - 每个页表都填充了内核<u>所有物理内存空间</u>（16MB）对应的页框，作为内核的页表
   - 将来每个用户都有自己的页表
5. 执行`ret`命令，esp退栈，弹出main函数地址作为eip，作为“返回地址”使用（注意不是主调函数控制链），以此来达到进入main函数的目的。
   - 如果直接使用`call`命令调用main函数，那么最后main执行完成后，则需要回复现场，而这又是没必要且逻辑上不成立的。

 

## 设备初始化 & 激活进程#0

**设备初始化**

1. 选定根设备（根文件系统所在设备）和硬盘
2. 规划物理内存：缓冲区、虚拟盘和主存空间
   - 缓冲区：主机与外设的数据交互
   - 虚拟盘：类似SPOOLING，用于一次性读完外设至内存的区域（这里还要设置请求项处理函数，内核代码段的函数指针）
   - 主内存：进程代码运行空间
   - **注意**：现在的物理内存分布情况为：二级页表、4个页表、软盘缓冲区、IDT、GDT、main代码区、main数据区、（空闲区）、BIOS&VGA、（实模式空间结束）、缓冲区、虚拟盘、主存
3. `mem_init`：初始化内存管理结构`mem_map`
   - `mem_map`的每个元素表示每个页面的使用次数（从实模式空间之后，即1MB～16MB的每个页面）。
   - 主存区设为0次（视为空闲页面），其他区（缓冲区和虚拟盘）设为`UESD`
   - **注意**：
     1. 内核与用户进程的内存映射方式不同，内核是线性地址即物理地址（一一映射），用户地址则是虚拟内存映射。
     2. 1MB之内仅能由内核控制，用户进程不可能访问到。
4. `trap_init`：挂接异常的中断服务程序
   - 在idt的第n个位置，写入中断描述符。其中的中断服务程序入口设置为对应的内存地址（内核代码段的函数指针）。
5. `blk_dev_init`：块设备的请求项结构
   - `requests`数组主要用于记录请求的外设和缓冲区的对应关系（其外还有TSS等），是一个链表数组。
6. 挂接人机交互的外设中断挂接：串行口、显示器、键盘
7. 通过CMOS提取开机时间



**初始化进程#0**

> https://www.cnblogs.com/flashsun/p/12258829.html

TSS&LDT控制进程的隔离，时钟中断是时间片轮转的关键，系统调用则用于用户进程的陷入。这些都是进程的关键。

1. 初始化TSS0、LDT0挂接在GDT上
   - TSS：任务状态段，是指在操作系统进程管理的过程中，任务（进程）切换时的任务现场信息，包含了寄存器的值。 
   - LDT：由GDT中的段描述符和LDTR中的段描述符指向，作用与GDT一样，用于存储段描述符。
   - GDT目前结构：NULL、内核CS、内核DS、NULL、TSS0、LDT0
2. 设置时钟中断：定义每10ms发生一次时钟中断，挂接时钟中断，开启中断芯片的时钟中断屏蔽码。
   - 注意：现在CPU仍然处于关中断状态，并不能响应芯片的时钟中断。
3. 设置系统调用总入口
   - 就是用户进程用的陷入中断，由于CPU设定的特权级对内核的保护，不能直接调用内核代码的缘故。
   - **特权级检查**：处理器在 **访问数据** 或 **跳转到代码** 时，需要进行特权级检查。
     - 不论是访问数据，还是跳转到代码，特权级检查仅发生在<u>重新加载选择子</u>时，而不是每条指令都检查一遍。
     - **访问数据**：在<u>数据段寄存器（如DS）</u>中加载<u>段选择子</u>时，且只能高特权级的指令访问低特权级的数据
     - **跳转代码**：<u>代码段寄存器CS</u>和<u>指令指针寄存器 EIP</u>的指令时，且只能**平级跳转**。从低级到高级需要**门**，从高级到低级需要**返回指令**



继续**设备初始化**

8. `buffer_init`：初始化缓冲区管理结构
   - 从内核数据区的末端向高地址开始构建`buffer_head`，同时指向从缓冲区末端向低地址开始构建缓冲数据
   - `buffer_head`是双向环形链表，由`free_list`指定链表头
   - 设置`hash_table`为空
9. `hd_init`初始化硬盘：挂接请求项服务，挂接中断服务，复位中断芯片和硬盘的中断请求屏蔽位
10. `floppy_init`初始化软盘：同上
11. 标志寄存器开启中断
12. 翻转至3特权级：原理同进入main程序，模拟陷入中断的返回现场。即先压栈现场，后调用`iret`。





## 进程#1的创建和运行

由#0进程按照父子进程机制进行创建，这是内核第一次进行进程调度

进程#1第一次执行后，设置硬盘信息，格式化虚拟盘，加载根文件系统。



**#1进程创建过程**

1. 由父进程调用`fork`，`fork`发出一个系统调用`system call`中断（即`int 0x80`），同时给定系统调用的函数编号。
   
   - `sys_call_table`存储着具体系统调用的函数
   
2. CPU查找`sys_call_table`找到`sys_fork`函数，进行调用
   1. 首先获取空闲进程号和`task[64]`项
      - 用于存储`task_struct`进程状态信息等，关于进程调度和进程树的信息
      - 每一个进程都有属于自己进程的内核内存空间的一个`task_struct`
      - 注意：`task_unoin`同时提供了页中剩下的空余作为内核栈
   2. 其次进行进程的拷贝：
      - #0的`task_struct`复制给#1，降`task_struct`挂接在`task[64]`上
      - 申请页表，复制上#0的页表项（第一次在主存申请页表，目前是共用同一个页表）
        - 首先必须启用分段机制，使用了#0的代码段和数据段
      - 共享#0的文件
      - 设置#1的GDT（TSS和LDT）
      - 使之就绪
   3. 首次进程调度
      - 通过系统调用置#0可中断等待状态，仅当有接收到某种信号才就绪
      - 调用`schedule`，跳到#1的代码段（注意当前#0在中断中未返回）



**#1进程运行过程**

1. #1进程通过`setup`函数初始化：硬盘文件系统   
   - 申请缓冲区（使用`hash_table`判断是否相同dev和block号存在缓存）
   - 挂接请求项（同时给缓冲区加锁）
   - 读数据时，`schedule`强行切换#0
   - 硬盘中断，执行硬盘中断服务程序。
   - 重复中断直到完成读取，切换至#1
2. #1进程格式化虚拟盘，并设为根设备（目前为软盘）（超级块，引导块）
3. #1进程在根设备上挂载文件系统





## 进程#2的创建和运行

进程#1创建进程#2，最终shell进程开始执行，整个boot工作结束，实现系统怠速。

注意进程#2是从<u>硬盘</u>中加载的执行代码，而非之前的软盘中内核`system`代码。



**#1进程继续运行**

4. 打开标准输入、输出和错误设备文件
   - 注意其中的各种挂接和维护
5. 创建进程#2，并切换#2运行
   - 同#0创建#1的过程
6. 加载shell
   - 关闭`/dev/tty0`文件
   - 打开`/etc/rc`文件，并调用`exec`加载`/bin/sh`
7. **加载`shell`的过程**
   1. 检测文件：i节点属性、文件头属性
   2. 加载参数和环境变量，调整`task_struct`和LDT，调整EIP和ESP（准备利用`iret`切换）
   3. `iret`中断返回，开始执行shell
8. **shell的执行**
   1. 触发缺页异常，加载第一页程序
      - 调用`do_no_page`中断处理函数，申请一个页面
      - 调用`bread_page`从虚拟盘上读一页shell程序的内容，载入页面
      - 内核构建二级页表、页表和页面，及之间的映射关系
   2. 读取标准输入`/etc/rc`初始化文件
      1. 新建一个`/etc/update`进程#3，并切换#3。
         - #3定时切换，用于同步缓冲区与外设
      2. 切换回进程#2，继续执行`/etc/rc`的命令
      3. 直到`/etc/rc`结束，进程#2由于普通文件返回ERROR，从而退出
9. **shell的退出**
   - 释放代码段和数据段的页面
   - 它的子进程移动父进程指针到进程#1（如果当前进程`ZOMBIE`，则再发一个`SIGCHLD`信号）
   - 解除各种挂接
   - 设置进程状态为`ZOMBIE`
   - `tell_father`通知它要退出：给父进程#1发送`SIGCHLD`信号，通知子进程退出
   - `schedule`切换进程：遍历进程时检测到信号，将可中断等待状态的#1就绪（有没有Actor的感觉）
10. 进程#1处理子进程退出
    1. 代码为`goto repeat`，则跳到之前完成#2的善后
    2. 当即将退出的子进程为`ZOBMIE`状态：释放task_struct所在页面（进程真正消失），和其他工作
    3. 重建shell进程#4（进程#2只是执行`/etc/rc`）
11. 重建的shell进程#4，读取`/dev/tty0`，不再退出
    - 同时进入可中断等待状态（目前所有进程都是这样），于是跳转至#0，系统怠速
    - 之后的操作就是用户通过shell进行交互



**用户通过shell进行交互**

1. 用户键盘输入信息，产生中断
2. 中断服务程序将字符信息存储与字符缓冲队列
3. 给shell发送一个信号，使之从可中断等待状态到就绪状态
4. shell从`/dev/tty0`对应的缓冲队列中读取并处理
5. 完毕后进入可中断等待状态
