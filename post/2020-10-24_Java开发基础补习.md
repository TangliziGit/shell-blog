# Java 8 特性
> https://blog.csdn.net/zxm1306192988/article/details/73744378



## 为何使用 Java 8

> [从ConcurrentHashMap的演进看Java多线程核心技术](http://www.jasongj.com/java/concurrenthashmap/)

1. 底层优化数据结构
   - HashMap 引入红黑树 (长度大于8时)
   - ConcurrentHashMap 从分段锁到CAS
2. 取消堆中永久区，使用元空间
3. **Lambda表达式**
4. **强大的Stream API**
5. 便于并行
6. 减少空指针异常 Optional



## Lambda 表达式

提高代码复用度，减少代码量。
策略设计模式 -> 匿名内部类 -> Lambda 表达式 -> Stream API



### 基础语法举例

左右可省括号，左侧可**类型推断**。

```java
() -> System.out.println("Hello Lambda");
x -> System.out.println(x);
(x, y) -> System.out.println(x + y);
(x, y) -> Integer.compare(x, y);
(Integer x, Integer y) -> Integer.compare(x,y);
```



### 函数式接口

**只包含一个抽象方法的接口，称为 函数式接口。**

> Java 7 接口包括：常量 抽象方法
> Java 8 接口包括：默认方法 静态方法
> Java 9 接口包括：私有方法

1. 可以通过 Lambda 表达式来创建该接口的对象。（若 Lambda表达式抛出一个受检异常，那么该异常需要在目标接口的抽象方法上进行声明）。
2. 在任意函数式接口上使用 @FunctionalInterface 注解，这样做可以**检查**它是否是一个函数式接口。
3. 4大核心内置函数式接口（另有更多内置接口）：
	
	```java
	Comsumer<T>: 	void accept(T t);
	Supplier<T>: 	T get();
	Function<T, R>: R apply(T t);
	Predicate<T>: 	boolean test(T t);
	```



### 方法引用 & 构造器引用

注意：需要调用的方法要与函数式接口中抽象方法的参数列表保持一致！

1. 方法引用
   - 对象::实例方法名
   - 类::静态方法名
   - 类::实例方法名 （第一个参数是 实例方法的调用者，而第二个参数是实例方法的参数）

2. 构造器引用
   - 
     ClassName::new

3. 数组引用
   - Type[]::new

```java
Consumer<String> con = System.out::println;
Comparator<Integer> cmp = Integer::compare;
BiPredicate<String, String> pred = String::equals;

Supplier<String> sup = String::new;
Function<Integer, Employee> sup = Employee::new;

Supplier<String[]> sup = x -> new String[x];
Supplier<String[]> sup = String[]::new;
```





## Stream API

Stream 是 Java 对数据的计算过程的抽象表达，位于 `java.util.stream`。



### 创建 Stream

1. 通过Collection 系列集合提供的方法
   - ` default Stream<E> stream()`
   - `default Stream<E> parallelStream() `

2. 通过 Arrays 中的静态方法
   - `static <T> Stream<T> stream(T[] array)`

3. 通过Stream 类中的静态方法
   - `static <T> Stream<T> of(T... values)`
4. 通过Stream 类创建无限流
   - `static <T> Stream<T> iterate(final T seed, final UnaryOperator<T> f)`
   - `static <T> Stream<T> generate(Supplier<T> s)`

```java
// 1. Collection method
List<String> list = new ArrayList<>();
Stream<String> stream = list.stream();
Stream<String> stream = list.parallelStream();

// 2. Arrays static method
Employee[] emps = new Employee[10];
Stream<Employee> stream = Arrays.stream(emps);

// 3. Stream static method
Stream<Integer> stream = Stream.of(1, 2, 3, 4);

// 4. Infinite Stream
Stream.iterate(0, x -> 2 * x)
    .limit(10)
    .forEach(System.out::println);

Stream.generate(Math::random)
    .limit(10)
    .forEach(System.out::println);
```



### 中间操作

1. 筛选 & 切片

   - `filter(Predicate p)`
   - `distinct()`：去除重复元素，需要重写`hashCode`和`equals`方法
   - `skip(long n)`
   - `limit(long n)`

2. 映射

   - `map(Function f)`
   - `flatMap(Function f)`：将每个值映射为另一个流，在拼接起来

3. 排序

   - `sorted()`：产生新的流，按自然顺序排序

   - `sorted(Comparator cmp)`

   - `sorted(Collections.reverseOrder()`：反转



### 终止操作

1. 匹配 & 查找
   - `boolean allMatch(Predicate p)`：是否全部匹配
   - `boolean anyMatch(Predicate p)`：是否存在匹配
   - `boolean noneMatch(Predicate p)`：是否全部不匹配
   - `Optional<T> findFirst(Predicate p)`
   - `Optional<T> findAny(Predicate p)`
   - `int count(Predicate p)`
   - `Optional<T> max(Predicate p)`
2. 归约
   - `T reduce(T ident, BinaryOperator op)`
   - `Optional<T> reduce(BinaryOperator op)`：此处 `ident` 为首元素
   - `T reduce(T ident, BinaryOperator op, BinaryOperator<U> combiner)`：`combiner`用于组合`ident`，可以模拟`scan`操作
3. 收集
   - `T collect(Collector c)`



**Collector 接口总结**

1. 至容器
   - `toList()`, `toSet()`
   - `Collector.toCollection(Supplier<T> sup)`
2. 至统计量
   - `counting()`
   - `summingInt()`
   - `averagingInt()`
   - `summarizingInt()`
3. 选择
   - `maxBy(Comparator<T> cmp)`
4. 聚集 & 分区
   - `groupingBy(Function<T, U> classifier)`：至`Map<U, T>`
   - `groupingBy(Function classifier, Collector downStream)`：多级聚集
   - `partitioningBy(Predicate p)`
   - `partitioningBy(Predicate p, Collector downStream)`
5. 转换
   - `collectingAndThen(Collector c, Function f)`



**Comparator 接口总结**

1. 排序
   - `naturalOrder()`
   - `reverseOrder()`
2. 比较
   - `comparingInt(ToIntFunction func)`
   - `thenComparingInt(ToIntFunction func)`
   - `reversed()`

```java
// 先以价格（升序）、后再速度（升序）
list.sort(Comparator.comparingInt(Computer::getPrice).thenComparingInt(Computer::getSpeed));

// 先以速度（降序）、后再价格（升序）list.sort(Comparator.comparingInt(Computer::getSpeed).reversed().thenComparingInt(Computer::getPrice));

// 先以价格（降序）、后再速度（降序） list.sort(Comparator.comparingInt(Computer::getPrice).thenComparingInt(Computer::getSpeed).reversed());
```



### 并行流与串行流

并行流就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。

Java 8 中将并行进行了优化，我们可以很容易的对数据进行并行操作。

Stream API 可以声明性地通过 `parallel()` 与 `sequential()` 在并行流与顺序流之间进行切换。



#### Fork/Join 框架

将一个大任务（至少百万级），拆分（fork）成若干个小任务（拆到不可再拆时），再将一个个的小任务运行的结果进行join汇总。

**Fork/Join 框架与传统线程池的区别 - 工作窃取**

当执行新的任务时，它可以将其拆分成更小的任务执行，并将小任务加到线程队列中。当自己的队列中取不出值后，再从一个随机其他的线程的任务队列（双端队列）中偷一个并把它放在自己的队列中。
如果一个线程正在执行的任务由于某些原因无法继续运行，那么其他空闲线程会窃取任务处理。

```java
public class ForkJoinCalculate extends RecursiveTask<Long>{

    private static final long serialVersionUID = 1234567890L;//序列号

    private long start;
    private long end;
    private static final long THRESHOLD=10000L;//临界值

    public ForkJoinCalculate(long start,long end) {
        this.start=start;
        this.end=end;
    }
    
    @Override
    protected Long compute() {
        long length=end-start;
        if(length<=THRESHOLD){
            long sum=0;
            for(long i=start;i<=end;i++){
                sum+=i;
            }
            return sum;
        }else{
            long middle=(start+end)/2;
            ForkJoinCalculate left=new ForkJoinCalculate(start, middle);
            left.fork();

            ForkJoinCalculate right=new ForkJoinCalculate(middle+1, end);
            right.fork();

            return left.join()+right.join();
        }
    }

}
```

```java
public class TestForkJoin {

    @Test
    public void test1(){
        Instant start=Instant.now();

        ForkJoinPool pool=new ForkJoinPool();
        ForkJoinTask<Long> task=new ForkJoinCalculate(0L, 10000000000L);
        long sum=pool.invoke(task);
        System.out.println(sum);

        Instant end=Instant.now();
        System.out.println("消耗时间"+Duration.between(start, end).toMillis()+"ms");//消耗时间3409ms
    }

    @Test//直接使用java8的并行流
    public void test2(){
        Instant start=Instant.now();

        Long sum=LongStream.rangeClosed(0L, 10000000000L)
                           .parallel()
                           .reduce(0,Long::sum);
        System.out.println(sum);

        Instant end=Instant.now();
        System.out.println("消耗时间"+Duration.between(start, end).toMillis()+"ms");//消耗时间2418ms
    }
}
```



## Optional类

| 方法                     | 说明                                              |
|--------------------------|---------------------------------------------------|
| Optional.of(T t)         |                                                   |
| Optional.empty()         |                                                   |
| Optional.ofNullable(T t) | 若非null, 创建 Optional 实例, 否则创建空实例      |
| orElse(T t)              | 如果调用对象包含值，返回该值，否则返回t           |
| orElseGet(Supplier sup)  | 如果调用对象包含值，返回该值，否则返回 s 获取的值 |
| map(Function fun)        |                                                   |
| flatMap(Function fun)    | 要求返回值必须是Optional                          |



## 接口中的默认方法与静态方法

若一个接口中定义了一个默认方法，而另一个父类或接口中又定义了一个同名的方法时：

1. 选择父类中的方法。

   如果一个父类提供了具体的实现，那么接口中具有相同名称和参数的默认方法会被忽略。

2. 接口冲突。

   如果一个父接口提供一个默认方法，而另一个接口也提供了一个具有相同名称和参数列表的方法（不管方法是否是默认方法），那么必须覆盖该方法来解决冲突。



## 日期API

以前的时间API是线程不安全的，是可变的。需要多线程对日期进行处理要加锁。

Java8 新的实例是**不可变**的对象，分别表示使用 ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的日期或时间，并不包含当前的时间信息。也不包含与时区相关的信息。



### LocalDate & LocalTime & LocalDateTime

他们分别是日期、时刻、日期和时刻。

它们的API都是一样的，主要有：

1. `LocalDateTime.now()`
2. `LocalDateTime.of(xxx)`：某年某月......
3. `ldt.plusXxx()`
4. `ldt.minusXxx()`
5. `ldt.getXxx()`



### Instant 时间戳

主要方法：

1. `Instant.now()`
2. `Instant.ofEpochXxx()`：较Unix元年加Xxx
3. `ins.atOffset(ZoneOffset.ofHours(8))`
4. `ins.toEpochMilli()`：获取Unix元年至今毫秒



### Duration 时间段 & Period 日期段

Duration可用于任何时刻上：`Instant` `LocalTime` `LocalDateTime`

Period可用于任何日期上：`LocalDate`

主要方法：

1. `Duration.between(ins1, ins2)`
2. `duration.toXxx()`：单位转换
3. `duration.getXxx()`：在上一个单位上计数



### TemporalAdjuster 时间校正器

`LocalDateTime` 等时间提供 `with`API，它可以对时间实例进行调整。

```java
LocalDateTime ldt=LocalDateTime.now();
System.out.println(ldt);//2017-07-20T19:28:57.822

LocalDateTime ldt2=ldt.withDayOfMonth(10);
System.out.println(ldt2);//2017-07-10T19:28:57.822

//调整为下个周日
LocalDateTime ldt3=ldt.with(TemporalAdjusters.next(DayOfWeek.SUNDAY));
System.out.println(ldt3);//2017-07-23T19:31:39.479

//自定义：下一个工作日
LocalDateTime ldt5=ldt.with((l)->{
    LocalDateTime ldt4=(LocalDateTime)l;
    DayOfWeek dow=ldt4.getDayOfWeek();//获取当前星期
    if(dow.equals(DayOfWeek.FRIDAY)){//如果是周5，下个工作日即加3天
        return ldt4.plusDays(3);
    }else if(dow.equals(DayOfWeek.SATURDAY)){//如果是周6，下个工作日即加2天
        return ldt4.plusDays(2);
    }else{
        return ldt4.plusDays(1);//其他，下个工作日即为明天
    }
});
System.out.println(ldt5);//2017-07-21T19:37:05.533
```





### DateTimeFormatter 格式化时间/日期

常用方法：

1. `DateTimeFormatter.ISO_XXX`
2. `DateTimeFormatter.ofPattern("yyyy年MM月dd日 HH:mm:ss")`：自定义格式化格式
3. `ldt.format(dtf)` `dtf.format(ldt)`：日期格式化
4. `LocalDateTime.parse(String text, DateTimeFormatter formatter)`：日期解析

```java
DateTimeFormatter dtf=DateTimeFormatter.ISO_DATE;
LocalDateTime ldt=LocalDateTime.now();

String strDate=ldt.format(dtf);
System.out.println(strDate);

//自定义格式化格式
DateTimeFormatter dtf2=DateTimeFormatter.ofPattern("yyyy年MM月dd日 HH:mm:ss");
String strDate2=dtf2.format(ldt);
System.out.println(strDate2);//2017年07月20日 19:49:53

LocalDateTime newDate=ldt.parse(strDate2,dtf2);
System.out.println(newDate);//2017-07-20T19:49:53
```



### ZonedDate & ZonedTime & ZonedDateTime

带时区的日期、时刻、日期和时刻。

常用方法：

1. `LocalDateTime.now(ZoneId.of("Asia/Shanghai"))`：获得某时区的`LocalDateTime`
2. `ldt.atZone(ZoneId.of("Asia/Shanghai"))`：加上某时区的信息，转换为`ZonedDateTime`