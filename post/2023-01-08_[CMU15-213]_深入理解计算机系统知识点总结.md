# [CMU15-213] 深入理解计算机系统知识点总结

> - CMU15213 Schedule: https://www.cs.cmu.edu/~213/schedule.html
> - CSAPP Lab: http://csapp.cs.cmu.edu/3e/labs.html
> - 参考读书笔记：https://zhuanlan.zhihu.com/p/103476182

# Ch.1 计算机系统漫游

### Q：什么是Amdahl定律？

当我们对系统的某个部分做加速优化时，其对系统整体性能的影响取决于该部分的耗时占比和加速程度。用白话来讲，要想显著加速整个系统，必须提升全系统中相当大的部分的速度。

# Ch.2 信息的表示和处理

这里我们研究最重要的三种数字表示：无符号、补码和浮点数。

### Q：相比于数学，计算机中的算术运算会出现那些异常？

- **溢出**：由于任意数字需要保存在有限数位上，所以存在结果太大不能表示的情况。
  - 有符号数加法会出现正溢出和负溢出，分别代表加和结果原本为正或负，却因为加和溢出或者符号位被占用导致结果符号相反。
- 浮点运算不满足**结合率**：由于更大的数字具有更大的步长，在加法乘法中过小精度的数字会因为精度丢失被舍掉。所以说浮点数的表示只是近似的。
  - 例：`(3.14 + 1e20) - 1e20 != 3.14 + (1e20 - 1e20)`

### Q：什么是字长？为什么64位机的指针却只使用低48位？

- 字长指明指针数据的大小。虚拟地址是以这样的一个字来编码的,所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。

- 一个表示虚拟内存地址的64位指针只有低48位有效并带符号扩展到64位。因为现在还用不到完整的64位寻址空间，所以硬件也没必要支持那么多位的地址。

### Q：什么是小端和大端？

分别指两种不同的字节序：

- **小端**：指数据中的字节按照低位对应低位排序。由于ALU算术运算需要从低位开始计算并传播，使用小端更方便，所以大多数CPU常使用小端在内存中组织数据。
- **大端**：指字节按照低位排在高位的方式组织。由于人类习惯大端的读数，所以除了CPU内部/内存，其他常见都大量使用大端，如：网络传输等。3

## 整数数据类型

### Q：如何编码有符号和无符号整数？

**无符号数**

无符号数的表示就是幂的加权和：$ N_{Unsigned} = \sum^{w-1}_{i=0} x_i \cdot2^i $

**有符号数：补码**

补码的表示就是最高位为负数的加权和：$ N_{Two's-complement} = -x2^{w-1} + \sum^{w-2}_{i=0} x_i \cdot2^i $

在这里顺带提一下有符号数的其他表示。这两种方法对0有两种不同的表示。现在几乎所有机器都用补码表示有符号数，而原码将会用在浮点数指数表示上：

- **反码**：即补码加一。
- **原码**：最高位是符号位，其余位按2的幂加权和：$ N_{Sign-Magnitude} = (-1)^{x_{w-1}} \cdot \sum^{w-2}_{i=0} x_i \cdot 2^i $

### Q：有符号数和无符号数之间的转换是怎样的？

强制类型转换的结果保持位值不变，只是改变了解释这些位的方式。下图展示了补码在负数情况和无符号数在数值过大情况下的转换异常：

<div style='display: flex'>
    <img alt="T2U" src="/static/image/2023-01-08/T2U.png" />
    <img alt="U2T" src="/static/image/2023-01-08/U2T.png" />
</div>

同时需要注意的是，C/C++中会发生有符号数隐式转换成无符号数的情况。

### Q：讲一下整数溢出的所有情况

对有符号数和无符号数来说，都只是在加法或乘法的结果上做取模而已。这里不提乘法的实现。

**无符号数溢出**

- **判断溢出**：加法判断`x + y < x || x + y < y`；乘法判断`x > 0 && y > UMAX / x`

![unsigned_overflow](/static/image/2023-01-08/unsigned_overflow.png)

**有符号数溢出**

- **判断溢出**：加法如下图，需要分类讨论；乘法判断`p=x*y; !x || p/x == y`

![signed_overflow](/static/image/2023-01-08/signed_overflow.png)

## 浮点数据类型

1985年浮点数标准IEEE754被提出，意在提高程序的可移植性，同时不会太多关注运算的准确性，而是把实现的速度和简便性看得比数字精确性更重要。

### Q：如何编码浮点数？规格化值是指什么？

- **表示**：$$(-1)^s \cdot M \cdot 2^e$$。其中符号S表示正0负1，阶码E位为指数，尾数M表示精度（取值为1到2之间的数）。
- **存储**：格式为`S | Exp(E) | Frac(M)`。其中单精度中E长度为8，M长度为23；双精度中E长度为11，M长度为52。

![floating_number](/static/image/2023-01-08/floating_number.png)

- **规格化值**：当exp的位不全是0或1时。
  - 此时有$ E = exp - Bias; Bias = 2^{k-1}-1$。（为什么要用bias来表示而不是补码呢？因为可以直接通过比较E原码来比较两个浮点数大小会更方便）
  - 同时有$ M = 1 + frac $。（实际存储的是frac的数位，这样做是为了免费获得一位1。所以frac全0是指1.0，全1是指接近10.0的数）
- **非规格化值**：当exp的位全是0时。
  - 此时有$ E = 1 - Bias; Bias = 2^{k-1} -1 $。
  - 同时有$ M = frac $。frac将不带隐含前导1，所以能够表示正负0以及0.000xxx的数值（其中000表示E的位数，xxx表示M）。
- **特殊值**：当exp的位全是1时。
  - 当frac全0：表示正负无穷大。
  - 其他情况：表示NaN，如虚数结果，无穷大乘0等。

![floating_number_classes](/static/image/2023-01-08/floating_number_classes.png)

下面列出一个规格化数的例子：

![floating_number_example](/static/image/2023-01-08/floating_number_example.png)

### Q：浮点数如何分布？

不同的E值对应了不同的精度单位。每到尾数从全0变为全1时，E值加一，使得步长按照2的倍数递增。

![floating_number_dynamic_range](/static/image/2023-01-08/floating_number_dynamic_range.png)

![floating_number_dist](/static/image/2023-01-08/floating_number_dist.png)

一些可能被忽略的情况：

- 最大非规格化值和最小规格化值的步长相同，可以看成是光滑转变。
- 从最小数值到无穷大的过程可以看作是无符号数的排序方式。当然，需要保证正负数的问题（正0负1）。
- 在递增时阶码和尾数可以看成一个整体做二进制加一。

### Q：浮点数的舍入规则

向偶数舍入，即四舍六入五偶数。这样做的原因是有正好一半的概率向上或者向下舍入。

![round_to_even](/static/image/2023-01-08/round_to_even.png)
