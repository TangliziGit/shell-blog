This is introduction to database systems.
Those of you familiar with the class may know that it's usually taught by Andy Pablo and as I'm sure some of you may have realized.
I am not Andy Pavlow.
My name is Andrew Crotty.
I'm, a postdoctoral researcher here at CmU and my research focuses mainly on database systems and data management.
You may also have realized that my co-instructor for the course.
Lin Ma is also not Andy Pavlow.
He is a postdoc here as well and he's one of Andy's former PhD students.
So at this point you might be wondering where Andy is and he's actually on leave this semester because he's filming a a netflix docentary that's a follow-up to last year's Tiger King and unfortunately, I can't say anything more because of the Mba that I signed, but you should definitely check this out when it's when it's released so with that let's move on to the course material one last thing before we begin.
I want to thank Google Bigquery for helping us with course development this semester.
I'm sure all of you know what what Google is but bigquery specifically is a a database product.
It's a fully managed cloud data warehouse.
We might call it platform as a service and essentially you give them your data and then you can query it run all sorts of analytics machine learning that kind of stuff and at the end of the semester there's there's going to be someone from Google who comes here to give a guest lecture and tell you about kind of all the the cool stuff they're doing and you you'll be able to see a lot of the topics that we cover in the course actually applied in practice and they'll be able to talk more about kind of the the problems that come up when dealing with with data at this scale so today's agenda we're just gonna go over the kind of beginning.
What is this course of course logistics stuff and then there'll be sort of like a mini half lecture.
At the end, we'll we'll just.
kind of go through some of the core concepts that we're going to cover in the course so depending on timing.
I get out a few minutes early to start off with the wait list.
I do not control the wait list.
It is way above my pay grade is Students are going to be moved off the wait list based on your position as new spots in the class open up so I if you if you send us emails there's nothing that I personally can do about it.
It's just gonna be based on order and if you're not currently enrolled in the course the likelihood that you'll get in and things will probably firm up over the next week or so.
But unfortunately, you might not be able to get in, but we do plan to make all of the course materials public We're gonna put the lectures lecture videos on Youtube, and all the material will be there so you'll be able to follow them.
In terms of lecture rules please interrupt me at any time.
If any of these things happens either I'm speaking too fast.
If you don't understand something that I'm talking about or if you have a database related question chances are that if you have a question then then someone else does too and if this is kind of a big room.
If I if I can't quite hear you or if I don't if I don't see you right away just try to interrupt me at a good point where I can take so just at a high level.
This course is specifically about.
the design and implementation of database management systems so that means we're going to be looking at the software that manages databases.
So this isn't a course about how to use a DbMs to build applications like imagine if you had a building a web application and you wanted to store your user user data in in a database.
This this class is not about that and it's not a class about how to administer a database system.
So they're all all sorts of jobs out there.
Where people's entire role is to essentially manage the software that manages the data and that's that's also not not the topic of this course.
So there are other courses.
Unfortunately, one of them is not being offered this semester and actually I don't know if it's offered anymore, but that that fun course is the one that covers those topics okay so.
Just at a high level for the rest of the semester.
The topics that we're going to be covering we're going to be starting with a relational model and that's that's a data model for databases and that's going to be the main theme for the entire course.
So we're going to talk primarily about relational database management systems.
There are all sorts of other data management systems.
NosQL.
Some of you may have heard of graph databases.
All sorts of things we're going to be focusing on relational databases in this course and we're going to sort of build up from the bottom level.
All the way up through the stack to look at the different parts of a database management system, starting with the storage how you actually physically store the data in memory and on on persistent storage like a hard drive or an SsD then we're.
Going to move up and talk about query execution and kind of how you can either put data into update the data that you've stored or retrieve the data.
Then we're going to move on to kind of concurrency control so imagine you have several processes that are concurrently trying to access the database.
How can you sort of keep all those together and manage them.
The next piece that we're going to cover is recovery so if your database crashes or if the machine crashes, how can you kind of make sure that your data is safe and persistent, and you can kind of recover from those types of situations and then towards the end of this this semester we're going to cover some more advanced topics distributed database management systems and kind of just a general review of of some advanced topics so in terms of logistics.
The course policies and the schedule are all on the webpage Academic Honesty.
I'm gonna talk about this in later in the slides, but please Don't do anything stupid if if we catch you plagiarizing or copying work.
Those sorts of things it's gonna be a big problem.
I'll have to do a lot of paperwork and it's gonna be a big problem for you so just please it's easier if you don't do it if you have any questions if you're not sure about anything please either send an email to me or Lynn or one of the tas and just ask like is is this thing that I'm doing okay and you can also refer to the CmU policy page.
Ironically that link there is broken.
I checked it this morning their their web page is down, but there's a cached version somewhere or or I can make.
it available to you? If you if you email me? So all of the discussion and announcements for the course will be on Piazza and if if there's something that you need to contact either me or lynn about just private private privately a sensitive subject please send us an email and we can coordinate something to speak.
So The textbook for the course is is the this database systems concepts book also known as the the sales book.
There are so I'm not sure about the the exact difference between the sixth and the the seventh edition.
I think all of the material that we're going to cover in this course is available on the sixth edition.
If you have that or I want to buy that version.
I don't think that the seventh edition is available as like a hard cover book anymore.
I think it's like loosely.
pages that are you get sent and with like a three-hole punch in them, but we'll also be providing lecture notes that will cover all of the topics as well as things that we cover in class that aren't covered in the book.
So in terms of grading, this is going to be the breakdown for how your grades are calculated 15 for homeworks 45 for projects, 20 for the midterm exam and 20 for the final exam.
So it's.
It's pretty heavily weighted towards homeworks and the projects for homeworks.
There are going to be five assignments that are are spread out over the course of the semester.
The first homework is is a SqL assignment, so it's equal to we're going to talk about a little bit at the end of this class and in the next class, but it's a query language that you use to interact.
The database management system so the first homework assignment is going to be able to write some SqL queries to answer some questions from a sample database.
We'll give you in the rest are going to be paper and pencil assignments where you kind of like apply formulas or solve different like conceptual problems for topics we cover in class and again I mentioned earlier all homework should be done individually.
You shouldn't be you know sharing answers or doing group assignments.
They're all individual assignments and should be done individually and we'll be checking for kind of copied solutions to things.
So the projects are focused around this idea that you're going to build up your own database engine over the course of the semester.
So like I said we'll start at the lower levels and we'll work our way up through the stack, but what this means is.
that each project is going to build on the previous ones.
So for example, if you have to implement a storage manager earlier on the later projects may interact with that storage manager to get data in and out so for that reason, it's it's important that you kind of keep up and go along.
If you get too far behind on on you know these early projects, then it's going to be really difficult or impossible to catch up later on in the semester so an important thing and this was kind of already mentioned in the announcement for the first project, but we're not going to be teaching you how to write or debug C plus code.
In this class.
It's a prerequisite for the course We expect.
This is a higher higher level course.
We expect that you know kind of C plus plus as a prerequisite.
So if you go to you know ta office hours and you're asking things like what is a string or what is a shared pointer or that kind of stuff There We've told them not not to answer those kind of questions, so we expect to be comfortable working with C plus plus that's kind of why this this project zero is released and it needs to be completed by September 13th for you to continuing the course so it's kind of meant as like a as like a self-check kind of thing where if you're if you're really struggling with project zero, then this might might not be the course for you because later on you're not gonna be able to do the more complicated programming projects, so all of the projects for the course will be implemented using the CmU Db group bus tub academic DbMs it.
is kind of a an academic system, so it's not really a full-fledged database system, but it has these kind of modular pieces and and we'll go through.
Some of these things will make more sense later in the course, but as kind of this disk-based storage architecture, where as I said it can read and write data from disk.
It has a volcano style query processing setup where you can kind of chain together iterators basically to to iterate over your data and answer queries.
It has pluggable Apis that will leverage to be able to implement the different pieces of the system that you're going to implement for the projects and it currently does not support SqL so you won't be interacting with it through simply kind of be interacting interacting with it through lower level tests test programs that we provide okay so the next thing.
The late policy you lose 10 points or sorry 10 of the points for a project or homework for every 24 hours late that you you handed in so if you know if you hand it in after the deadline, we'll round up so if it's four hours late, then it's going to be 10 percent off and round up to the next full day.
You're going to have a total of four late days.
Over the course of the semester to be used for projects only so not for the homeworks is only for the programming projects and you're free to allocate them as you wish.
For example, you could turn in one project four days late or four projects each one day.
The only thing that you cannot use them for is is the project Nber zero that has to be done by September 13th for you to.
Continue of course there's pandemic still going on.
I know that there's a lot of uncertainty and things that can come up so we're also going to grant no penalty extensions due to extreme circstances like the medical emergency or a family emergency.
Just if something comes up.
I I realize you know at the time you might not be able to, but as soon as you can just contact us and let us know what's going on and we can we can try to make arrangements for you okay so again.
I want to reiterate the plagiarism warning.
I I know this is redundant, but I really want to get this out there and so you've all seen it and there's there's video of me telling all of you about it.
So later on.
If you run into any problems there's no excuse for not not knowing what this.
Is so the homework and the projects must be your own original work.
They're not group assignments.
They're not meant to be done together in groups.
I you you cannot copy source code from other people, your peers or the web.
In general, there's not a Tyson's.
Since this is kind of a an academic system and we change the projects each semester there shouldn't be like one for one's solutions to the projects that we're going to give you online but I still if there's any any source source code out there please Don't copy it we're not going to tolerate plagiarism and it is going to be a big problem.
So please do not do it so kind of the last administrative thing is office hours.
We're still waiting on a clarification from the university about what we're supposed to do for in-person versus remote office hours you.
have noticed the website does not have either the instructor or ta office hours yet but as soon as we get this hopefully within the next day or two we will update you so we'll put it on the website and we'll send out a message to the class if you need to contact us sooner about anything at all please just send us an email or you can reach out if it's something that's a more general question.
You can reach out on Ps4 okay so for the fun stuff database research.
There is a vaccination database tech talks seminar series that will take place.
I believe on zoom Mondays at 4-30 pm, starting on 9 13 Monday 9 13..
There's a link to the schedule.
There you can access it and we are going to have a whole bunch of excellent people from each of these these.
Either database companies or projects come and talk about their system and these aren't like marketing people that are just gonna say hey use our system there.
They're technical people that are going to come and give technical talks about the actual internals of their system.
So low level stuff kind of the design stuff that we're talking about in this course.
So if you're interested in that please check it out and you can check out the website so that is kind of all of the administrative logistics part of this lecture.
So if there are any specific questions so far I'd be happy to answer them and then we can move on to the fun database stuff cool okay and again.
All of this stuff that I mentioned should be available on the website either currently or as I said in the case of office art and stuff.
Shortly so you can check there and if you have any questions, just send us an email or ask on okay so databases let's start with what is database just out of curiosity How like you just raise your hands? How many of you regularly interact with a database management system databases.
It doesn't have to be like command line writing SqL queries no one no no databases all right.
I find that a little hard to believe.
So Sqlite is a database management system.
It is probably the most widely deployed database management system in the world, creating you that have a smartphone.
It's used in ios and android web browsers.
I don't know if you use web browsers there's Chrome and Safari both use SqL lite for storing data and if if you ever made a call with skype Skype uses a SqL light behind the scene so.
I I guess the point I'm trying to make is that pretty much behind every application anywhere where you need to store data there's probably a database management system running in the background handling things for you.
So a database is essentially an organized collection of interrelated data where you're trying to model or capture some aspect of the real world.
So if you think about like a real world entity.
For example, if I have a database to model students in the class.
Each individual student is a data point that would be stored in my database so just as a practical example.
Let's create a database that models a a digital music store, something like the apple music store itunes store or something similar where you want to keep track of we'll just for now to simplify things.
We'll just keep track of artists and the albs that they release so the things that we're going to need Are you know to know about individual artists and kind of a record of over time the the different albs that they released and the way we can do this just as a as a straw man sort of example is using flat files so imagine that we want to store our database in just a comment comma separated value CSV file kind of where each each row or line in the file represents one you know data entity so an artist or an alb and kind of each coln is going to represent a an individual attribute about that entity, so you know pretend.
We don't know anything about any kind of you know database management systems that are out there like MySQl postgre oracle sqlite any of that.
Stuff Jen we don't know about that we're just kind of building an application up ourselves and what this is going to require is that the application needs to parse the file.
Each time it wants to read anything and it's going to have to read.
Align split the Csp and kind of figure out what's going on every single time.
We want to access the data so again here's here's just a simple example using the music store where we have two essentially tables stored as CSV files.
So there's the artist table where we have the the name of the artist.
The year they first started releasing music in the country they're from and in this second alb table we have the the name of the alb the artist that released it and the year it was released so now let's say that that we want to issue.
essentially a query on on the data that we have and we want to know the year that Ice Cube went solo all right you know the ice Cube had had some disagreements about the amount of money he was making so he decided to go solo and start releasing homes on his own.
So I guess the the the way that we would do this.
We have the CSV files is we write you know you write some kind of like a Python program to look something like this where essentially you open up the file and then you iterate over every line and file take the line.
Remember it's just a CSV string.
You have to parse it into a record and then we want to do is check if the value at position zero in the record is ice Cube because we're looking for one ice Cube.
When solo and you want to print out the the year so we're gonna cast the the second value of the string into an int and return that so I I guess what's the problem with this it seems pretty simple pretty straightforward.
I mean I guess your your query could change.
Maybe you want to know when the tourist big went so low or started releasing music.
You could just swap out the ice cube for for a different name and get a different result or if you want to know the country that someone's from just change the position that you're printing out there.
So I guess this seems fine but can anyone think of you know any issues that might come up if if you're managing things this way that is true So if the the data gets really large, then what you're going to have to do is kind of open the file and iterate over all of the the the lines here.
I guess what you could do is modify this a little bit to as soon as you know that there's only one record you're looking for in this case, you could modify it a little bit to just return as soon as you find it, but that's certainly true if if you're if you're not careful with how you code this, then you might end up iterating over every single line in the file every single time that is another problem that can come up so that the statement.
was that there could be a duplicate entries for ice cube, and there's no way to ensure using this method that someone doesn't come in and you know put in another record for ice cubes.
Then we there's no way to maintain kind of the the invariant.
We want only one record to represent ice cream yes that's another problem any others.
I have a whole list.
I can go through okay so the first problem or the first.
A series of problems relates to data integrity.
So one problem might be is how do we ensure that the artist is the name The name of the artist is the same for each alb entry.
So if you remember in order to figure out you know kind of which artists have released which albs.
We store the artist name in the alb CSV file so imagine that that you know.
You type in a wrong a wrong name to update one of the the alb rose or you know an artist changes their name or that sort of thing, so how do you ensure that there's consistency between the name that an artist lists in the artist's file and the name that the artist lists in the albs file.
Another problem that come up is you know what if someone overwrites the alb year in the the alb file within invalid string so in that code I showed you you're expecting an integer that that represents a year When the alb was released someone comes in and puts in just a regular string.
Then your your code's going to break there's going to be a problem parsing and again there's no kind of I guess you could have access control on your files, but you know once someone's able to get in the file, you can just make a mistake put in an invalid value for a particular field.
What if there are multiple artists on an alb so everything I showed you know each each alb only on an individual artist.
So it's just one field in the CfD string, but you know imagine that there's a multiple artists on a in that case.
I guess you know you could change the format instead of being a single string.
You could put you know a comma separated list inside the field of the CSV file.
But then you're you know complicating your parsing code you have to go back and adjust your.
parsing code to now handle you know potentially one or more values in that field and kind of the last problem and these are just a few that I you know came up with here.
But there are many many more but what happens if we delete an artist that has albs so imagine that you know you deleted the record for ice cube in the artist file and now he has a bunch of records or a bunch of records representing albs in the alb table and now there there's no artist remaining that they linked to okay so that's kind of the data integrity side from an information implementation perspective and this was one of the points made is how do you find a particular error so again.
In the example, you end up in the code that I showed iterating through every single row every single time.
You want to find something and you you There are all sorts of ways to optimize it.
For example, if you know the data is sorted, you could do like binary search or something or if you have a data structure that stores it maybe like a hash table or something you could index directly to the the record.
You're looking for but just you know all of these things.
You're building up additional complexity in your python program that you have to write to access the code.
So all of that kind of implementation efficiency needs to be taken into consideration when when you're designing your application.
Similarly, what if we want to create a new application that uses the same database, so the database is stored in the CSV files imagine that you know someone else for some other purpose wants to come along and access the same.
CSV files concurrently do you want them to have to rewrite kind of all the Python code that you've had built up or maybe you need to do it in a different language, but the point is that kind of you've you've had to do the work to build up this application and now it has to be replicated every time.
Someone else wants to access the same data and even for you.
You know like I said if you want to change the query or or change change things that you're looking for you run into the problem of having to kind of re-implement things from scratch every single time.
So kind of another implementation question is what if two threads or two programs I try to write to the the file at the same time.
You know if I'm editing five and you're editing the file we both.
our work, who knows what's gonna happen? You know one of us might override the other or maybe both of our rights get partially written and now you have kind of this garbage record in there so what you can end up with is kind of all of this.
You have to implement some kind of concurrency layer to manage the current accesses to the data.
So the final piece that I want to talk about is his durability which means like what happens if the machine crashes when when the program is updating records, so you're doing right power goes out or something or the your program crashes and you know now what happens to the data is inconsistent.
Did you finish writing the whole record you wanted to write or is it kind of half written Now you have again.
This is garbage value in your your database.
What if we want to replicate the database on multiple machines? So we can have high availability? How do we handle kind of concurrent rights to different machines because now the machines need to be synchronized across them and kind of the list goes on and on and on with all of these problems that can come up so that's kind of the the reason why we want to build a database management system so we don't have to handle all of this complexity all those different types of problems that i mentioned in application code okay so i explain what a database is the software that manages database is a database management system.
Sometimes people use the words interchangeably.
I will try not to because it's diffusing but a database management system or DbMs is a system.
The software that manages the database and allows applications to store retrieve.
and analyze information that's that's stored in the database so rather than managing things in these CSV files, you can access them through the database and it kind of gives you all of these nice properties that avoid the problems that I mentioned before and a general purpose.
DbMs is designed to allow you to define, create query update and administer databases in in a generic sense.
So if you have again an application for managing students in a class or for managing an online music store kind of it's it's general purpose enough that you can program your applications against the system.
So this is really good for like business reasons for your business or startup or your organization Because the purpose of the value add that you're bringing is not that you can store data.
Lots of people can store data but what what a database management system.
Allows you to do is focus on you know the core aspect of your business rather than worrying about all of these issues surrounding actually managing the data and you know.
DbMss are are widely tested and deployed so that they you know find all the bugs the concurrency bugs.
The consistency bugs all those problems that come up because kind of you know the the chances that that every single Python program that you write is going to be 100 bug free.
All the time pretty much zero so kind of the the the whole point of a database management system is that you can leverage kind of this this core set of functionality for managing databases, so you don't have to do it manually in application curve so I database management systems are not new.
The first one, I came out of 1965 at General Electric was called IdM and essentially they were they were used kind of to manage data, but they were really writing applications.
They were really difficult to build and maintain and that's because people were working at a very low level, and there was you know really tight coupling between the logical layer.
So kind of the the data model there and the physical layer that like the implementation writing to disk recruiting things from desk query and that kind of stuff so kind of the the the big problem is that you had to know the the queries that you wanted your application to execute before you deployed the database and they were just really cbersome and not not easy to work with so kind of the things that we're going to talk about over the course of the semester might seem obvious in retrospect, but at the time you know people were struggling to build these applications and and they were kind of controversial.
The ideas were kind of controversial.
So there was this guy at IBM named Ted Codd.
It's him who kind of observed that people were were reimplementing the same things over and over again reinventing the wheel and and you know making a lot of mistakes along the way, so he proposed kind of this.
This high-level idea called a relational model and there's this original.
I think it came out as a technical report in 1969 but nobody reads this one.
This is the one that everyone references came out a year later In 1970.
It's a paper called a relational model of data for large shared data banks and you know it's old because people when they write the text they spelled data and base as two separate words.
Now you have it combined as one but kind of the the core idea that he proposed was the relational model and he actually won.
Turin Award in 1981.
If you know what that is it's like the people call it the Nobel Prize for computing It's like the highest honor you can receive in computer science, and he he he won it for the relational model and as I said it was kind of controversial at the time.
I mean you can look at it now and say oh yeah sure that makes sense, but at the time it wasn't so obvious so kind of the relational model at a high level is a database abstraction to avoid a lot of low-level maintenance and problems that people are running into writing database application.
So the the the kind of three main points that they're gonna touch on are the the databases database databases should be stored in a simple data structure called relation where a relation essentially represents the relationship among attributes stored.
In the table so like the relationship if you are thinking about the the artist example, the relationship between the artist name the the year that they that they started producing music and the country their first the relationship between those advocates.
Kind of the the next piece is that you thought you should access data through a high-level language, rather than kind of telling the database your database management system explicitly how how you wanted to get the data you could just specify what data you wanted and let the database management system figure out kind of the best strategy to do it because you know if you're building a piece of software that's specialized interactive databases, you should it should be pretty good at figuring out the best way to get you the data you want and and finally the the last piece is that the physical storage.
the data either at the time on on disk or secondary storage Now in memory also should be left up to the the DVMs implement so you have to worry about whether it's laid out in in a row format.
A CSV file it's just completely abstracted to you.
You just know what the data is that's in there and you can let the DbMs kind of figure out the specifics of storing it and you know at the time like I said people argued that a DbMs would never be able to generate a query plan as efficient as kind of what a Han could do kind of like how people used to argue about you know compilers No one could ever produce code that's newer no no.
A computer program compiler could ever produce code that's as efficient as what assembly that a Han could write now almost.
No one writes at that level, So kind of it's the same idea with databases.
There was a lot of of Han effort that went into designing programs to efficiently access it because they thought that you couldn't design a a system to do it efficiently.
So I mentioned that the relational model is a type of data model.
So the data model is just essentially a high-level collection of concepts for describing the data that's stored in in a database.
So it's like a high-level abstraction.
For for how we're going to represent the data now a schema is more specifically a description of a particular collection of data given a data model so what does that mean it means that the schema defines exactly what we're going to store in the database so, for example, in the music store example, the schema would be the artist.
table followed by the different attributes that are associated with an artist so that's the schema that you would define that describes the data that's stored in the data, so there are as I said lots and lots of different data models.
Most DbMss that you may have heard of are based on this first relational data model and for a lot of reasons, but probably the biggest one is that the relational model is probably the most flexible of all of them.
The relational model can kind of model.
All of these other or you.
You can represent all of these other data models using the relational model and the the the exact you know Api or or what's going on behind the scenes might not be as efficient, but it's still general enough to be able to handle all these other models.
So NosQL is a popular term.
It means a lot of things to a lot of different people, but just at kind of a high level like.
For example, it's more than just a data model, a lot of people when they hear.
NosQL think about things like transactions or consistency or not having certain Apis, but just in terms of the actual No SqL data model.
It covers kind of this key value stores graph database management systems, docent databases, mongodb and kind of a broader Coln family databases and kind of these these data models are more restrictive than what you get with the relational model and they don't give you as many as I said kind of guarantees in terms of different properties that we're going to discuss over the course of the semester.
There are some just i'll finally say there's some application domains where these data models might make sense so.
Imagine I know you're storing video data or you're storing log data or something you just want to shove it into a key value store that's that's perfectly valid and might be better for that particular type of application than a relational database array and matrix database management systems are kind of specialized more towards machine learning or scientific applications.
There are a few Cyb tile Db but they're not They're not really widespread and kind of They're narrowly focused on on these sorts of use cases and kind of the last group hierarchical network and multi-value.
These are kind of either obsolete data models that people tried out in the past and they find and found didn't work well or they had other problems, but they might still be hanging around in legacy systems so for the purposes of this course, we're going to be focusing exclusively on the.
model and how database management system works in that context okay so what is the relational model exactly the the relational model defines the the relations inside the database so like I mentioned the individual tables sometimes they're in SqL.
They're called tables.
In the relational model they're called relations.
I I'll probably end up using them interchangeably, but you can think of them just concretely as those examples from the music store there's the artist relation table and the alb relation and the the structure of the relational model defines those relations and the contents inside them.
So the next piece as I mentioned is integrity which ensures that the database's contents satisfy some constraints so with the concern about you know whether or not there could be a garbage string value inserted or overwritten on a when you're expecting an integer year kind of the integrity aspect seeks.
to mitigate that problem by forcing all of the year values to be integers and forcing that property and finally there's the the manipulation aspect which is the programming interface or Api that you use to access and modify the contents of the database and this is what we're going to talk about later in in the lecture with relational algebra.
So relational algebra is a programming programming interface for interacting with the relational model.
So again kind of just going through the example.
A relation is an unordered set so that's important.
There's no order to the values we don't necessarily care what order they appear in in the database they could be sorted they could not be sorted it doesn't matter.
It's just a set and it contains the relationship of the attributes that represent entities so as i said a relation or table has many entries that.
are called tuples tuples.
Some people say either either is fine with me, but I'll probably end up saying both but tuples or records also in a table tupler record is interchangeable.
There's there's another word that sometimes people use called rows.
I will try not to use that I might accidentally, but a row implies something specific about how the data is stored so in the CSV example, you know every every data was stored as an individual line, but the the tuples and records represent individual data entries in a table.
The the values are normally scalar values.
Things like integer strings that's not necessarily true anymore.
In the original specification they all had to be kind of these scalar values, But popular systems have started relaxing to store things like you could store an array maybe in an individual coln or like a Json docent individual and.
There's also this notion of a null which is a member of every single domain.
It can be any attribute can be set to null, and it's not exactly like null in a null pointer or something, but it's used to signify that we don't know what a particular value is.
So For example, if if the the country that is ice cube is from we're null.
It just means that we don't we don't know what that value we don't know the specific value for that record so again.
Just a relation is is a mathematical term that represents this unordered set and SqL.
The SqL equivalent is a table so in entering relation.
If I say an energy relation.
It means that there's a table with n individual colns and individual attributes unless it's three colns okay so a big piece of the relational model is that every.
relation should have a primary key that uniquely identifies a single tuple, so some DbMss will will automatically create this for you.
If you specify it, They'll do it behind the scenes kind of think about like a an auto-incrementing unique integer for four keys.
So in this this table example here there's not really anything that we can use to uniquely identify.
I guess I mean you could potentially use the name of the artist to uniquely identify.
But there's no guarantee that you know all those values are going to be unique so what you can do is add kind of this surrogate primary key that's essentially just a just an integer and like I said it can be auto generating or random or whatever kind of just to keep each each record or tuple unique so foreign keys are are related to primary keys in that.
They specify that an attribute from one relation has a mapping to to some tuple in another relation so just concretely.
If we have this artist key here and we have the alb key.
We know that the artists.
So the the new primary key id nbers that we've added to the alb table.
The artists 123 789 reference artists stored tuples stored in the artist table.
So if we want to know you know who wrote one of these or who released one of these albs? We can go look up okay what's the Nber of the artist and then go look up which artist that is in the area's table.
But you know there's a problem you can run into which is I mentioned earlier, which is what if you want to have multiple artists on on a single alb.
So again you release like a mixtape or something.
We have a lot of different artists contributing, but we only have this one attribute to store the artist Id and the the solution we come up with in the relational model is to create this a third table sometimes called the join table, which is going to join or link the artist table with the alb table.
So we're going to do Is we're going to we're going to get rid of that artist coln in the alb table and instead create this new artist alb table that has only two things in it So there's an artist id and an alb Id and now if if you look at it we can figure out okay.
Here is how all of the artists link to the the albs that they release so in the case where you have you know one artist on an alb and there's only going.
to be one tuple in the artist Alb relation in the case we have multiple you'll have now multiple tuples okay so data manipulation languages or DMl are the specific methods that that we use to store and retrieve information from a database and they come specifically in two flavors.
So the first is procedural and that's that that a high-level query should specify how the Dbms should compute the answer to our query.
So the key word here is how you're telling the database how you wanted to retrieve the data and this is going to be a relational algebra that we talked about in a couple slides here you're saying specifically how you want the data to be retrieved from the database.
The alternative is a non-procedural or declarative language where you only specify what data you want retrieved from the database.
You know You don't tell the database management system how you want to get it back You just say what data you want and then the system goes and figures out how to do that for you so an example of this non--procedural or declarative language is relational calculus we're not going to talk too much about relational calculus in this class.
It's important it's really important for query optimization, but it's it's not really recovering this class.
Don't worry too much about it.
Relational algebra and relational calculus are are they're logically equivalent, but we're like I said only focusing on on this first one.
Another example of a declarative language is sql which we're going to talk about next class.
So relational algebra defines the original the original specification defines these seven operators and they're all fundamental operations that you can use to retrieve and manipulate the the two folds.
relationship.
These are the fundamental operators proposed by Cod and they're based on mathematical ideas of set ultra.
So each operator listed here is going to take in one or more relations as input and it's going to output a new relation.
So in order to build up a query to get the data you want out of your database.
You can kind of chain.
These operators together to create more complex operations so we'll just kind of go through each one starting with select sorry is your question no so starting with select essentially the goal of the select operator is to choose a subset of the the two poles from a relation that satisfy a particular predicate that you provide so the predicate.
You can think about it acting like a filter or kind of like an if statement that's only going to retain the tuples that qualify.
For for the the user specified predicate and you can, of course, combine multiple multiple predicates using conjunctions or disjunctions to get exactly the the subset that you want.
I think it's called restrict in the original relational model paper, but everyone everyone calls it a select and the the symbol is the lowercase sigma in relational algebra so just as an example, we have this really simple relation here R it only has two attributes or colns a id and bid.
So if we want to for example, restrict or filter the relation to only cases where aid equals a2.
Then we apply that predicate and we get back just that subset that satisfies the predicate that we that we specified and as I said you can kind of change things together and say okay give me all of the the records where aid equals a2 and bid equal.
Or is greater than 102.
so in this case, you can see you're only going to get that one tuple and then if you're wondering how this how this works with SqL i apologize.
I didn't come up with the naming convention, but the the select relational algebra operator maps to the where clause in a SqL statement might be a little confusing, but select in relation algebra maps to where clause again we'll talk about SqL next times we'll go through these individualities, but the projection statement is essentially going to generate a relation with tackles that only contain the attributes that you ask for and what does that mean you can do all sorts of things like rearrange the order of the attributes.
You can manipulate the values of the attributes do different types of modifications.
It's it specified the lowercase pi symbol and essentially a list of.
All of the different modifications so here is just an example query where again we're doing the selection first so I mentioned you can chain them together.
We're doing the selection first to get only the records that have a id equals A2 and then we're performing a projection where we're going to modify B by subtracting 100 and we're going to put you know swap the order of the id and that's that's kind of the result you get so again.
This is a i didn't come up with the names, but the projection operator maps to the select clause of the sqL statement.
So the selection operator maps to the where clause.
The projection operator maps to the selected.
The union operator is essentially going to generate a relation that contains all the tuples that appear in either or or both relations it's just like a set union.
So for example, imagine we have another second table here s which has the same schema as the first one to perform r s is going to give us essentially all of the tuples that appear in R.
All the tuples that appear in S and the SqL syntax for this is a little bit different it's union all in order to get potential duplicates because of a difference between set algebra and like a a bag or a multi-set algebra.
So you can see here that there are there is the the duplicate that appears in the union.
So in this example, i the the output is ordered but that's again not necessarily to be true because it's a set they could appear in the output relation could appear in any order and the answer would still you know still consider the correct so you can't count on the.
In there, the intersection operator is going to generate a relation that only contains the tuples that appear in both of the input relations, so it's r intercept s again.
It's the same example, where R and s both have the same schema and what we want to do is find kind of the intersection it's going to give us only A3 appears in both R and s so you can do this in sqL using the intercept operator so just as an example of when this might be useful.
If you think about the music store example, maybe we have one relation representing the rap artists another one representing rock or country artists and you want to know which artists have both rap albs and country albs.
So you just do an intersection of the two relations to get that answer.
The difference operator is going to generate a relation that contains only the tuples that appear in the first relation and not the second relation.
So in this example, here you end up with only the unique ones that appear appear in R and not s and you can do that in SqL.
Using the accept keyword okay the product is essentially going to generate a relation that contains all of the possible combinations of tuples from the both input relations.
So sometimes it's called the Cartesian product, but it's the product of two relations it's going to.
Be all the pairwise combinations essentially what you're going to get from doing the product of RNs is kind of all of these pairwise combinations of tuples from from both relations.
This might seem kind of useless, but it does show up sometimes you know if you want to get generate all the possible combinations in two tables, but more importantly, what what this is going to be used for is just from a conceptual or theoretical perspective it's going to let us model the next operator we're going to talk about which is a join so can you get all these these pairwise combinations.
This is the the syntax and SqL for how to do it.
You can get all these pairwise combinations, but now let's say that you just want the pairwise combinations where your primary key that we talked about in your foreign key match so you.
have two keys that match so the join operator is going to generate a relation that contains all.
All the tuples are a combination of the the two inputs where there's a common value for one or more attributes depending on on what you specify so what we're going to do is we're going to look for matches here and again.
These two tables have the same schema but you could do it in an arbitrary case.
In the music store example, you have the artist relation and the alb's relation and they share the artist's primary key that they join on so what's happening here with the join operator is that we're only finding the matches like I said that appear in both the r table and the s table so like I said kind of this this conceptually, if you think about what the the product operator does.
You could produce all of these pairwise optimizations very sorry, so you produce all these pairwise combinations and then filter it down to just the the set that matches where the keys match, but of course you never do this Because you know you have to first enerate all the different combinations and then perform the filter.
So there are different optimizations you you might want to do to short-circuit this but from a theoretical perspective conceptual perspective.
It's useful to think about in this way.
So the SqL syntax for this and again we'll go over these in in more detail next class, but the SqL syntax to do this joint here is the natural journal so over time like I said there there have been extensions the original relational algebra where they built up more operators.
There's now a bunch that people have added rename assignment duplicate elimination.
Imagine you want to count how many albs A particular artist is released sorting so you can actually impose some kind of ordering on the unordered set and set division, so there are analogs for all of these in SqL that we'll talk about Don't Don't worry too much about them.
They're not going to be super important for the course so just in observation about relation relational algebra and we've gone through all the operators, but it's still defining more or less the high level steps that are necessary for how to compute a query.
So essentially we're telling the database management system exactly how it should go about computing the query and in the example, here we have two you know more or less equivalent queries on on the one side you're doing the join between R and s first before applying the filter to only the two.
volts that have bid 102 and on the other side, you're filtering s to only the tuples that have 102 bid equals 102 and then performing the joint so kind of these these two.
While they're going to produce the exact same answer, one might be a lot more efficient than the other.
You know.
If you have again a billion tuples in the relation you might want to do the filtering first so you get down just one rather than having to you know find all the billion matches and then then do the filter.
So in this way the the the relational algebra is still procedural and not declarative so really what we'd like is is a declarative language like SqL for exiting the database and that's kind of this idea where you want to state the high level answer or exactly what you want the database management.
system to compute for you rather than telling it how it should go about doing it and essentially you can just leave the low level details about you know how to actually do it to the database management system and if it's well implemented, it should do it a lot better than the kind of high level procedural query you would produce so the relational model just as a concept is independent of any kind of specific query language implementations.
There are a lot that got proposed over the years.
I think there's an alpha proposed originally proposed by Cod, but no one talks about that anymore.
There's quail which increased by someone from Berkeley and SqL kind of emerged as the de facto standard.
Some people call it SqL it SqL both are fine.
I'll still know what you're talking about if you say so it's kind of emerged.
as the de facto standard and there are standard specifications, but pretty much every system implements its own variant, so if you write a query for my sequel, it might not exactly match something that runs in postgres or oracle or sqlite, or whatever so kind of that's the tricky part.
There is a standard that everyone like you know 98 adheres to, but there's this kind of wiggle room where people implement their own special divergences so going way back to the Python example, I gave earlier.
This was the code where you're going to iterate over all the lines and file to find the year that ice cube went solo and if we rewrite that in in a sql query we get this a lot more compact specification for what we want and not how we want the database management system to give it to us so we.
Say we want to select the year from the artists table where the name of the artist is ice cube so that's a lot a higher level and we don't have to worry about kind of the low level details about reading the lines parsing the lines all that stuff we just tell the database management system.
This is what we want.
This is the answer that we want you figure out how to get it back to me so that kind of wraps everything up the the key takeaways are that you know databases are ubiquitous.
They're using all sorts of applications all over the place.
There's any amount of data being managed in an application.
You're using there is almost certainly a database management system behind the scenes.
Relational algebra kind of defines the the primitives for processing queries on a relational database and we're going to see.
relation algebra again when we talk about query, optimization and execution, but for now the next class is going to be specifically about SqL where you go through some of the more advanced topics with with SqL so that's it and we'll see you.
I put in much work with the BMt and the e-trouble get us a saint I grew on the double you.